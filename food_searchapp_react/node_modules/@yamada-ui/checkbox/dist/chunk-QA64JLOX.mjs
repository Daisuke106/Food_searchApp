"use client"

// src/checkbox.tsx
import { ui, useMultiComponentStyle, omitThemeProps } from "@yamada-ui/core";
import {
  useFormControl as useFormControl2,
  useFormControlProps,
  formControlProperties
} from "@yamada-ui/form-control";
import { AnimatePresence, motion } from "@yamada-ui/motion";
import { trackFocusVisible } from "@yamada-ui/use-focus-visible";
import {
  cx as cx2,
  useCallbackRef as useCallbackRef2,
  useSafeLayoutEffect,
  useUpdateEffect,
  handlerAll,
  dataAttr,
  mergeRefs,
  funcAll,
  splitObject
} from "@yamada-ui/utils";
import {
  cloneElement,
  useCallback as useCallback2,
  useEffect,
  useRef,
  useState,
  forwardRef as forwardRef2,
  useId
} from "react";

// src/checkbox-group.tsx
import { useFormControl } from "@yamada-ui/form-control";
import { Flex } from "@yamada-ui/layouts";
import { useControllableState } from "@yamada-ui/use-controllable-state";
import {
  createContext,
  cx,
  isObject,
  useCallbackRef,
  getValidChildren
} from "@yamada-ui/utils";
import { forwardRef, useCallback } from "react";
import { jsx } from "react/jsx-runtime";
var isEvent = (value) => value && isObject(value) && isObject(value.target);
var useCheckboxGroup = ({
  value: valueProp,
  defaultValue = [],
  onChange: onChangeProp,
  isNative,
  ...props
}) => {
  const onChangeRef = useCallbackRef(onChangeProp);
  const [value, setValue] = useControllableState({
    value: valueProp,
    defaultValue,
    onChange: onChangeRef
  });
  const onChange = useCallback(
    (evOrValue) => {
      const isChecked = isEvent(evOrValue) ? evOrValue.target.checked : !value.includes(evOrValue);
      const selectedValue = isEvent(evOrValue) ? evOrValue.target.value : evOrValue;
      const nextValue = isChecked ? [...value, selectedValue] : value.filter((v) => String(v) !== String(selectedValue));
      setValue(nextValue);
    },
    [value, setValue]
  );
  const getCheckboxProps = useCallback(
    (props2, ref = null) => ({
      ...props2,
      ref,
      [isNative ? "checked" : "isChecked"]: value.some(
        (val) => String(props2 == null ? void 0 : props2.value) === String(val)
      ),
      onChange
    }),
    [onChange, isNative, value]
  );
  return { props, value, setValue, onChange, getCheckboxProps };
};
var [CheckboxGroupProvider, useCheckboxGroupContext] = createContext({
  strict: false,
  name: "CheckboxGroupContext"
});
var CheckboxGroup = forwardRef(
  ({
    className,
    size,
    variant,
    colorScheme,
    children,
    items = [],
    direction = "column",
    gap,
    ...props
  }, ref) => {
    const { value, onChange, props: computedProps } = useCheckboxGroup(props);
    const { isRequired, isReadOnly, isDisabled, isInvalid, ...rest } = useFormControl(computedProps);
    const validChildren = getValidChildren(children);
    let computedChildren = [];
    if (!validChildren.length && items.length) {
      computedChildren = items.map(({ label, value: value2, ...props2 }, i) => /* @__PURE__ */ jsx(Checkbox, { value: value2, ...props2, children: label }, i));
    }
    return /* @__PURE__ */ jsx(
      CheckboxGroupProvider,
      {
        value: {
          size,
          variant,
          colorScheme,
          isRequired,
          isReadOnly,
          isDisabled,
          isInvalid,
          value,
          onChange
        },
        children: /* @__PURE__ */ jsx(
          Flex,
          {
            ref,
            className: cx("ui-checkbox-group", className),
            role: "group",
            direction,
            gap: gap != null ? gap : direction === "row" ? "1rem" : void 0,
            ...rest,
            children: children != null ? children : computedChildren
          }
        )
      }
    );
  }
);
CheckboxGroup.displayName = "CheckboxGroup";

// src/checkbox.tsx
import { jsx as jsx2, jsxs } from "react/jsx-runtime";
var useCheckbox = ({
  id,
  ...props
}) => {
  id != null ? id : id = useId();
  const {
    id: _id,
    name,
    value,
    isChecked: isCheckedProp,
    defaultIsChecked,
    tabIndex,
    required,
    disabled,
    readOnly,
    isIndeterminate,
    onChange: onChangeProp,
    onFocus: onFocusProp,
    onBlur: onBlurProp,
    ...computedProps
  } = useFormControlProps({ id, ...props });
  const [{ "aria-readonly": _ariaReadonly, ...formControlProps }, rest] = splitObject(computedProps, formControlProperties);
  const [isFocusVisible, setIsFocusVisible] = useState(false);
  const [isFocused, setFocused] = useState(false);
  const [isHovered, setHovered] = useState(false);
  const [isActive, setActive] = useState(false);
  const inputRef = useRef(null);
  const [isLabel, setIsLabel] = useState(true);
  const [isChecked, setIsChecked] = useState(!!defaultIsChecked);
  const isControlled = isCheckedProp !== void 0;
  const checked = isControlled ? isCheckedProp : isChecked;
  const onChange = useCallbackRef2(
    (ev) => {
      if (readOnly || disabled) {
        ev.preventDefault();
        return;
      }
      if (!isControlled)
        setIsChecked(!checked || isIndeterminate ? true : ev.target.checked);
      onChangeProp == null ? void 0 : onChangeProp(ev);
    },
    [readOnly, disabled, isControlled, checked, isIndeterminate]
  );
  const onFocus = useCallbackRef2(onFocusProp);
  const onBlur = useCallbackRef2(onBlurProp);
  const onKeyDown = useCallback2(
    ({ key }) => {
      if (key === " ")
        setActive(true);
    },
    [setActive]
  );
  const onKeyUp = useCallback2(
    ({ key }) => {
      if (key === " ")
        setActive(false);
    },
    [setActive]
  );
  useEffect(() => {
    return trackFocusVisible(setIsFocusVisible);
  }, []);
  useSafeLayoutEffect(() => {
    if (inputRef.current)
      inputRef.current.indeterminate = Boolean(isIndeterminate);
  }, [isIndeterminate]);
  useUpdateEffect(() => {
    if (disabled)
      setFocused(false);
  }, [disabled, setFocused]);
  useSafeLayoutEffect(() => {
    var _a;
    if (!((_a = inputRef.current) == null ? void 0 : _a.form))
      return;
    inputRef.current.form.onreset = () => setIsChecked(!!defaultIsChecked);
  }, []);
  useSafeLayoutEffect(() => {
    if (!inputRef.current)
      return;
    if (inputRef.current.checked !== checked)
      setIsChecked(inputRef.current.checked);
  }, [inputRef.current]);
  const getContainerProps = useCallback2(
    (props2 = {}, ref = null) => ({
      ...formControlProps,
      ...props2,
      ref: mergeRefs(ref, (el) => {
        if (el)
          setIsLabel(el.tagName === "LABEL");
      }),
      "data-checked": dataAttr(checked),
      onClick: handlerAll(props2.onClick, () => {
        var _a;
        if (isLabel)
          return;
        (_a = inputRef.current) == null ? void 0 : _a.click();
        requestAnimationFrame(() => {
          var _a2;
          return (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
        });
      })
    }),
    [checked, isLabel, formControlProps]
  );
  const getIconProps = useCallback2(
    (props2 = {}, ref = null) => ({
      ...formControlProps,
      ...props2,
      ref,
      "data-active": dataAttr(isActive),
      "data-hover": dataAttr(isHovered),
      "data-checked": dataAttr(checked),
      "data-focus": dataAttr(isFocused),
      "data-focus-visible": dataAttr(isFocused && isFocusVisible),
      "data-indeterminate": dataAttr(isIndeterminate),
      "aria-hidden": true,
      onMouseDown: handlerAll(props2.onMouseDown, (ev) => {
        if (isFocused)
          ev.preventDefault();
        setActive(true);
      }),
      onMouseUp: handlerAll(props2.onMouseUp, () => setActive(false)),
      onMouseEnter: handlerAll(props2.onMouseEnter, () => setHovered(true)),
      onMouseLeave: handlerAll(props2.onMouseLeave, () => setHovered(false))
    }),
    [
      isActive,
      checked,
      isFocused,
      isHovered,
      isFocusVisible,
      isIndeterminate,
      formControlProps
    ]
  );
  const getInputProps = useCallback2(
    (props2 = {}, ref = null) => ({
      ...formControlProps,
      ...props2,
      ref: mergeRefs(inputRef, ref),
      id,
      type: "checkbox",
      name,
      value,
      tabIndex,
      required,
      disabled,
      readOnly,
      checked,
      style: {
        border: "0px",
        clip: "rect(0px, 0px, 0px, 0px)",
        height: "1px",
        width: "1px",
        margin: "-1px",
        padding: "0px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        position: "absolute"
      },
      onChange: handlerAll(props2.onChange, onChange),
      onBlur: handlerAll(props2.onBlur, onBlur, () => setFocused(false)),
      onFocus: handlerAll(props2.onFocus, onFocus, () => setFocused(true)),
      onKeyDown: handlerAll(props2.onKeyDown, onKeyDown),
      onKeyUp: handlerAll(props2.onKeyUp, onKeyUp)
    }),
    [
      formControlProps,
      id,
      name,
      value,
      tabIndex,
      required,
      disabled,
      readOnly,
      checked,
      onChange,
      onBlur,
      onFocus,
      onKeyDown,
      onKeyUp
    ]
  );
  const getLabelProps = useCallback2(
    (props2 = {}, ref = null) => ({
      ...formControlProps,
      ...props2,
      ref,
      "data-checked": dataAttr(checked),
      onMouseDown: handlerAll(props2.onMouseDown, (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
      }),
      onTouchStart: handlerAll(props2.onTouchStart, (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
      })
    }),
    [checked, formControlProps]
  );
  return {
    props: rest,
    isFocusVisible,
    isFocused,
    isHovered,
    isActive,
    isChecked: checked,
    isIndeterminate,
    getContainerProps,
    getIconProps,
    getInputProps,
    getLabelProps
  };
};
var Checkbox = forwardRef2(
  (props, ref) => {
    var _a, _b, _c, _d;
    const group = useCheckboxGroupContext();
    const { value: groupValue, ...groupProps } = { ...group };
    const control = useFormControl2(props);
    const [styles, mergedProps] = useMultiComponentStyle("Checkbox", {
      ...groupProps,
      ...props
    });
    const {
      className,
      gap = "0.5rem",
      isRequired = (_a = groupProps.isRequired) != null ? _a : control.isRequired,
      isReadOnly = (_b = groupProps.isReadOnly) != null ? _b : control.isReadOnly,
      isDisabled = (_c = groupProps.isDisabled) != null ? _c : control.isDisabled,
      isInvalid = (_d = groupProps.isInvalid) != null ? _d : control.isInvalid,
      iconProps,
      inputProps,
      labelProps,
      children,
      ...computedProps
    } = omitThemeProps(mergedProps);
    const isCheckedProp = groupValue && computedProps.value ? groupValue.includes(computedProps.value) : computedProps.isChecked;
    const onChange = groupProps.onChange && computedProps.value ? funcAll(groupProps.onChange, computedProps.onChange) : computedProps.onChange;
    const {
      isChecked,
      isIndeterminate,
      getContainerProps,
      getInputProps,
      getIconProps,
      getLabelProps,
      props: rest
    } = useCheckbox({
      ...computedProps,
      isRequired,
      isReadOnly,
      isDisabled,
      isInvalid,
      isChecked: isCheckedProp,
      onChange
    });
    const { children: customIcon, ...resolvedIconProps } = { ...iconProps };
    const cloneIcon = cloneElement(customIcon != null ? customIcon : /* @__PURE__ */ jsx2(CheckboxIcon, {}), {
      __css: {
        opacity: isChecked || isIndeterminate ? 1 : 0,
        transform: isChecked || isIndeterminate ? "scale(1)" : "scale(0.95)",
        transitionProperty: "transform",
        transitionDuration: "normal"
      },
      isIndeterminate,
      isChecked,
      isRequired,
      isReadOnly,
      isDisabled,
      isInvalid
    });
    return /* @__PURE__ */ jsxs(
      ui.label,
      {
        className: cx2("ui-checkbox", className),
        ...getContainerProps(),
        __css: {
          cursor: "pointer",
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          verticalAlign: "top",
          gap,
          ...styles.container
        },
        ...rest,
        children: [
          /* @__PURE__ */ jsx2(
            ui.input,
            {
              className: "ui-checkbox__input",
              ...getInputProps(inputProps, ref)
            }
          ),
          /* @__PURE__ */ jsx2(
            ui.span,
            {
              className: "ui-checkbox__icon",
              __css: {
                pointerEvents: isReadOnly ? "none" : void 0,
                position: "relative",
                display: "inline-block",
                userSelect: "none",
                ...styles.icon
              },
              ...getIconProps(resolvedIconProps),
              children: cloneIcon
            }
          ),
          /* @__PURE__ */ jsx2(
            ui.span,
            {
              className: "ui-checkbox__label",
              __css: { ...styles.label },
              ...getLabelProps(labelProps),
              children
            }
          )
        ]
      }
    );
  }
);
Checkbox.displayName = "Checkbox";
var CheckboxIcon = ({
  isIndeterminate,
  isChecked,
  isRequired: _isRequired,
  isReadOnly: _isReadOnly,
  isDisabled: _isDisabled,
  isInvalid: _isInvalid,
  ...rest
}) => {
  return /* @__PURE__ */ jsx2(AnimatePresence, { initial: false, children: isIndeterminate || isChecked ? /* @__PURE__ */ jsx2(
    ui.div,
    {
      __css: {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)"
      },
      children: /* @__PURE__ */ jsx2(
        ui.div,
        {
          as: motion.div,
          variants: {
            unchecked: { scale: 0.5 },
            checked: { scale: 1 }
          },
          initial: "unchecked",
          animate: "checked",
          exit: "unchecked",
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          },
          children: isIndeterminate ? /* @__PURE__ */ jsx2(IndeterminateIcon, { ...rest }) : /* @__PURE__ */ jsx2(CheckIcon, { ...rest })
        }
      )
    }
  ) : null });
};
var CheckIcon = (props) => {
  return /* @__PURE__ */ jsx2(
    ui.svg,
    {
      as: motion.svg,
      width: "1.2em",
      viewBox: "0 0 12 10",
      variants: {
        unchecked: {
          opacity: 0,
          strokeDashoffset: 16
        },
        checked: {
          opacity: 1,
          strokeDashoffset: 0,
          transition: { duration: 0.2 }
        }
      },
      style: {
        fill: "none",
        strokeWidth: 2,
        stroke: "currentColor",
        strokeDasharray: 16
      },
      ...props,
      children: /* @__PURE__ */ jsx2("polyline", { points: "1.5 6 4.5 9 10.5 1" })
    }
  );
};
var IndeterminateIcon = (props) => {
  return /* @__PURE__ */ jsx2(
    ui.svg,
    {
      as: motion.svg,
      width: "1.2em",
      viewBox: "0 0 24 24",
      variants: {
        unchecked: {
          scaleX: 0.65,
          opacity: 0
        },
        checked: {
          scaleX: 1,
          opacity: 1,
          transition: {
            scaleX: { duration: 0 },
            opacity: { duration: 0.02 }
          }
        }
      },
      style: { stroke: "currentColor", strokeWidth: 4 },
      ...props,
      children: /* @__PURE__ */ jsx2("line", { x1: "21", x2: "3", y1: "12", y2: "12" })
    }
  );
};

export {
  useCheckbox,
  Checkbox,
  CheckboxIcon,
  useCheckboxGroup,
  useCheckboxGroupContext,
  CheckboxGroup
};
//# sourceMappingURL=chunk-QA64JLOX.mjs.map