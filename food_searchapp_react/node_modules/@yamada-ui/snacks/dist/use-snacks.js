"use client"
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/use-snacks.tsx
var use_snacks_exports = {};
__export(use_snacks_exports, {
  useSnacks: () => useSnacks
});
module.exports = __toCommonJS(use_snacks_exports);
var import_alert = require("@yamada-ui/alert");
var import_close_button = require("@yamada-ui/close-button");
var import_core = require("@yamada-ui/core");
var import_utils = require("@yamada-ui/utils");
var import_react = require("react");
var import_jsx_runtime = require("react/jsx-runtime");
var createRender = (options) => {
  const { component } = options;
  const Render = (props) => {
    if (typeof component === "function") {
      return component({ ...props, ...options });
    } else {
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Snack, { ...props, ...options });
    }
  };
  return Render;
};
var counter = 0;
var useSnacks = (defaultOptions = {}) => {
  const [items, setItems] = (0, import_react.useState)([]);
  const { theme } = (0, import_core.useTheme)();
  const themeOptions = (0, import_react.useMemo)(
    () => {
      var _a, _b;
      return (_b = (_a = theme.__config.snacks) == null ? void 0 : _a.options) != null ? _b : {};
    },
    [theme]
  );
  const computedOptions = (0, import_react.useMemo)(
    () => (0, import_utils.merge)(themeOptions, defaultOptions),
    [defaultOptions, themeOptions]
  );
  const { direction, startIndex, limit = 3 } = computedOptions;
  const getOptions = (0, import_react.useCallback)(
    (options) => (0, import_utils.merge)(computedOptions, options),
    [computedOptions]
  );
  const snack = (0, import_react.useMemo)(() => {
    const methods = (options = {}) => {
      options = getOptions(options);
      const message = createRender(options);
      counter += 1;
      let {
        id = counter,
        duration,
        onCloseComplete,
        status,
        boxShadow,
        style
      } = options;
      const onClose = () => setItems((prev) => prev.filter((child) => child.id !== id));
      const snack2 = {
        id,
        status,
        duration,
        message,
        onClose,
        onCloseComplete,
        boxShadow,
        style
      };
      setItems((prev) => [
        ...prev.splice(-1 * ((limit != null ? limit : Infinity) - 1)),
        snack2
      ]);
      return id;
    };
    methods.update = (id, options) => {
      options = getOptions(options);
      setItems(
        (prev) => prev.map((props) => {
          if (props.id === id) {
            return { ...props, ...options, message: createRender(options) };
          } else {
            return props;
          }
        })
      );
    };
    methods.closeAll = () => {
      setItems([]);
    };
    methods.close = (id) => {
      setItems((prev) => prev.filter((props) => props.id !== id));
    };
    methods.isActive = (id) => !!items.find((props) => props.id === id);
    return methods;
  }, [items, limit, getOptions]);
  const snacks = (0, import_react.useMemo)(
    () => ({ direction, startIndex, items }),
    [direction, startIndex, items]
  );
  return { snack, snacks };
};
var defaultBoxShadow = [
  "0 -1px 3px 0 rgba(0, 0, 0, 0.1), 0 -1px 2px 0 rgba(0, 0, 0, 0.06), 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
  "0px 0px 0px 1px rgba(0, 0, 0, 0.1), 0px -1px 2px rgba(0, 0, 0, 0.2), 0px 1px 2px rgba(0, 0, 0, 0.2)"
];
var Snack = (0, import_core.forwardRef)(
  ({
    variant = "basic",
    colorScheme,
    status,
    icon,
    title,
    description,
    isClosable = true,
    boxShadow = defaultBoxShadow,
    className,
    index,
    onClose
  }, ref) => {
    return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      import_alert.Alert,
      {
        ref,
        className: (0, import_utils.cx)("ui-snack", className),
        status,
        variant,
        colorScheme,
        alignItems: "start",
        boxShadow: index ? boxShadow : void 0,
        pe: isClosable ? 8 : void 0,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            import_alert.AlertIcon,
            {
              variant: icon == null ? void 0 : icon.variant,
              className: "ui-snack__icon",
              ...(icon == null ? void 0 : icon.color) ? { color: icon.color } : {},
              children: icon == null ? void 0 : icon.children
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_core.ui.div, { flex: "1", children: [
            title ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_alert.AlertTitle, { className: "ui-snack__title", lineClamp: 1, children: title }) : null,
            description ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_alert.AlertDescription, { className: "ui-snack__desc", lineClamp: 3, children: description }) : null
          ] }),
          isClosable ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            import_close_button.CloseButton,
            {
              className: "ui-snack__close-button",
              size: "sm",
              onClick: onClose,
              position: "absolute",
              top: 2,
              right: 2
            }
          ) : null
        ]
      }
    );
  }
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useSnacks
});
//# sourceMappingURL=use-snacks.js.map