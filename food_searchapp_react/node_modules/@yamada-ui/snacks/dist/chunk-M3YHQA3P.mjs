"use client"

// src/snacks.tsx
import { ui, forwardRef, useTheme } from "@yamada-ui/core";
import { AnimatePresence, Motion, useIsPresent } from "@yamada-ui/motion";
import { useTimeout } from "@yamada-ui/use-timeout";
import { useToken } from "@yamada-ui/use-token";
import { useValue } from "@yamada-ui/use-value";
import { calc, cx, noop, runIfFunc, useUpdateEffect } from "@yamada-ui/utils";
import { createRef, memo, useEffect, useMemo, useRef, useState } from "react";
import { jsx } from "react/jsx-runtime";
var defaultContainerVariants = {
  initial: { padding: 0 },
  animate: ({ gutter }) => ({
    padding: `${gutter[0]} 0 ${gutter[1]}`,
    transition: { duration: 0.4 }
  }),
  exit: { padding: 0 }
};
var defaultListVariants = {
  initial: { opacity: 1, height: 0 },
  animate: ({ height }) => ({
    opacity: 1,
    height,
    transition: { duration: 0.4 }
  }),
  exit: { opacity: 0, height: 0 }
};
var Snacks = forwardRef(
  ({
    className,
    snacks,
    containerVariants = defaultContainerVariants,
    listVariants = defaultListVariants,
    listProps,
    ...props
  }, ref) => {
    var _a, _b;
    const { items, ...computedSnacks } = snacks;
    const count = items.length;
    const refMap = useRef(/* @__PURE__ */ new Map());
    const [height, setHeight] = useState(0);
    const [isExist, setIsExist] = useState(!!count);
    const { theme } = useTheme();
    const {
      variants,
      direction = "top",
      startIndex = 0,
      gutter = [0, 0],
      gap = "fallback(4, 1rem)",
      negateMargin = true,
      ...rest
    } = useMemo(
      () => ({ ...computedSnacks, ...theme.__config.snacks, ...props }),
      [computedSnacks, theme, props]
    );
    const top = (_a = useToken("spaces", useValue(gutter[0]))) != null ? _a : 0;
    const bottom = (_b = useToken("spaces", useValue(gutter[1]))) != null ? _b : 0;
    const negatedTop = calc(top).negate().toString();
    const negatedBottom = calc(bottom).negate().toString();
    const isShow = !!count || isExist;
    const css = {
      w: "100%",
      var: [{ __prefix: "ui", name: "space", token: "spaces", value: gap }],
      margin: negateMargin ? `${negatedTop} 0 ${negatedBottom}` : void 0
    };
    useEffect(() => {
      let height2 = 0;
      if (!count)
        return;
      const refs = [...refMap.current.values()].slice(0, count);
      for (const ref2 of refs) {
        if (!ref2.current)
          continue;
        let { offsetHeight, offsetTop } = ref2.current;
        offsetHeight += offsetTop;
        if (offsetHeight > height2)
          height2 = offsetHeight;
      }
      setHeight(height2);
    }, [count, direction]);
    useUpdateEffect(() => {
      if (!!count)
        setIsExist(true);
    }, [count]);
    return /* @__PURE__ */ jsx(AnimatePresence, { initial: false, children: isShow ? /* @__PURE__ */ jsx(
      Motion,
      {
        ref,
        className: cx("ui-snacks", className),
        __css: css,
        variants: containerVariants,
        custom: { gutter: [top, bottom] },
        initial: "initial",
        animate: "animate",
        exit: "exit",
        ...rest,
        children: /* @__PURE__ */ jsx(
          Motion,
          {
            as: "ul",
            className: "ui-snacks__list",
            variants: listVariants,
            custom: { height },
            initial: "initial",
            animate: "animate",
            exit: "exit",
            __css: {
              position: "relative",
              w: "100%"
            },
            ...listProps,
            children: /* @__PURE__ */ jsx(
              AnimatePresence,
              {
                onExitComplete: () => {
                  if (!count)
                    setIsExist(false);
                },
                children: items.map((props2, index) => {
                  const ref2 = createRef();
                  refMap.current.set(index, ref2);
                  return /* @__PURE__ */ jsx(
                    SnackComponent,
                    {
                      ref: ref2,
                      index,
                      lastIndex: count - index - 1,
                      startIndex,
                      variants,
                      direction,
                      ...props2
                    },
                    props2.id
                  );
                })
              }
            )
          }
        )
      }
    ) : null });
  }
);
var defaultItemVariants = {
  initial: ({ index, direction }) => ({
    opacity: 0,
    ...index ? { y: (direction === "top" ? -1 : 1) * 16 } : {}
  }),
  animate: ({ index }) => ({
    opacity: 1,
    y: 0,
    transition: {
      delay: !index ? 0.4 : 0,
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  }),
  exit: {
    opacity: 0,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
};
var SnackComponent = memo(
  forwardRef(
    ({
      index,
      lastIndex,
      startIndex,
      direction,
      variants = defaultItemVariants,
      duration = null,
      message,
      onClose: onCloseProp,
      onCloseComplete,
      style
    }, ref) => {
      const [delay, setDelay] = useState(duration);
      const isPresent = useIsPresent();
      const onClose = isPresent ? onCloseProp : noop;
      const onMouseEnter = () => setDelay(null);
      const onMouseLeave = () => setDelay(duration);
      const zIndex = startIndex + index;
      const space = `calc(var(--ui-space) * ${direction === "top" ? lastIndex : index})`;
      const css = {
        position: "absolute",
        top: space,
        left: 0,
        right: 0,
        zIndex,
        w: "100%",
        maxW: "100%",
        ...style
      };
      useUpdateEffect(() => {
        if (!isPresent)
          onCloseComplete == null ? void 0 : onCloseComplete();
      }, [isPresent]);
      useUpdateEffect(() => {
        setDelay(duration);
      }, [duration]);
      useTimeout(onClose, delay);
      return /* @__PURE__ */ jsx(ui.li, { ref, className: "ui-snacks__item", __css: css, children: /* @__PURE__ */ jsx(
        Motion,
        {
          className: "ui-snacks__item-inner",
          layout: true,
          variants,
          custom: { index, lastIndex, direction },
          initial: "initial",
          animate: "animate",
          exit: "exit",
          onHoverStart: onMouseEnter,
          onHoverEnd: onMouseLeave,
          children: runIfFunc(message, { index, onClose })
        }
      ) });
    }
  )
);
SnackComponent.displayName = "SnackComponent";

export {
  Snacks
};
//# sourceMappingURL=chunk-M3YHQA3P.mjs.map