{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import {\n  clampNumber,\n  countDecimal,\n  toPrecision,\n  useCallbackRef,\n} from \"@yamada-ui/utils\"\nimport { useCallback, useState } from \"react\"\n\nexport type UseCounterProps = {\n  /**\n   * The value of the counter.\n   * Should be less than `max` and greater than `min`.\n   */\n  value?: string | number\n  /**\n   * The initial value of the counter.\n   * Should be less than `max` and greater than `min`.\n   */\n  defaultValue?: string | number\n  /**\n   * The step used to increment or decrement the value.\n   *\n   * @default 1\n   */\n  step?: number\n  /**\n   * The minimum value of the counter\n   *\n   * @default Number.MIN_SAFE_INTEGER\n   */\n  min?: number\n  /**\n   * The maximum value of the counter\n   *\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  max?: number\n  /**\n   * The number of decimal points used to round the value.\n   */\n  precision?: number\n  /**\n   * This controls the value update behavior in general.\n   *\n   * - If `true` and you use the stepper or up/down arrow keys,\n   * the value will not exceed the `max` or go lower than `min`.\n   *\n   * - If `false`, the value will be allowed to go out of range.\n   *\n   * @default true\n   */\n  keepWithinRange?: boolean\n  /**\n   * The callback fired when the value changes.\n   */\n  onChange?: (valueAsString: string, valueAsNumber: number) => void\n}\n\nexport const useCounter = ({\n  min = Number.MIN_SAFE_INTEGER,\n  max = Number.MAX_SAFE_INTEGER,\n  keepWithinRange = true,\n  ...props\n}: UseCounterProps = {}) => {\n  const onChange = useCallbackRef(props.onChange)\n\n  const [defaultValue, setValue] = useState<string | number>(() => {\n    if (props.defaultValue == null) return \"\"\n\n    return casting(props.defaultValue, props.step ?? 1, props.precision) ?? \"\"\n  })\n\n  const isControlled = typeof props.value !== \"undefined\"\n  const value = isControlled ? (props.value as string | number) : defaultValue\n\n  const countDecimal = getCountDecimal(parse(value), props.step ?? 1)\n\n  const precision = props.precision ?? countDecimal\n\n  const update = useCallback(\n    (next: string | number) => {\n      if (next === value) return\n\n      if (!isControlled) setValue(next.toString())\n\n      onChange(next.toString(), parse(next))\n    },\n    [onChange, isControlled, value],\n  )\n\n  const clamp = useCallback(\n    (value: number) => {\n      let nextValue = value\n\n      if (keepWithinRange) nextValue = clampNumber(nextValue, min, max)\n\n      return toPrecision(nextValue, precision)\n    },\n    [precision, keepWithinRange, max, min],\n  )\n\n  const increment = useCallback(\n    (step = props.step ?? 1) => {\n      let next: string | number\n\n      if (value === \"\") {\n        next = parse(step)\n      } else {\n        next = parse(value) + step\n      }\n\n      next = clamp(next as number)\n\n      update(next)\n    },\n    [clamp, props.step, update, value],\n  )\n\n  const decrement = useCallback(\n    (step = props.step ?? 1) => {\n      let next: string | number\n\n      if (value === \"\") {\n        next = parse(-step)\n      } else {\n        next = parse(value) - step\n      }\n\n      next = clamp(next as number)\n\n      update(next)\n    },\n    [clamp, props.step, update, value],\n  )\n\n  const reset = useCallback(() => {\n    let next: string | number\n\n    if (props.defaultValue == null) {\n      next = \"\"\n    } else {\n      next =\n        casting(props.defaultValue, props.step ?? 1, props.precision) ?? min\n    }\n\n    update(next)\n  }, [props.defaultValue, props.precision, props.step, update, min])\n\n  const cast = useCallback(\n    (value: string | number) => {\n      const nextValue = casting(value, props.step ?? 1, precision) ?? min\n\n      update(nextValue)\n    },\n    [precision, props.step, update, min],\n  )\n\n  const valueAsNumber = parse(value)\n\n  const isOut = valueAsNumber < min || max < valueAsNumber\n  const isMax = valueAsNumber === max\n  const isMin = valueAsNumber === min\n\n  return {\n    isOut,\n    isMax,\n    isMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast,\n    setValue,\n  }\n}\n\nexport type UseCounterReturn = ReturnType<typeof useCounter>\n\nconst parse = (value: string | number): number =>\n  parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"))\n\nconst getCountDecimal = (value: number, step: number): number =>\n  Math.max(countDecimal(step), countDecimal(value))\n\nconst casting = (\n  value: string | number,\n  step: number,\n  precision?: number,\n): string | undefined => {\n  value = parse(value)\n\n  return !Number.isNaN(value)\n    ? toPrecision(value, precision ?? getCountDecimal(value, step))\n    : undefined\n}\n"],"mappings":"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","names":["_a","_b","countDecimal","value"]}