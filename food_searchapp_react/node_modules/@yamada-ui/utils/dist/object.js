"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/object.ts
var object_exports = {};
__export(object_exports, {
  assignAfter: () => assignAfter,
  filterObject: () => filterObject,
  filterUndefined: () => filterUndefined,
  flattenObject: () => flattenObject,
  getMemoizedObject: () => getMemoizedObject,
  getObject: () => getObject,
  keysFormObject: () => keysFormObject,
  memoizeObject: () => memoizeObject,
  merge: () => merge,
  objectFromEntries: () => objectFromEntries,
  omitObject: () => omitObject,
  pickObject: () => pickObject,
  replaceObject: () => replaceObject,
  splitObject: () => splitObject
});
module.exports = __toCommonJS(object_exports);

// src/assertion.ts
var isString = (value) => Object.prototype.toString.call(value) === "[object String]";
var isObject = (value) => value !== null && (typeof value === "object" || typeof value === "function") && !isArray(value);
var isArray = (value) => Array.isArray(value);
var isFunction = (value) => typeof value === "function";

// src/object.ts
var omitObjectHelper = (obj, path) => {
  if (!path.length)
    return obj;
  const [primaryKey, ...restKeys] = path;
  if (restKeys.length === 0 && primaryKey in obj) {
    const { [primaryKey]: _, ...rest } = obj;
    return rest;
  }
  if (obj[primaryKey] && isObject(obj[primaryKey])) {
    return {
      ...obj,
      [primaryKey]: omitObjectHelper(obj[primaryKey], restKeys)
    };
  }
  return obj;
};
var omitObject = (obj, keys) => {
  return keys.reduce((prev, key) => {
    const path = isString(key) ? key.split(".") : [];
    return omitObjectHelper(prev, path);
  }, obj);
};
var pickObject = (obj, keys, fallbackValue = "__fallback") => keys.reduce((prev, key) => {
  const path = isString(key) ? key.split(".") : [];
  if (!path.length)
    return prev;
  const value = getMemoizedObject(obj, key, fallbackValue);
  if (value === fallbackValue)
    return prev;
  prev = merge(
    prev,
    path.reduceRight(
      (prev2, key2) => ({ [key2]: key2 === path.at(-1) ? value : prev2 }),
      {}
    )
  );
  return prev;
}, {});
var splitObject = (obj, keys) => {
  const picked = {};
  const omitted = {};
  for (const [key, value] of Object.entries(obj)) {
    if (keys.includes(key)) {
      picked[key] = value;
    } else {
      omitted[key] = value;
    }
  }
  return [picked, omitted];
};
var filterObject = (obj, func) => {
  const result = {};
  Object.entries(obj).forEach(([key, value]) => {
    const shouldPass = func(key, value, obj);
    if (shouldPass)
      result[key] = value;
  });
  return result;
};
var filterUndefined = (obj) => filterObject(obj, (_, val) => val !== null && val !== void 0);
var merge = (target, source, mergeArray = false) => {
  let result = Object.assign({}, target);
  if (isObject(source)) {
    if (isObject(target)) {
      for (const [sourceKey, sourceValue] of Object.entries(source)) {
        const targetValue = target[sourceKey];
        if (mergeArray && isArray(sourceValue) && isArray(targetValue)) {
          result[sourceKey] = targetValue.concat(...sourceValue);
        } else if (!isFunction(sourceValue) && isObject(sourceValue) && target.hasOwnProperty(sourceKey)) {
          result[sourceKey] = merge(targetValue, sourceValue, mergeArray);
        } else {
          Object.assign(result, { [sourceKey]: sourceValue });
        }
      }
    } else {
      result = source;
    }
  }
  return result;
};
var flattenObject = (obj, maxDepth = Infinity, omitKeys = []) => {
  if (!isObject(obj) && !isArray(obj) || !maxDepth)
    return obj;
  return Object.entries(obj).reduce((result, [key, value]) => {
    if (isObject(value) && !Object.keys(value).some((key2) => omitKeys.includes(key2))) {
      Object.entries(flattenObject(value, maxDepth - 1, omitKeys)).forEach(
        ([childKey, childValue]) => {
          result[`${key}.${childKey}`] = childValue;
        }
      );
    } else {
      result[key] = value;
    }
    return result;
  }, {});
};
var objectFromEntries = (entries) => entries.reduce((result, [key, value]) => {
  result[key] = value;
  return result;
}, {});
var keysFormObject = (obj) => Object.keys(obj);
var replaceObject = (objOrArray, callBack) => {
  if (isArray(objOrArray)) {
    return objOrArray.map(callBack);
  } else if (isObject(objOrArray)) {
    return Object.entries(objOrArray).reduce((obj, [key, value]) => {
      obj[key] = callBack(value);
      return obj;
    }, {});
  } else {
    return callBack(objOrArray);
  }
};
var getObject = (obj, path, fallback, i) => {
  const k = typeof path === "string" ? path.split(".") : [path];
  for (i = 0; i < k.length; i += 1) {
    if (!obj)
      break;
    obj = obj[k[i]];
  }
  return obj === void 0 ? fallback : obj;
};
var memoizeObject = (func) => {
  const cache = /* @__PURE__ */ new WeakMap();
  const memoizedFunc = (obj, path, fallback, i) => {
    if (typeof obj === "undefined")
      return func(obj, path, fallback);
    if (!cache.has(obj))
      cache.set(obj, /* @__PURE__ */ new Map());
    const map = cache.get(obj);
    if (map.has(path))
      return map.get(path);
    const value = func(obj, path, fallback, i);
    map.set(path, value);
    return value;
  };
  return memoizedFunc;
};
var getMemoizedObject = memoizeObject(getObject);
var assignAfter = (target, ...sources) => {
  if (target == null)
    throw new TypeError("Cannot convert undefined or null to object");
  const result = { ...target };
  for (const nextSource of sources) {
    if (nextSource == null)
      continue;
    for (const nextKey in nextSource) {
      if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey))
        continue;
      if (nextKey in result)
        delete result[nextKey];
      result[nextKey] = nextSource[nextKey];
    }
  }
  return result;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assignAfter,
  filterObject,
  filterUndefined,
  flattenObject,
  getMemoizedObject,
  getObject,
  keysFormObject,
  memoizeObject,
  merge,
  objectFromEntries,
  omitObject,
  pickObject,
  replaceObject,
  splitObject
});
//# sourceMappingURL=object.js.map