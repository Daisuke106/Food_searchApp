import { Dict, Union } from './index.types.mjs';

declare const omitObject: <Y extends Dict, M extends keyof Y, D extends unknown>(obj: Y, keys: Union<M>[]) => D extends unknown ? Omit<Y, M> : D;
declare const pickObject: <Y extends Dict, M extends keyof Y, D extends unknown>(obj: Y, keys: Union<M>[], fallbackValue?: string) => D extends unknown ? { [H in M]: Y[H]; } : D;
declare const splitObject: <T extends Dict, K extends keyof T>(obj: T, keys: K[]) => [{ [P in K]: T[P]; }, Omit<T, K>];
declare const filterObject: <T extends Dict, K extends Dict>(obj: T, func: (key: keyof T, value: T[keyof T], obj: T) => boolean) => K;
declare const filterUndefined: <T extends Dict>(obj: T) => T;
declare const merge: <T extends Dict>(target: any, source: any, mergeArray?: boolean) => T;
declare const flattenObject: <T extends Dict>(obj: any, maxDepth?: number, omitKeys?: string[]) => T;
declare const objectFromEntries: <T extends Dict>(entries: any[][]) => T;
declare const keysFormObject: <T extends Dict>(obj: T) => (keyof T)[];
declare const replaceObject: <T extends unknown>(objOrArray: T, callBack: (value: any) => any) => T;
declare const getObject: (obj: Dict, path: string | number, fallback?: any, i?: number) => any;
declare const memoizeObject: (func: typeof getObject) => <T extends unknown = any>(obj: Dict, path: string | number, fallback?: any, i?: number) => T;
declare const getMemoizedObject: <T extends unknown = any>(obj: Dict, path: string | number, fallback?: any, i?: number) => T;
declare const assignAfter: (target: Record<string, any>, ...sources: any[]) => Record<string, unknown>;

export { assignAfter, filterObject, filterUndefined, flattenObject, getMemoizedObject, getObject, keysFormObject, memoizeObject, merge, objectFromEntries, omitObject, pickObject, replaceObject, splitObject };
