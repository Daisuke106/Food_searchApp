{"version":3,"sources":["../src/color.ts","../src/assertion.ts","../src/object.ts"],"sourcesContent":["import * as c from \"color2k\"\nimport type { Dict } from \".\"\nimport { getMemoizedObject as get, isArray, isNumber } from \".\"\n\ntype ColorMode = \"light\" | \"dark\"\n\nexport type ColorFormat = \"hex\" | \"hexa\" | \"rgba\" | \"rgb\" | \"hsl\" | \"hsla\"\n\nexport const tones = [\n  50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950,\n] as const\n\nexport const isGray = (colorScheme: string) =>\n  colorScheme === \"gray\" || colorScheme === \"neutral\"\n\nexport const isAccessible = (colorScheme: string) =>\n  colorScheme === \"yellow\" || colorScheme === \"cyan\" || colorScheme === \"lime\"\n\nexport const getColor =\n  (color: string, fallback: string = \"#000000\") =>\n  (theme: Dict = {}, colorMode?: ColorMode) => {\n    const [token, hue] = color.split(\".\")\n\n    const [, relatedToken] =\n      Object.entries<string>(theme.semantics?.colorSchemes ?? {}).find(\n        ([semanticToken]) => token === semanticToken,\n      ) ?? []\n\n    if (relatedToken) color = `${relatedToken}.${hue}`\n\n    const hex = get<\n      string | number | [string | number, string | number] | undefined\n    >(theme, `colors.${color}`, color)\n\n    try {\n      if (isArray(hex)) {\n        return c.toHex(String(colorMode !== \"dark\" ? hex[0] : hex[1]))\n      } else {\n        return c.toHex(String(hex))\n      }\n    } catch {\n      try {\n        return c.toHex(fallback)\n      } catch {\n        return \"#000000\"\n      }\n    }\n  }\n\nexport const lightenColor =\n  (color: string, amount: number) => (theme?: Dict, colorMode?: ColorMode) => {\n    const raw = getColor(color, color)(theme, colorMode)\n\n    return c.toHex(c.lighten(raw, amount / 100))\n  }\n\nexport const darkenColor =\n  (color: string, amount: number) => (theme?: Dict, colorMode?: ColorMode) => {\n    const raw = getColor(color, color)(theme, colorMode)\n\n    return c.toHex(c.darken(raw, amount / 100))\n  }\n\nexport const tintColor =\n  (color: string, amount: number) => (theme?: Dict, colorMode?: ColorMode) => {\n    const raw = getColor(color, color)(theme, colorMode)\n\n    return c.toHex(c.mix(raw, \"#fff\", amount / 100))\n  }\n\nexport const shadeColor =\n  (color: string, amount: number) => (theme?: Dict, colorMode?: ColorMode) => {\n    const raw = getColor(color, color)(theme, colorMode)\n\n    return c.toHex(c.mix(raw, \"#000\", amount / 100))\n  }\n\nexport const transparentizeColor =\n  (color: string, alpha: number) => (theme?: Dict, colorMode?: ColorMode) => {\n    const raw = getColor(color, color)(theme, colorMode)\n\n    return c.transparentize(raw, 1 - alpha)\n  }\n\nexport const randomColor = ({\n  string,\n  colors,\n}: { string?: string; colors?: string[] } = {}) => {\n  const fallback = randomHex()\n\n  if (string && colors) return randomColorFromList(string, colors)\n\n  if (string && !colors) return randomColorFromString(string)\n\n  if (colors && !string) return randomFromList(colors)\n\n  return fallback\n}\n\nconst randomHex = () =>\n  `#${Math.floor(Math.random() * 0xffffff)\n    .toString(16)\n    .padEnd(6, \"0\")}`\n\nconst randomColorFromString = (str: string) => {\n  let hash = 0\n\n  if (str.length === 0) return hash.toString()\n\n  for (let i = 0; i < str.length; i += 1) {\n    hash = str.charCodeAt(i) + ((hash << 5) - hash)\n    hash = hash & hash\n  }\n\n  let color = \"#\"\n\n  for (let j = 0; j < 3; j += 1) {\n    const value = (hash >> (j * 8)) & 255\n\n    color += `00${value.toString(16)}`.substr(-2)\n  }\n\n  return color\n}\n\nconst randomColorFromList = (str: string, list: string[]) => {\n  let index = 0\n\n  if (str.length === 0) return list[0]\n\n  for (let i = 0; i < str.length; i += 1) {\n    index = str.charCodeAt(i) + ((index << 5) - index)\n\n    index = index & index\n  }\n\n  index = ((index % list.length) + list.length) % list.length\n\n  return list[index]\n}\n\nconst randomFromList = (list: string[]) =>\n  list[Math.floor(Math.random() * list.length)]\n\nconst getBrightness = (color: string) => {\n  const [r, g, b] = c.parseToRgba(color)\n\n  return (r * 299 + g * 587 + b * 114) / 1000\n}\n\nexport const isTone =\n  (color: string) => (theme?: Dict, colorMode?: ColorMode) => {\n    const raw = theme ? getColor(color)(theme, colorMode) : color\n\n    const brightness = getBrightness(raw)\n\n    const isDark = brightness < 128\n\n    return isDark ? \"dark\" : \"light\"\n  }\n\nexport const isLight =\n  (color: string) => (theme?: Dict, colorMode?: ColorMode) =>\n    isTone(color)(theme, colorMode) === \"dark\"\n\nexport const isDark =\n  (color: string) => (theme?: Dict, colorMode?: ColorMode) =>\n    isTone(color)(theme, colorMode) === \"light\"\n\nexport const convertColor =\n  (color: string, fallback?: string) =>\n  (format: ColorFormat): string | undefined => {\n    try {\n      const isAlpha = format.endsWith(\"a\")\n\n      if (/^[0-9a-fA-F]{6}$/.test(color)) color = \"#\" + color\n\n      if (format.startsWith(\"hex\")) {\n        let hexa = c.toHex(color)\n\n        if (isAlpha) {\n          if (hexa.length === 7) hexa += \"ff\"\n        } else {\n          hexa = hexa.replace(/(?<=^#([0-9a-fA-F]{6}))[0-9a-fA-F]{2}$/, \"\")\n        }\n\n        return hexa\n      } else if (format.startsWith(\"hsl\")) {\n        let hsla = c.toHsla(color)\n\n        if (!isAlpha) {\n          hsla = hsla.replace(/hsla/, \"hsl\")\n          hsla = hsla.replace(/,\\s*\\d+(\\.\\d+)?\\)$/, \")\")\n        }\n\n        return hsla\n      } else {\n        let rgba = c.toRgba(color)\n\n        if (!isAlpha) {\n          rgba = rgba.replace(/rgba/, \"rgb\")\n          rgba = rgba.replace(/,\\s*\\d+(\\.\\d+)?\\)$/, \")\")\n        }\n\n        return rgba\n      }\n    } catch {\n      if (fallback) return convertColor(fallback)(format)\n    }\n  }\n\nexport const calcFormat = (color: string): ColorFormat => {\n  if (color.startsWith(\"hsl\")) {\n    return color.startsWith(\"hsla\") ? \"hsla\" : \"hsl\"\n  } else if (color.startsWith(\"rgb\")) {\n    return color.startsWith(\"rgba\") ? \"rgba\" : \"rgb\"\n  } else {\n    return color.length === 9 ? \"hexa\" : \"hex\"\n  }\n}\n\nexport const getAlpha = (color: string) => c.parseToRgba(color)[3]\n\nexport const alphaToHex = (a: number) => {\n  if (0 > a) a = 0\n  if (1 < a) a = 1\n\n  return Math.round(a * 255)\n    .toString(16)\n    .padStart(2, \"0\")\n}\n\nexport const parseToRgba = (color: string, fallback?: string) => {\n  try {\n    if (/^[0-9a-fA-F]{6}$/.test(color)) color = \"#\" + color\n\n    return c.parseToRgba(color)\n  } catch {\n    if (fallback) return c.parseToRgba(fallback)\n  }\n}\n\nexport const parseToHsla = (color: string, fallback?: string) => {\n  try {\n    if (/^[0-9a-fA-F]{6}$/.test(color)) color = \"#\" + color\n\n    return c.parseToHsla(color)\n  } catch {\n    if (fallback) return c.parseToHsla(fallback)\n  }\n}\n\nexport const parseToHsv = (\n  color: string,\n  fallback?: string,\n): [number, number, number, number] => {\n  let [r, g, b, a] = parseToRgba(color, fallback) ?? [255, 255, 255, 1]\n\n  r = r / 255\n  g = g / 255\n  b = b / 255\n\n  const [min, max] = [Math.min(r, g, b), Math.max(r, g, b)]\n  const delta = max - min\n\n  let [h, v, s] = [0, max, max == 0 ? 0 : delta / max]\n\n  switch (min) {\n    case max:\n      h = 0\n      break\n\n    case r:\n      h = 60 * ((b - g) / delta) + 180\n      break\n\n    case g:\n      h = 60 * ((r - b) / delta) + 300\n      break\n\n    case b:\n      h = 60 * ((g - r) / delta) + 60\n      break\n  }\n\n  return [h, s, v, a]\n}\n\nexport const rgbaTo =\n  ([r, g, b, a]: [number, number, number, number], fallback?: string) =>\n  (format: ColorFormat = \"hex\") =>\n    convertColor(c.rgba(r, g, b, a), fallback)(format)\n\nexport const hslaTo =\n  ([h, s, l, a]: [number, number, number, number], fallback?: string) =>\n  (format: ColorFormat = \"hex\") =>\n    convertColor(c.hsla(h, s, l, a), fallback)(format)\n\nexport const hsvTo =\n  ([h, s, v, a]: [number, number, number, number?], fallback?: string) =>\n  (format: ColorFormat = \"hex\"): string | undefined => {\n    h = h / 60\n\n    let rgb: [number, number, number] = [v, v, v]\n\n    let i = Math.floor(h)\n    let f = h - i\n    let p = v * (1 - s)\n    let q = v * (1 - s * f)\n    let t = v * (1 - s * (1 - f))\n\n    switch (i) {\n      case 0:\n      case 6:\n        rgb = [v, t, p]\n        break\n\n      case 1:\n        rgb = [q, v, p]\n        break\n\n      case 2:\n        rgb = [p, v, t]\n        break\n\n      case 3:\n        rgb = [p, q, v]\n        break\n\n      case 4:\n        rgb = [t, p, v]\n        break\n\n      case 5:\n        rgb = [v, p, q]\n        break\n    }\n\n    let color = `rgb(${rgb.map((v) => Math.round(v * 255)).join(\", \")})`\n\n    if (isNumber(a)) color = color.replace(/\\)$/, `, ${a})`)\n\n    return convertColor(color, fallback)(format)\n  }\n\nexport const sameColor = (\n  color: string | undefined,\n  comparison: string | undefined,\n) => {\n  if (!color) return false\n  if (!comparison) return false\n\n  const a = parseToRgba(color) ?? []\n  const b = parseToRgba(comparison) ?? []\n\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]\n}\n","import type { Dict } from \".\"\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\"\n\nexport const isNotNumber = (value: any): boolean =>\n  typeof value !== \"number\" || Number.isNaN(value) || !Number.isFinite(value)\n\nexport const isNumeric = (value: any): boolean =>\n  value != null &&\n  parseFloat(value.toString()) - parseFloat(value.toString()) + 1 >= 0\n\nexport const isString = (value: any): value is string =>\n  Object.prototype.toString.call(value) === \"[object String]\"\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\"\n\nexport const isUndefined = (value: any): value is undefined =>\n  typeof value === \"undefined\" && value === undefined\n\nexport const isNull = (value: any): value is null => value === null\n\nexport const isObject = <T extends Dict>(value: any): value is T =>\n  value !== null &&\n  (typeof value === \"object\" || typeof value === \"function\") &&\n  !isArray(value)\n\nexport const isArray = <T extends any[]>(value: any): value is T =>\n  Array.isArray(value)\n\nexport const isEmpty = (value: any): boolean =>\n  !isArray(value) || !value.length || value.every((v) => v == null)\n\nexport const isFunction = <T extends Function = Function>(\n  value: any,\n): value is T => typeof value === \"function\"\n\nexport const isUnit = (value: any): boolean =>\n  /[0-9].*[px|rem|em|%|vw|vh]$/.test(value)\n\nexport const cast = <T>(value: any) => value as T\n","import type { Dict, Union } from \".\"\nimport { isObject, isArray, isFunction, isString } from \".\"\n\nconst omitObjectHelper = <T extends Dict, K extends keyof T>(\n  obj: T,\n  path: Union<K>[],\n): any => {\n  if (!path.length) return obj\n\n  const [primaryKey, ...restKeys] = path\n\n  if (restKeys.length === 0 && primaryKey in obj) {\n    const { [primaryKey]: _, ...rest } = obj\n\n    return rest\n  }\n\n  if (obj[primaryKey] && isObject(obj[primaryKey])) {\n    return {\n      ...obj,\n      [primaryKey]: omitObjectHelper(obj[primaryKey], restKeys),\n    }\n  }\n\n  return obj\n}\n\nexport const omitObject = <\n  Y extends Dict,\n  M extends keyof Y,\n  D extends unknown,\n>(\n  obj: Y,\n  keys: Union<M>[],\n) => {\n  return keys.reduce((prev, key) => {\n    const path = (isString(key) ? key.split(\".\") : []) as Union<M>[]\n\n    return omitObjectHelper(prev, path)\n  }, obj) as unknown as D extends unknown ? Omit<Y, M> : D\n}\n\nexport const pickObject = <\n  Y extends Dict,\n  M extends keyof Y,\n  D extends unknown,\n>(\n  obj: Y,\n  keys: Union<M>[],\n  fallbackValue = \"__fallback\",\n) =>\n  keys.reduce((prev, key) => {\n    const path = isString(key) ? key.split(\".\") : []\n\n    if (!path.length) return prev\n\n    const value = getMemoizedObject(obj, key as string, fallbackValue)\n\n    if (value === fallbackValue) return prev\n\n    prev = merge(\n      prev,\n      path.reduceRight(\n        (prev, key) => ({ [key]: key === path.at(-1) ? value : prev }),\n        {},\n      ),\n    )\n\n    return prev\n  }, {}) as D extends unknown ? { [H in M]: Y[H] } : D\n\nexport const splitObject = <T extends Dict, K extends keyof T>(\n  obj: T,\n  keys: K[],\n) => {\n  const picked: Dict = {}\n  const omitted: Dict = {}\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (keys.includes(key as T[K])) {\n      picked[key] = value\n    } else {\n      omitted[key] = value\n    }\n  }\n\n  return [picked, omitted] as [{ [P in K]: T[P] }, Omit<T, K>]\n}\n\nexport const filterObject = <T extends Dict, K extends Dict>(\n  obj: T,\n  func: (key: keyof T, value: T[keyof T], obj: T) => boolean,\n): K => {\n  const result: Dict = {}\n\n  Object.entries(obj).forEach(([key, value]) => {\n    const shouldPass = func(key, value, obj)\n\n    if (shouldPass) result[key] = value\n  })\n\n  return result as K\n}\n\nexport const filterUndefined = <T extends Dict>(obj: T): T =>\n  filterObject(obj, (_, val) => val !== null && val !== undefined)\n\nexport const merge = <T extends Dict>(\n  target: any,\n  source: any,\n  mergeArray: boolean = false,\n): T => {\n  let result = Object.assign({}, target)\n\n  if (isObject(source)) {\n    if (isObject(target)) {\n      for (const [sourceKey, sourceValue] of Object.entries(source)) {\n        const targetValue: any = target[sourceKey]\n\n        if (mergeArray && isArray(sourceValue) && isArray(targetValue)) {\n          result[sourceKey] = targetValue.concat(...sourceValue)\n        } else if (\n          !isFunction(sourceValue) &&\n          isObject(sourceValue) &&\n          target.hasOwnProperty(sourceKey)\n        ) {\n          result[sourceKey] = merge(targetValue, sourceValue, mergeArray)\n        } else {\n          Object.assign(result, { [sourceKey]: sourceValue })\n        }\n      }\n    } else {\n      result = source\n    }\n  }\n\n  return result as T\n}\n\nexport const flattenObject = <T extends Dict>(\n  obj: any,\n  maxDepth: number = Infinity,\n  omitKeys: string[] = [],\n): T => {\n  if ((!isObject(obj) && !isArray(obj)) || !maxDepth) return obj\n\n  return Object.entries(obj).reduce((result, [key, value]) => {\n    if (\n      isObject(value) &&\n      !Object.keys(value).some((key) => omitKeys.includes(key))\n    ) {\n      Object.entries(flattenObject(value, maxDepth - 1, omitKeys)).forEach(\n        ([childKey, childValue]) => {\n          result[`${key}.${childKey}`] = childValue\n        },\n      )\n    } else {\n      result[key] = value\n    }\n\n    return result\n  }, {} as any) as T\n}\n\nexport const objectFromEntries = <T extends Dict>(entries: any[][]): T =>\n  entries.reduce((result, [key, value]) => {\n    result[key] = value\n\n    return result\n  }, {} as any) as T\n\nexport const keysFormObject = <T extends Dict>(obj: T): (keyof T)[] =>\n  Object.keys(obj)\n\nexport const replaceObject = <T extends any>(\n  objOrArray: T,\n  callBack: (value: any) => any,\n): T => {\n  if (isArray(objOrArray)) {\n    return objOrArray.map(callBack) as T\n  } else if (isObject(objOrArray)) {\n    return Object.entries(objOrArray).reduce((obj, [key, value]) => {\n      obj[key] = callBack(value)\n\n      return obj\n    }, {} as Dict) as T\n  } else {\n    return callBack(objOrArray)\n  }\n}\n\nexport const getObject = (\n  obj: Dict,\n  path: string | number,\n  fallback?: any,\n  i?: number,\n) => {\n  const k = typeof path === \"string\" ? path.split(\".\") : [path]\n\n  for (i = 0; i < k.length; i += 1) {\n    if (!obj) break\n\n    obj = obj[k[i]]\n  }\n\n  return obj === undefined ? fallback : obj\n}\n\nexport const memoizeObject = (func: typeof getObject) => {\n  const cache = new WeakMap()\n\n  const memoizedFunc = <T extends unknown = any>(\n    obj: Dict,\n    path: string | number,\n    fallback?: any,\n    i?: number,\n  ): T => {\n    if (typeof obj === \"undefined\") return func(obj, path, fallback)\n\n    if (!cache.has(obj)) cache.set(obj, new Map())\n\n    const map = cache.get(obj)\n\n    if (map.has(path)) return map.get(path)\n\n    const value = func(obj, path, fallback, i)\n\n    map.set(path, value)\n\n    return value as T\n  }\n\n  return memoizedFunc\n}\n\nexport const getMemoizedObject = memoizeObject(getObject)\n\nexport const assignAfter = (target: Record<string, any>, ...sources: any[]) => {\n  if (target == null)\n    throw new TypeError(\"Cannot convert undefined or null to object\")\n\n  const result: Record<string, unknown> = { ...target }\n\n  for (const nextSource of sources) {\n    if (nextSource == null) continue\n\n    for (const nextKey in nextSource) {\n      if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey)) continue\n\n      if (nextKey in result) delete result[nextKey]\n\n      result[nextKey] = nextSource[nextKey]\n    }\n  }\n\n  return result\n}\n"],"mappings":"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","names":["parseToHsla","parseToRgba","isDark","hsla","rgba","parseToRgba","parseToHsla","v"]}