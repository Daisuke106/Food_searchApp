import {
  isArray,
  isFunction,
  isNumber,
  isObject,
  isString,
  isUndefined
} from "./chunk-P5JCSYB3.mjs";

// src/function.ts
var noop = () => {
};
var runIfFunc = (valOrFunc, ...args) => isFunction(valOrFunc) ? valOrFunc(...args) : valOrFunc;
var handlerAll = (...funcs) => (event, ...args) => {
  funcs.some((func) => {
    func == null ? void 0 : func(event, ...args);
    return event == null ? void 0 : event.defaultPrevented;
  });
};
var funcAll = (...funcs) => (...args) => funcs.forEach((func) => func == null ? void 0 : func(...args));

// src/react.tsx
import * as React from "react";
var createContext2 = ({
  strict = true,
  errorMessage = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
  name,
  defaultValue
} = {}) => {
  const Context = React.createContext(defaultValue);
  Context.displayName = name;
  const useContext2 = () => {
    var _a;
    const context = React.useContext(Context);
    if (!context && strict) {
      const error = new Error(errorMessage);
      error.name = "ContextError";
      (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, error, useContext2);
      throw error;
    }
    return context;
  };
  return [
    Context.Provider,
    useContext2,
    Context
  ];
};
var useSafeLayoutEffect = Boolean(globalThis == null ? void 0 : globalThis.document) ? React.useLayoutEffect : React.useEffect;
var useUnmountEffect = (callback) => (
  // eslint-disable-next-line react-hooks/exhaustive-deps
  React.useEffect(() => () => callback(), [])
);
var useIsMounted = ({
  rerender = false,
  delay = 0
} = {}) => {
  const isMountedRef = React.useRef(false);
  const [isMounted, setIsMounted] = React.useState(false);
  useSafeLayoutEffect(() => {
    isMountedRef.current = true;
    let timeoutId = null;
    if (rerender) {
      if (delay > 0) {
        timeoutId = setTimeout(() => setIsMounted(true), delay);
      } else {
        setIsMounted(true);
      }
    }
    return () => {
      isMountedRef.current = false;
      if (rerender)
        setIsMounted(false);
      if (timeoutId)
        clearTimeout(timeoutId);
    };
  }, [delay, rerender]);
  return [React.useCallback(() => isMountedRef.current, []), isMounted];
};
var getValidChildren = (children) => React.Children.toArray(children).filter(
  (child) => React.isValidElement(child)
);
var isValidElement2 = (child) => React.isValidElement(child) || isString(child) || isNumber(child);
var findChildren = (children, ...types) => children.find((child) => types.some((type) => child.type === type)) ? children.sort(
  (a, b) => types.some((type) => a.type === type) ? -1 : types.some((type) => b.type === type) ? 1 : 0
) : [void 0, ...children];
var includesChildren = (children, ...types) => children.some((child) => {
  if (types.some((type) => child.type === type))
    return true;
  const children2 = getValidChildren(child.props.children);
  return children2.length ? includesChildren(children2, ...types) : false;
});
var omitChildren = (children, ...types) => children.filter((child) => types.every((type) => child.type !== type));
var pickChildren = (children, ...types) => children.filter((child) => types.every((type) => child.type === type));
var cx = (...classNames) => classNames.filter(Boolean).join(" ");
var isRefObject = (val) => "current" in val;
var assignRef = (ref, value) => {
  if (ref == null)
    return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
};
var mergeRefs = (...refs) => (node) => {
  refs.forEach((ref) => {
    assignRef(ref, node);
  });
};
var useMergeRefs = (...refs) => React.useMemo(() => mergeRefs(...refs), [refs]);
var useCallbackRef = (callback, deps = []) => {
  const callbackRef = React.useRef(callback);
  React.useEffect(() => {
    callbackRef.current = callback;
  });
  return React.useCallback(
    (...args) => {
      var _a;
      return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
    },
    deps
  );
};
var useUpdateEffect = (callback, deps) => {
  const renderCycleRef = React.useRef(false);
  const effectCycleRef = React.useRef(false);
  React.useEffect(() => {
    const mounted = renderCycleRef.current;
    const run = mounted && effectCycleRef.current;
    if (run)
      return callback();
    effectCycleRef.current = true;
  }, deps);
  React.useEffect(() => {
    renderCycleRef.current = true;
    return () => {
      renderCycleRef.current = false;
    };
  }, []);
};
var useAsync = (func, deps = []) => {
  const [state, callback] = useAsyncFunc(func, deps, { loading: true });
  React.useEffect(() => {
    callback();
  }, [callback]);
  return state;
};
var useAsyncFunc = (func, deps = [], initialState = { loading: false }) => {
  const lastCallId = React.useRef(0);
  const [isMounted] = useIsMounted();
  const [state, setState] = React.useState(initialState);
  const callback = React.useCallback(
    (...args) => {
      const callId = ++lastCallId.current;
      if (!state.loading)
        setState((prevState) => ({ ...prevState, loading: true }));
      return func(...args).then(
        (value) => {
          if (isMounted() && callId === lastCallId.current)
            setState({ value, loading: false });
          return value;
        },
        (error) => {
          if (isMounted() && callId === lastCallId.current)
            setState({ error, loading: false });
          return error;
        }
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  return [state, callback];
};
var useAsyncRetry = (func, deps = []) => {
  const [attempt, setAttempt] = React.useState(0);
  const state = useAsync(func, [...deps, attempt]);
  const stateLoading = state.loading;
  const retry = React.useCallback(() => {
    if (stateLoading)
      return;
    setAttempt((currentAttempt) => currentAttempt + 1);
  }, [...deps, stateLoading]);
  return { ...state, retry };
};
var createIdCounter = 0;
var createId = (prefix) => `${prefix}-${++createIdCounter}-${(/* @__PURE__ */ new Date()).getTime()}`;

// src/dom.ts
var createdDom = () => !!(typeof window !== "undefined" && window.document && window.document.createElement);
var getPlatform = () => {
  var _a, _b;
  return (_b = (_a = navigator.userAgentData) == null ? void 0 : _a.platform) != null ? _b : navigator.platform;
};
var vendor = (v) => createdDom() && v.test(navigator.vendor);
var platform = (v) => createdDom() && v.test(getPlatform());
var isMac = () => platform(/^mac/i);
var isApple = () => platform(/mac|iphone|ipad|ipod/i);
var isSafari = () => isApple() && vendor(/apple/i);
var isElement = (el) => el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
var isHTMLElement = (el) => {
  var _a;
  if (!isElement(el))
    return false;
  const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;
  return el instanceof win.HTMLElement;
};
var isHidden = (el) => {
  if (el.parentElement && isHidden(el.parentElement))
    return true;
  return el.hidden;
};
var isDisabled = (el) => Boolean(el.getAttribute("disabled")) === true || Boolean(el.getAttribute("data-disabled")) === true || Boolean(el.getAttribute("aria-disabled")) === true;
var isVisible = (el) => el.offsetWidth > 0 && el.offsetHeight > 0;
var hasTabIndex = (el) => el.hasAttribute("tabindex");
var isContentEditable = (el) => {
  const value = el.getAttribute("contenteditable");
  return value !== "false" && value != null;
};
var isContains = (parent, child) => {
  return parent === child || (parent == null ? void 0 : parent.contains(child));
};
var getPx = (value) => {
  if (isNumber(value))
    return value;
  if (isUndefined(value))
    return 0;
  if (value.includes("px"))
    return parseFloat(value);
  const isBrowser = createdDom();
  let fontSize = 16;
  if (isBrowser) {
    const style = window.getComputedStyle(document.documentElement);
    const computedFontSize = parseFloat(style.fontSize);
    if (!isNaN(computedFontSize))
      fontSize = computedFontSize;
  }
  return parseFloat(value) * fontSize;
};
var getEventRelatedTarget = (ev) => {
  var _a;
  return (_a = ev.relatedTarget) != null ? _a : ev.currentTarget.ownerDocument.activeElement;
};
var dataAttr = (condition) => condition ? "" : void 0;
var ariaAttr = (condition) => condition ? true : void 0;
var focusableElList = [
  "input:not(:disabled):not([disabled])",
  "select:not(:disabled):not([disabled])",
  "textarea:not(:disabled):not([disabled])",
  "embed",
  "iframe",
  "object",
  "a[href]",
  "area[href]",
  "button:not(:disabled):not([disabled])",
  "[tabindex]",
  "audio[controls]",
  "video[controls]",
  "*[tabindex]:not([aria-disabled])",
  "*[contenteditable]"
];
var focusableElSelector = focusableElList.join();
var getAllFocusable = (container) => {
  const focusableEls = Array.from(
    container.querySelectorAll(focusableElSelector)
  );
  focusableEls.unshift(container);
  return focusableEls.filter((el) => isFocusable(el) && isVisible(el));
};
var isFocusable = (el) => {
  if (!isHTMLElement(el) || isHidden(el) || isDisabled(el)) {
    return false;
  }
  const { localName } = el;
  const focusableTags = ["input", "select", "textarea", "button"];
  if (focusableTags.indexOf(localName) >= 0)
    return true;
  const others = {
    a: () => el.hasAttribute("href"),
    audio: () => el.hasAttribute("controls"),
    video: () => el.hasAttribute("controls")
  };
  if (localName in others)
    return others[localName]();
  if (isContentEditable(el))
    return true;
  return hasTabIndex(el);
};
var hasNegativeTabIndex = (el) => hasTabIndex(el) && el.tabIndex === -1;
var isTabbable = (el) => el ? isHTMLElement(el) && isFocusable(el) && !hasNegativeTabIndex(el) : false;
var getOwnerWindow = (node) => {
  var _a, _b;
  return (_b = (_a = getOwnerDocument(node)) == null ? void 0 : _a.defaultView) != null ? _b : window;
};
var getOwnerDocument = (el) => isElement(el) ? el.ownerDocument : document;
var getActiveElement = (el) => getOwnerDocument(el).activeElement;
var isActiveElement = (el) => {
  return getActiveElement(el) === el;
};

// src/color.ts
import * as c from "color2k";
var tones = [
  50,
  100,
  200,
  300,
  400,
  500,
  600,
  700,
  800,
  900,
  950
];
var isGray = (colorScheme) => colorScheme === "gray" || colorScheme === "neutral";
var isAccessible = (colorScheme) => colorScheme === "yellow" || colorScheme === "cyan" || colorScheme === "lime";
var getColor = (color, fallback = "#000000") => (theme = {}, colorMode) => {
  var _a, _b, _c;
  const [token, hue] = color.split(".");
  const [, relatedToken] = (_c = Object.entries((_b = (_a = theme.semantics) == null ? void 0 : _a.colorSchemes) != null ? _b : {}).find(
    ([semanticToken]) => token === semanticToken
  )) != null ? _c : [];
  if (relatedToken)
    color = `${relatedToken}.${hue}`;
  const hex = getMemoizedObject(theme, `colors.${color}`, color);
  try {
    if (isArray(hex)) {
      return c.toHex(String(colorMode !== "dark" ? hex[0] : hex[1]));
    } else {
      return c.toHex(String(hex));
    }
  } catch {
    try {
      return c.toHex(fallback);
    } catch {
      return "#000000";
    }
  }
};
var lightenColor = (color, amount) => (theme, colorMode) => {
  const raw = getColor(color, color)(theme, colorMode);
  return c.toHex(c.lighten(raw, amount / 100));
};
var darkenColor = (color, amount) => (theme, colorMode) => {
  const raw = getColor(color, color)(theme, colorMode);
  return c.toHex(c.darken(raw, amount / 100));
};
var tintColor = (color, amount) => (theme, colorMode) => {
  const raw = getColor(color, color)(theme, colorMode);
  return c.toHex(c.mix(raw, "#fff", amount / 100));
};
var shadeColor = (color, amount) => (theme, colorMode) => {
  const raw = getColor(color, color)(theme, colorMode);
  return c.toHex(c.mix(raw, "#000", amount / 100));
};
var transparentizeColor = (color, alpha) => (theme, colorMode) => {
  const raw = getColor(color, color)(theme, colorMode);
  return c.transparentize(raw, 1 - alpha);
};
var randomColor = ({
  string,
  colors
} = {}) => {
  const fallback = randomHex();
  if (string && colors)
    return randomColorFromList(string, colors);
  if (string && !colors)
    return randomColorFromString(string);
  if (colors && !string)
    return randomFromList(colors);
  return fallback;
};
var randomHex = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
var randomColorFromString = (str) => {
  let hash = 0;
  if (str.length === 0)
    return hash.toString();
  for (let i = 0; i < str.length; i += 1) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
    hash = hash & hash;
  }
  let color = "#";
  for (let j = 0; j < 3; j += 1) {
    const value = hash >> j * 8 & 255;
    color += `00${value.toString(16)}`.substr(-2);
  }
  return color;
};
var randomColorFromList = (str, list) => {
  let index = 0;
  if (str.length === 0)
    return list[0];
  for (let i = 0; i < str.length; i += 1) {
    index = str.charCodeAt(i) + ((index << 5) - index);
    index = index & index;
  }
  index = (index % list.length + list.length) % list.length;
  return list[index];
};
var randomFromList = (list) => list[Math.floor(Math.random() * list.length)];
var getBrightness = (color) => {
  const [r, g, b] = c.parseToRgba(color);
  return (r * 299 + g * 587 + b * 114) / 1e3;
};
var isTone = (color) => (theme, colorMode) => {
  const raw = theme ? getColor(color)(theme, colorMode) : color;
  const brightness = getBrightness(raw);
  const isDark2 = brightness < 128;
  return isDark2 ? "dark" : "light";
};
var isLight = (color) => (theme, colorMode) => isTone(color)(theme, colorMode) === "dark";
var isDark = (color) => (theme, colorMode) => isTone(color)(theme, colorMode) === "light";
var convertColor = (color, fallback) => (format) => {
  try {
    const isAlpha = format.endsWith("a");
    if (/^[0-9a-fA-F]{6}$/.test(color))
      color = "#" + color;
    if (format.startsWith("hex")) {
      let hexa = c.toHex(color);
      if (isAlpha) {
        if (hexa.length === 7)
          hexa += "ff";
      } else {
        hexa = hexa.replace(/(?<=^#([0-9a-fA-F]{6}))[0-9a-fA-F]{2}$/, "");
      }
      return hexa;
    } else if (format.startsWith("hsl")) {
      let hsla2 = c.toHsla(color);
      if (!isAlpha) {
        hsla2 = hsla2.replace(/hsla/, "hsl");
        hsla2 = hsla2.replace(/,\s*\d+(\.\d+)?\)$/, ")");
      }
      return hsla2;
    } else {
      let rgba2 = c.toRgba(color);
      if (!isAlpha) {
        rgba2 = rgba2.replace(/rgba/, "rgb");
        rgba2 = rgba2.replace(/,\s*\d+(\.\d+)?\)$/, ")");
      }
      return rgba2;
    }
  } catch {
    if (fallback)
      return convertColor(fallback)(format);
  }
};
var calcFormat = (color) => {
  if (color.startsWith("hsl")) {
    return color.startsWith("hsla") ? "hsla" : "hsl";
  } else if (color.startsWith("rgb")) {
    return color.startsWith("rgba") ? "rgba" : "rgb";
  } else {
    return color.length === 9 ? "hexa" : "hex";
  }
};
var getAlpha = (color) => c.parseToRgba(color)[3];
var alphaToHex = (a) => {
  if (0 > a)
    a = 0;
  if (1 < a)
    a = 1;
  return Math.round(a * 255).toString(16).padStart(2, "0");
};
var parseToRgba2 = (color, fallback) => {
  try {
    if (/^[0-9a-fA-F]{6}$/.test(color))
      color = "#" + color;
    return c.parseToRgba(color);
  } catch {
    if (fallback)
      return c.parseToRgba(fallback);
  }
};
var parseToHsla2 = (color, fallback) => {
  try {
    if (/^[0-9a-fA-F]{6}$/.test(color))
      color = "#" + color;
    return c.parseToHsla(color);
  } catch {
    if (fallback)
      return c.parseToHsla(fallback);
  }
};
var parseToHsv = (color, fallback) => {
  var _a;
  let [r, g, b, a] = (_a = parseToRgba2(color, fallback)) != null ? _a : [255, 255, 255, 1];
  r = r / 255;
  g = g / 255;
  b = b / 255;
  const [min, max] = [Math.min(r, g, b), Math.max(r, g, b)];
  const delta = max - min;
  let [h, v, s] = [0, max, max == 0 ? 0 : delta / max];
  switch (min) {
    case max:
      h = 0;
      break;
    case r:
      h = 60 * ((b - g) / delta) + 180;
      break;
    case g:
      h = 60 * ((r - b) / delta) + 300;
      break;
    case b:
      h = 60 * ((g - r) / delta) + 60;
      break;
  }
  return [h, s, v, a];
};
var rgbaTo = ([r, g, b, a], fallback) => (format = "hex") => convertColor(c.rgba(r, g, b, a), fallback)(format);
var hslaTo = ([h, s, l, a], fallback) => (format = "hex") => convertColor(c.hsla(h, s, l, a), fallback)(format);
var hsvTo = ([h, s, v, a], fallback) => (format = "hex") => {
  h = h / 60;
  let rgb = [v, v, v];
  let i = Math.floor(h);
  let f = h - i;
  let p = v * (1 - s);
  let q = v * (1 - s * f);
  let t = v * (1 - s * (1 - f));
  switch (i) {
    case 0:
    case 6:
      rgb = [v, t, p];
      break;
    case 1:
      rgb = [q, v, p];
      break;
    case 2:
      rgb = [p, v, t];
      break;
    case 3:
      rgb = [p, q, v];
      break;
    case 4:
      rgb = [t, p, v];
      break;
    case 5:
      rgb = [v, p, q];
      break;
  }
  let color = `rgb(${rgb.map((v2) => Math.round(v2 * 255)).join(", ")})`;
  if (isNumber(a))
    color = color.replace(/\)$/, `, ${a})`);
  return convertColor(color, fallback)(format);
};
var sameColor = (color, comparison) => {
  var _a, _b;
  if (!color)
    return false;
  if (!comparison)
    return false;
  const a = (_a = parseToRgba2(color)) != null ? _a : [];
  const b = (_b = parseToRgba2(comparison)) != null ? _b : [];
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

// src/object.ts
var omitObjectHelper = (obj, path) => {
  if (!path.length)
    return obj;
  const [primaryKey, ...restKeys] = path;
  if (restKeys.length === 0 && primaryKey in obj) {
    const { [primaryKey]: _, ...rest } = obj;
    return rest;
  }
  if (obj[primaryKey] && isObject(obj[primaryKey])) {
    return {
      ...obj,
      [primaryKey]: omitObjectHelper(obj[primaryKey], restKeys)
    };
  }
  return obj;
};
var omitObject = (obj, keys) => {
  return keys.reduce((prev, key) => {
    const path = isString(key) ? key.split(".") : [];
    return omitObjectHelper(prev, path);
  }, obj);
};
var pickObject = (obj, keys, fallbackValue = "__fallback") => keys.reduce((prev, key) => {
  const path = isString(key) ? key.split(".") : [];
  if (!path.length)
    return prev;
  const value = getMemoizedObject(obj, key, fallbackValue);
  if (value === fallbackValue)
    return prev;
  prev = merge(
    prev,
    path.reduceRight(
      (prev2, key2) => ({ [key2]: key2 === path.at(-1) ? value : prev2 }),
      {}
    )
  );
  return prev;
}, {});
var splitObject = (obj, keys) => {
  const picked = {};
  const omitted = {};
  for (const [key, value] of Object.entries(obj)) {
    if (keys.includes(key)) {
      picked[key] = value;
    } else {
      omitted[key] = value;
    }
  }
  return [picked, omitted];
};
var filterObject = (obj, func) => {
  const result = {};
  Object.entries(obj).forEach(([key, value]) => {
    const shouldPass = func(key, value, obj);
    if (shouldPass)
      result[key] = value;
  });
  return result;
};
var filterUndefined = (obj) => filterObject(obj, (_, val) => val !== null && val !== void 0);
var merge = (target, source, mergeArray = false) => {
  let result = Object.assign({}, target);
  if (isObject(source)) {
    if (isObject(target)) {
      for (const [sourceKey, sourceValue] of Object.entries(source)) {
        const targetValue = target[sourceKey];
        if (mergeArray && isArray(sourceValue) && isArray(targetValue)) {
          result[sourceKey] = targetValue.concat(...sourceValue);
        } else if (!isFunction(sourceValue) && isObject(sourceValue) && target.hasOwnProperty(sourceKey)) {
          result[sourceKey] = merge(targetValue, sourceValue, mergeArray);
        } else {
          Object.assign(result, { [sourceKey]: sourceValue });
        }
      }
    } else {
      result = source;
    }
  }
  return result;
};
var flattenObject = (obj, maxDepth = Infinity, omitKeys = []) => {
  if (!isObject(obj) && !isArray(obj) || !maxDepth)
    return obj;
  return Object.entries(obj).reduce((result, [key, value]) => {
    if (isObject(value) && !Object.keys(value).some((key2) => omitKeys.includes(key2))) {
      Object.entries(flattenObject(value, maxDepth - 1, omitKeys)).forEach(
        ([childKey, childValue]) => {
          result[`${key}.${childKey}`] = childValue;
        }
      );
    } else {
      result[key] = value;
    }
    return result;
  }, {});
};
var objectFromEntries = (entries) => entries.reduce((result, [key, value]) => {
  result[key] = value;
  return result;
}, {});
var keysFormObject = (obj) => Object.keys(obj);
var replaceObject = (objOrArray, callBack) => {
  if (isArray(objOrArray)) {
    return objOrArray.map(callBack);
  } else if (isObject(objOrArray)) {
    return Object.entries(objOrArray).reduce((obj, [key, value]) => {
      obj[key] = callBack(value);
      return obj;
    }, {});
  } else {
    return callBack(objOrArray);
  }
};
var getObject = (obj, path, fallback, i) => {
  const k = typeof path === "string" ? path.split(".") : [path];
  for (i = 0; i < k.length; i += 1) {
    if (!obj)
      break;
    obj = obj[k[i]];
  }
  return obj === void 0 ? fallback : obj;
};
var memoizeObject = (func) => {
  const cache = /* @__PURE__ */ new WeakMap();
  const memoizedFunc = (obj, path, fallback, i) => {
    if (typeof obj === "undefined")
      return func(obj, path, fallback);
    if (!cache.has(obj))
      cache.set(obj, /* @__PURE__ */ new Map());
    const map = cache.get(obj);
    if (map.has(path))
      return map.get(path);
    const value = func(obj, path, fallback, i);
    map.set(path, value);
    return value;
  };
  return memoizedFunc;
};
var getMemoizedObject = memoizeObject(getObject);
var assignAfter = (target, ...sources) => {
  if (target == null)
    throw new TypeError("Cannot convert undefined or null to object");
  const result = { ...target };
  for (const nextSource of sources) {
    if (nextSource == null)
      continue;
    for (const nextKey in nextSource) {
      if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey))
        continue;
      if (nextKey in result)
        delete result[nextKey];
      result[nextKey] = nextSource[nextKey];
    }
  }
  return result;
};

export {
  omitObject,
  pickObject,
  splitObject,
  filterObject,
  filterUndefined,
  merge,
  flattenObject,
  objectFromEntries,
  keysFormObject,
  replaceObject,
  getObject,
  memoizeObject,
  getMemoizedObject,
  assignAfter,
  noop,
  runIfFunc,
  handlerAll,
  funcAll,
  createContext2 as createContext,
  useSafeLayoutEffect,
  useUnmountEffect,
  useIsMounted,
  getValidChildren,
  isValidElement2 as isValidElement,
  findChildren,
  includesChildren,
  omitChildren,
  pickChildren,
  cx,
  isRefObject,
  assignRef,
  mergeRefs,
  useMergeRefs,
  useCallbackRef,
  useUpdateEffect,
  useAsync,
  useAsyncFunc,
  useAsyncRetry,
  createId,
  createdDom,
  getPlatform,
  vendor,
  platform,
  isMac,
  isApple,
  isSafari,
  isElement,
  isHTMLElement,
  isHidden,
  isDisabled,
  hasTabIndex,
  isContentEditable,
  isContains,
  getPx,
  getEventRelatedTarget,
  dataAttr,
  ariaAttr,
  getAllFocusable,
  isFocusable,
  hasNegativeTabIndex,
  isTabbable,
  getOwnerWindow,
  getOwnerDocument,
  getActiveElement,
  isActiveElement,
  tones,
  isGray,
  isAccessible,
  getColor,
  lightenColor,
  darkenColor,
  tintColor,
  shadeColor,
  transparentizeColor,
  randomColor,
  isTone,
  isLight,
  isDark,
  convertColor,
  calcFormat,
  getAlpha,
  alphaToHex,
  parseToRgba2 as parseToRgba,
  parseToHsla2 as parseToHsla,
  parseToHsv,
  rgbaTo,
  hslaTo,
  hsvTo,
  sameColor
};
//# sourceMappingURL=chunk-YI55JNAD.mjs.map