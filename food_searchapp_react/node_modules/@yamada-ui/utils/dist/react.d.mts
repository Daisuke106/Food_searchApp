import * as React from 'react';
import { Merge } from './index.types.mjs';

type DOMElement = Element & HTMLOrSVGElement;
type DOMAttributes<Y = DOMElement> = React.HTMLAttributes<Y> & React.AriaAttributes & React.DOMAttributes<Y> & {
    id?: string;
    role?: React.AriaRole;
    tabIndex?: number;
    style?: React.CSSProperties;
};
type PropGetter<Y = undefined, M = DOMAttributes> = (props?: Merge<DOMAttributes, Y>, ref?: React.Ref<any>) => M & React.RefAttributes<any>;
type RequiredPropGetter<Y = undefined, M = DOMAttributes> = (props: Merge<DOMAttributes, Y>, ref?: React.Ref<any>) => M & React.RefAttributes<any>;
type MaybeRenderProp<Y> = React.ReactNode | ((props: Y) => React.ReactNode);
type Options<ContextType extends any = any> = {
    strict?: boolean;
    errorMessage?: string;
    name?: string;
    defaultValue?: ContextType;
};
type CreateContextReturn<T> = [React.Provider<T>, () => T, React.Context<T>];
declare const createContext: <ContextType extends unknown = any>({ strict, errorMessage, name, defaultValue, }?: Options<ContextType>) => CreateContextReturn<ContextType>;
declare const useSafeLayoutEffect: typeof React.useLayoutEffect;
declare const useUnmountEffect: (callback: () => void) => void;
type UseIsMountedProps = {
    rerender?: boolean;
    delay?: number;
};
declare const useIsMounted: ({ rerender, delay, }?: UseIsMountedProps) => [() => boolean, boolean];
type UseIsMountedReturn = ReturnType<typeof useIsMounted>;
declare const getValidChildren: (children: React.ReactNode) => React.ReactElement[];
declare const isValidElement: (child: any) => child is React.ReactNode;
declare const findChildren: (children: React.ReactElement<any, string | React.JSXElementConstructor<any>>[], ...types: (string | React.JSXElementConstructor<any>)[]) => [React.ReactElement | undefined, ...React.ReactElement[]];
declare const includesChildren: (children: React.ReactElement<any, string | React.JSXElementConstructor<any>>[], ...types: (string | React.JSXElementConstructor<any>)[]) => boolean;
declare const omitChildren: (children: React.ReactElement<any, string | React.JSXElementConstructor<any>>[], ...types: (string | React.JSXElementConstructor<any>)[]) => React.ReactElement[];
declare const pickChildren: (children: React.ReactElement<any, string | React.JSXElementConstructor<any>>[], ...types: (string | React.JSXElementConstructor<any>)[]) => React.ReactElement[];
declare const cx: (...classNames: (string | undefined)[]) => string;
type ReactRef<T> = React.Ref<T> | React.MutableRefObject<T> | React.LegacyRef<T>;
declare const isRefObject: (val: any) => val is {
    current: any;
};
declare const assignRef: <T extends unknown = any>(ref: ReactRef<T> | undefined, value: T) => void;
declare const mergeRefs: <T extends unknown = any>(...refs: (ReactRef<T> | null | undefined)[]) => (node: T | null) => void;
declare const useMergeRefs: <T extends unknown = any>(...refs: (ReactRef<T> | undefined)[]) => (node: T | null) => void;
declare const useCallbackRef: <T extends (...args: any[]) => any>(callback: T | undefined, deps?: React.DependencyList) => T;
/**
 * `useUpdateEffect` is a custom hook that skips side effects on the initial render, and only runs them when the dependency array changes.
 *
 * @see Docs https://yamada-ui.com/hooks/use-update-effect
 */
declare const useUpdateEffect: (callback: React.EffectCallback, deps: React.DependencyList) => void;
type FunctionReturningPromise = (...args: any[]) => Promise<any>;
/**
 * `useAsync` is a custom hook that executes an asynchronous function and tracks its state.
 *
 * @see Docs https://yamada-ui.com/hooks/use-async
 */
declare const useAsync: <T extends FunctionReturningPromise>(func: T, deps?: React.DependencyList) => StateFromFunctionReturningPromise<T>;
type AsyncState<T> = {
    loading: boolean;
    error?: undefined;
    value?: undefined;
} | {
    loading: true;
    error?: Error | undefined;
    value?: T;
} | {
    loading: false;
    error: Error;
    value?: undefined;
} | {
    loading: false;
    error?: undefined;
    value: T;
};
type PromiseType<P extends Promise<any>> = P extends Promise<infer T> ? T : never;
type StateFromFunctionReturningPromise<T extends FunctionReturningPromise> = AsyncState<PromiseType<ReturnType<T>>>;
type AsyncFnReturn<T extends FunctionReturningPromise = FunctionReturningPromise> = [StateFromFunctionReturningPromise<T>, T];
declare const useAsyncFunc: <T extends FunctionReturningPromise>(func: T, deps?: React.DependencyList, initialState?: StateFromFunctionReturningPromise<T>) => AsyncFnReturn<T>;
type AsyncStateRetry<T> = AsyncState<T> & {
    retry(): void;
};
declare const useAsyncRetry: <T>(func: () => Promise<T>, deps?: React.DependencyList) => {
    retry: () => void;
    loading: boolean;
    error?: undefined;
    value?: undefined;
} | {
    retry: () => void;
    loading: false;
    error: Error;
    value?: undefined;
} | {
    retry: () => void;
    loading: true;
    error?: Error | undefined;
    value?: T | undefined;
} | {
    retry: () => void;
    loading: false;
    error?: undefined;
    value: T;
};
declare const createId: (prefix: string) => string;

export { type AsyncFnReturn, type AsyncState, type AsyncStateRetry, type DOMAttributes, type FunctionReturningPromise, type MaybeRenderProp, type PromiseType, type PropGetter, type RequiredPropGetter, type UseIsMountedProps, type UseIsMountedReturn, assignRef, createContext, createId, cx, findChildren, getValidChildren, includesChildren, isRefObject, isValidElement, mergeRefs, omitChildren, pickChildren, useAsync, useAsyncFunc, useAsyncRetry, useCallbackRef, useIsMounted, useMergeRefs, useSafeLayoutEffect, useUnmountEffect, useUpdateEffect };
