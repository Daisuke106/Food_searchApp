{"version":3,"sources":["../src/object.ts","../src/assertion.ts"],"sourcesContent":["import type { Dict, Union } from \".\"\nimport { isObject, isArray, isFunction, isString } from \".\"\n\nconst omitObjectHelper = <T extends Dict, K extends keyof T>(\n  obj: T,\n  path: Union<K>[],\n): any => {\n  if (!path.length) return obj\n\n  const [primaryKey, ...restKeys] = path\n\n  if (restKeys.length === 0 && primaryKey in obj) {\n    const { [primaryKey]: _, ...rest } = obj\n\n    return rest\n  }\n\n  if (obj[primaryKey] && isObject(obj[primaryKey])) {\n    return {\n      ...obj,\n      [primaryKey]: omitObjectHelper(obj[primaryKey], restKeys),\n    }\n  }\n\n  return obj\n}\n\nexport const omitObject = <\n  Y extends Dict,\n  M extends keyof Y,\n  D extends unknown,\n>(\n  obj: Y,\n  keys: Union<M>[],\n) => {\n  return keys.reduce((prev, key) => {\n    const path = (isString(key) ? key.split(\".\") : []) as Union<M>[]\n\n    return omitObjectHelper(prev, path)\n  }, obj) as unknown as D extends unknown ? Omit<Y, M> : D\n}\n\nexport const pickObject = <\n  Y extends Dict,\n  M extends keyof Y,\n  D extends unknown,\n>(\n  obj: Y,\n  keys: Union<M>[],\n  fallbackValue = \"__fallback\",\n) =>\n  keys.reduce((prev, key) => {\n    const path = isString(key) ? key.split(\".\") : []\n\n    if (!path.length) return prev\n\n    const value = getMemoizedObject(obj, key as string, fallbackValue)\n\n    if (value === fallbackValue) return prev\n\n    prev = merge(\n      prev,\n      path.reduceRight(\n        (prev, key) => ({ [key]: key === path.at(-1) ? value : prev }),\n        {},\n      ),\n    )\n\n    return prev\n  }, {}) as D extends unknown ? { [H in M]: Y[H] } : D\n\nexport const splitObject = <T extends Dict, K extends keyof T>(\n  obj: T,\n  keys: K[],\n) => {\n  const picked: Dict = {}\n  const omitted: Dict = {}\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (keys.includes(key as T[K])) {\n      picked[key] = value\n    } else {\n      omitted[key] = value\n    }\n  }\n\n  return [picked, omitted] as [{ [P in K]: T[P] }, Omit<T, K>]\n}\n\nexport const filterObject = <T extends Dict, K extends Dict>(\n  obj: T,\n  func: (key: keyof T, value: T[keyof T], obj: T) => boolean,\n): K => {\n  const result: Dict = {}\n\n  Object.entries(obj).forEach(([key, value]) => {\n    const shouldPass = func(key, value, obj)\n\n    if (shouldPass) result[key] = value\n  })\n\n  return result as K\n}\n\nexport const filterUndefined = <T extends Dict>(obj: T): T =>\n  filterObject(obj, (_, val) => val !== null && val !== undefined)\n\nexport const merge = <T extends Dict>(\n  target: any,\n  source: any,\n  mergeArray: boolean = false,\n): T => {\n  let result = Object.assign({}, target)\n\n  if (isObject(source)) {\n    if (isObject(target)) {\n      for (const [sourceKey, sourceValue] of Object.entries(source)) {\n        const targetValue: any = target[sourceKey]\n\n        if (mergeArray && isArray(sourceValue) && isArray(targetValue)) {\n          result[sourceKey] = targetValue.concat(...sourceValue)\n        } else if (\n          !isFunction(sourceValue) &&\n          isObject(sourceValue) &&\n          target.hasOwnProperty(sourceKey)\n        ) {\n          result[sourceKey] = merge(targetValue, sourceValue, mergeArray)\n        } else {\n          Object.assign(result, { [sourceKey]: sourceValue })\n        }\n      }\n    } else {\n      result = source\n    }\n  }\n\n  return result as T\n}\n\nexport const flattenObject = <T extends Dict>(\n  obj: any,\n  maxDepth: number = Infinity,\n  omitKeys: string[] = [],\n): T => {\n  if ((!isObject(obj) && !isArray(obj)) || !maxDepth) return obj\n\n  return Object.entries(obj).reduce((result, [key, value]) => {\n    if (\n      isObject(value) &&\n      !Object.keys(value).some((key) => omitKeys.includes(key))\n    ) {\n      Object.entries(flattenObject(value, maxDepth - 1, omitKeys)).forEach(\n        ([childKey, childValue]) => {\n          result[`${key}.${childKey}`] = childValue\n        },\n      )\n    } else {\n      result[key] = value\n    }\n\n    return result\n  }, {} as any) as T\n}\n\nexport const objectFromEntries = <T extends Dict>(entries: any[][]): T =>\n  entries.reduce((result, [key, value]) => {\n    result[key] = value\n\n    return result\n  }, {} as any) as T\n\nexport const keysFormObject = <T extends Dict>(obj: T): (keyof T)[] =>\n  Object.keys(obj)\n\nexport const replaceObject = <T extends any>(\n  objOrArray: T,\n  callBack: (value: any) => any,\n): T => {\n  if (isArray(objOrArray)) {\n    return objOrArray.map(callBack) as T\n  } else if (isObject(objOrArray)) {\n    return Object.entries(objOrArray).reduce((obj, [key, value]) => {\n      obj[key] = callBack(value)\n\n      return obj\n    }, {} as Dict) as T\n  } else {\n    return callBack(objOrArray)\n  }\n}\n\nexport const getObject = (\n  obj: Dict,\n  path: string | number,\n  fallback?: any,\n  i?: number,\n) => {\n  const k = typeof path === \"string\" ? path.split(\".\") : [path]\n\n  for (i = 0; i < k.length; i += 1) {\n    if (!obj) break\n\n    obj = obj[k[i]]\n  }\n\n  return obj === undefined ? fallback : obj\n}\n\nexport const memoizeObject = (func: typeof getObject) => {\n  const cache = new WeakMap()\n\n  const memoizedFunc = <T extends unknown = any>(\n    obj: Dict,\n    path: string | number,\n    fallback?: any,\n    i?: number,\n  ): T => {\n    if (typeof obj === \"undefined\") return func(obj, path, fallback)\n\n    if (!cache.has(obj)) cache.set(obj, new Map())\n\n    const map = cache.get(obj)\n\n    if (map.has(path)) return map.get(path)\n\n    const value = func(obj, path, fallback, i)\n\n    map.set(path, value)\n\n    return value as T\n  }\n\n  return memoizedFunc\n}\n\nexport const getMemoizedObject = memoizeObject(getObject)\n\nexport const assignAfter = (target: Record<string, any>, ...sources: any[]) => {\n  if (target == null)\n    throw new TypeError(\"Cannot convert undefined or null to object\")\n\n  const result: Record<string, unknown> = { ...target }\n\n  for (const nextSource of sources) {\n    if (nextSource == null) continue\n\n    for (const nextKey in nextSource) {\n      if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey)) continue\n\n      if (nextKey in result) delete result[nextKey]\n\n      result[nextKey] = nextSource[nextKey]\n    }\n  }\n\n  return result\n}\n","import type { Dict } from \".\"\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\"\n\nexport const isNotNumber = (value: any): boolean =>\n  typeof value !== \"number\" || Number.isNaN(value) || !Number.isFinite(value)\n\nexport const isNumeric = (value: any): boolean =>\n  value != null &&\n  parseFloat(value.toString()) - parseFloat(value.toString()) + 1 >= 0\n\nexport const isString = (value: any): value is string =>\n  Object.prototype.toString.call(value) === \"[object String]\"\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\"\n\nexport const isUndefined = (value: any): value is undefined =>\n  typeof value === \"undefined\" && value === undefined\n\nexport const isNull = (value: any): value is null => value === null\n\nexport const isObject = <T extends Dict>(value: any): value is T =>\n  value !== null &&\n  (typeof value === \"object\" || typeof value === \"function\") &&\n  !isArray(value)\n\nexport const isArray = <T extends any[]>(value: any): value is T =>\n  Array.isArray(value)\n\nexport const isEmpty = (value: any): boolean =>\n  !isArray(value) || !value.length || value.every((v) => v == null)\n\nexport const isFunction = <T extends Function = Function>(\n  value: any,\n): value is T => typeof value === \"function\"\n\nexport const isUnit = (value: any): boolean =>\n  /[0-9].*[px|rem|em|%|vw|vh]$/.test(value)\n\nexport const cast = <T>(value: any) => value as T\n"],"mappings":"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","names":["prev","key"]}