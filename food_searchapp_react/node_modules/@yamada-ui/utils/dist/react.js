"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/react.tsx
var react_exports = {};
__export(react_exports, {
  assignRef: () => assignRef,
  createContext: () => createContext2,
  createId: () => createId,
  cx: () => cx,
  findChildren: () => findChildren,
  getValidChildren: () => getValidChildren,
  includesChildren: () => includesChildren,
  isRefObject: () => isRefObject,
  isValidElement: () => isValidElement2,
  mergeRefs: () => mergeRefs,
  omitChildren: () => omitChildren,
  pickChildren: () => pickChildren,
  useAsync: () => useAsync,
  useAsyncFunc: () => useAsyncFunc,
  useAsyncRetry: () => useAsyncRetry,
  useCallbackRef: () => useCallbackRef,
  useIsMounted: () => useIsMounted,
  useMergeRefs: () => useMergeRefs,
  useSafeLayoutEffect: () => useSafeLayoutEffect,
  useUnmountEffect: () => useUnmountEffect,
  useUpdateEffect: () => useUpdateEffect
});
module.exports = __toCommonJS(react_exports);
var React = __toESM(require("react"));

// src/assertion.ts
var isNumber = (value) => typeof value === "number";
var isString = (value) => Object.prototype.toString.call(value) === "[object String]";

// src/react.tsx
var createContext2 = ({
  strict = true,
  errorMessage = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
  name,
  defaultValue
} = {}) => {
  const Context = React.createContext(defaultValue);
  Context.displayName = name;
  const useContext2 = () => {
    var _a;
    const context = React.useContext(Context);
    if (!context && strict) {
      const error = new Error(errorMessage);
      error.name = "ContextError";
      (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, error, useContext2);
      throw error;
    }
    return context;
  };
  return [
    Context.Provider,
    useContext2,
    Context
  ];
};
var useSafeLayoutEffect = Boolean(globalThis == null ? void 0 : globalThis.document) ? React.useLayoutEffect : React.useEffect;
var useUnmountEffect = (callback) => (
  // eslint-disable-next-line react-hooks/exhaustive-deps
  React.useEffect(() => () => callback(), [])
);
var useIsMounted = ({
  rerender = false,
  delay = 0
} = {}) => {
  const isMountedRef = React.useRef(false);
  const [isMounted, setIsMounted] = React.useState(false);
  useSafeLayoutEffect(() => {
    isMountedRef.current = true;
    let timeoutId = null;
    if (rerender) {
      if (delay > 0) {
        timeoutId = setTimeout(() => setIsMounted(true), delay);
      } else {
        setIsMounted(true);
      }
    }
    return () => {
      isMountedRef.current = false;
      if (rerender)
        setIsMounted(false);
      if (timeoutId)
        clearTimeout(timeoutId);
    };
  }, [delay, rerender]);
  return [React.useCallback(() => isMountedRef.current, []), isMounted];
};
var getValidChildren = (children) => React.Children.toArray(children).filter(
  (child) => React.isValidElement(child)
);
var isValidElement2 = (child) => React.isValidElement(child) || isString(child) || isNumber(child);
var findChildren = (children, ...types) => children.find((child) => types.some((type) => child.type === type)) ? children.sort(
  (a, b) => types.some((type) => a.type === type) ? -1 : types.some((type) => b.type === type) ? 1 : 0
) : [void 0, ...children];
var includesChildren = (children, ...types) => children.some((child) => {
  if (types.some((type) => child.type === type))
    return true;
  const children2 = getValidChildren(child.props.children);
  return children2.length ? includesChildren(children2, ...types) : false;
});
var omitChildren = (children, ...types) => children.filter((child) => types.every((type) => child.type !== type));
var pickChildren = (children, ...types) => children.filter((child) => types.every((type) => child.type === type));
var cx = (...classNames) => classNames.filter(Boolean).join(" ");
var isRefObject = (val) => "current" in val;
var assignRef = (ref, value) => {
  if (ref == null)
    return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
};
var mergeRefs = (...refs) => (node) => {
  refs.forEach((ref) => {
    assignRef(ref, node);
  });
};
var useMergeRefs = (...refs) => React.useMemo(() => mergeRefs(...refs), [refs]);
var useCallbackRef = (callback, deps = []) => {
  const callbackRef = React.useRef(callback);
  React.useEffect(() => {
    callbackRef.current = callback;
  });
  return React.useCallback(
    (...args) => {
      var _a;
      return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
    },
    deps
  );
};
var useUpdateEffect = (callback, deps) => {
  const renderCycleRef = React.useRef(false);
  const effectCycleRef = React.useRef(false);
  React.useEffect(() => {
    const mounted = renderCycleRef.current;
    const run = mounted && effectCycleRef.current;
    if (run)
      return callback();
    effectCycleRef.current = true;
  }, deps);
  React.useEffect(() => {
    renderCycleRef.current = true;
    return () => {
      renderCycleRef.current = false;
    };
  }, []);
};
var useAsync = (func, deps = []) => {
  const [state, callback] = useAsyncFunc(func, deps, { loading: true });
  React.useEffect(() => {
    callback();
  }, [callback]);
  return state;
};
var useAsyncFunc = (func, deps = [], initialState = { loading: false }) => {
  const lastCallId = React.useRef(0);
  const [isMounted] = useIsMounted();
  const [state, setState] = React.useState(initialState);
  const callback = React.useCallback(
    (...args) => {
      const callId = ++lastCallId.current;
      if (!state.loading)
        setState((prevState) => ({ ...prevState, loading: true }));
      return func(...args).then(
        (value) => {
          if (isMounted() && callId === lastCallId.current)
            setState({ value, loading: false });
          return value;
        },
        (error) => {
          if (isMounted() && callId === lastCallId.current)
            setState({ error, loading: false });
          return error;
        }
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  return [state, callback];
};
var useAsyncRetry = (func, deps = []) => {
  const [attempt, setAttempt] = React.useState(0);
  const state = useAsync(func, [...deps, attempt]);
  const stateLoading = state.loading;
  const retry = React.useCallback(() => {
    if (stateLoading)
      return;
    setAttempt((currentAttempt) => currentAttempt + 1);
  }, [...deps, stateLoading]);
  return { ...state, retry };
};
var createIdCounter = 0;
var createId = (prefix) => `${prefix}-${++createIdCounter}-${(/* @__PURE__ */ new Date()).getTime()}`;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assignRef,
  createContext,
  createId,
  cx,
  findChildren,
  getValidChildren,
  includesChildren,
  isRefObject,
  isValidElement,
  mergeRefs,
  omitChildren,
  pickChildren,
  useAsync,
  useAsyncFunc,
  useAsyncRetry,
  useCallbackRef,
  useIsMounted,
  useMergeRefs,
  useSafeLayoutEffect,
  useUnmountEffect,
  useUpdateEffect
});
//# sourceMappingURL=react.js.map