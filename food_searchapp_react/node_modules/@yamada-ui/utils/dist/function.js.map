{"version":3,"sources":["../src/function.ts","../src/assertion.ts"],"sourcesContent":["import { isFunction } from \".\"\n\nexport const noop = () => {}\n\nexport const runIfFunc = <T, U extends Array<any>>(\n  valOrFunc: T | ((...funcArgs: U) => T),\n  ...args: U\n): T => (isFunction(valOrFunc) ? valOrFunc(...args) : valOrFunc)\n\nexport const handlerAll =\n  <T extends (event: any, ...args: any[]) => void>(\n    ...funcs: (T | undefined)[]\n  ) =>\n  (\n    event: T extends (event: infer R, ...args: any[]) => any ? R : never,\n    ...args: T extends (event: any, ...args: infer R) => any ? R : never\n  ) => {\n    funcs.some((func) => {\n      func?.(event, ...args)\n\n      return event?.defaultPrevented\n    })\n  }\n\nexport const funcAll =\n  <T extends (...args: any[]) => any>(...funcs: (T | undefined)[]) =>\n  (...args: T extends (...args: infer R) => any ? R : never) =>\n    funcs.forEach((func) => func?.(...args))\n","import type { Dict } from \".\"\n\nexport const isNumber = (value: any): value is number =>\n  typeof value === \"number\"\n\nexport const isNotNumber = (value: any): boolean =>\n  typeof value !== \"number\" || Number.isNaN(value) || !Number.isFinite(value)\n\nexport const isNumeric = (value: any): boolean =>\n  value != null &&\n  parseFloat(value.toString()) - parseFloat(value.toString()) + 1 >= 0\n\nexport const isString = (value: any): value is string =>\n  Object.prototype.toString.call(value) === \"[object String]\"\n\nexport const isBoolean = (value: any): value is boolean =>\n  typeof value === \"boolean\"\n\nexport const isUndefined = (value: any): value is undefined =>\n  typeof value === \"undefined\" && value === undefined\n\nexport const isNull = (value: any): value is null => value === null\n\nexport const isObject = <T extends Dict>(value: any): value is T =>\n  value !== null &&\n  (typeof value === \"object\" || typeof value === \"function\") &&\n  !isArray(value)\n\nexport const isArray = <T extends any[]>(value: any): value is T =>\n  Array.isArray(value)\n\nexport const isEmpty = (value: any): boolean =>\n  !isArray(value) || !value.length || value.every((v) => v == null)\n\nexport const isFunction = <T extends Function = Function>(\n  value: any,\n): value is T => typeof value === \"function\"\n\nexport const isUnit = (value: any): boolean =>\n  /[0-9].*[px|rem|em|%|vw|vh]$/.test(value)\n\nexport const cast = <T>(value: any) => value as T\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACkCO,IAAM,aAAa,CACxB,UACe,OAAO,UAAU;;;ADlC3B,IAAM,OAAO,MAAM;AAAC;AAEpB,IAAM,YAAY,CACvB,cACG,SACI,WAAW,SAAS,IAAI,UAAU,GAAG,IAAI,IAAI;AAE/C,IAAM,aACX,IACK,UAEL,CACE,UACG,SACA;AACH,QAAM,KAAK,CAAC,SAAS;AACnB,iCAAO,OAAO,GAAG;AAEjB,WAAO,+BAAO;AAAA,EAChB,CAAC;AACH;AAEK,IAAM,UACX,IAAuC,UACvC,IAAI,SACF,MAAM,QAAQ,CAAC,SAAS,6BAAO,GAAG,KAAK;","names":[]}