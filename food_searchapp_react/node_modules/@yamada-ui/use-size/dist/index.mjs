"use client"

// src/index.ts
import { useSafeLayoutEffect, isRefObject, isArray } from "@yamada-ui/utils";
import { useState } from "react";
var trackElementSize = (el, cb) => {
  var _a;
  if (!el) {
    cb(void 0);
    return;
  }
  cb({ width: el.offsetWidth, height: el.offsetHeight });
  const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;
  const observer = new win.ResizeObserver((entries) => {
    if (!isArray(entries) || !entries.length)
      return;
    const [entry] = entries;
    let width;
    let height;
    if ("borderBoxSize" in entry) {
      const borderSizeEntry = entry.borderBoxSize;
      const borderSize = isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
      width = borderSize.inlineSize;
      height = borderSize.blockSize;
    } else {
      width = el.offsetWidth;
      height = el.offsetHeight;
    }
    cb({ width, height });
  });
  observer.observe(el, { box: "border-box" });
  return () => observer.unobserve(el);
};
var trackMutation = (el, cb) => {
  var _a, _b;
  if (!el || !el.parentElement)
    return;
  const win = (_b = (_a = el.ownerDocument) == null ? void 0 : _a.defaultView) != null ? _b : window;
  const observer = new win.MutationObserver(() => {
    cb();
  });
  observer.observe(el.parentElement, { childList: true });
  return () => {
    observer.disconnect();
  };
};
var useSizes = ({
  getNodes,
  observeMutation = true
}) => {
  const [sizes, setSizes] = useState([]);
  const [count, setCount] = useState(0);
  useSafeLayoutEffect(() => {
    const elements = getNodes();
    const cleanups = elements.map(
      (element, index) => trackElementSize(element, (size) => {
        setSizes((sizes2) => {
          return [
            ...sizes2.slice(0, index),
            size,
            ...sizes2.slice(index + 1)
          ];
        });
      })
    );
    if (observeMutation) {
      const firstNode = elements[0];
      cleanups.push(
        trackMutation(firstNode, () => {
          setCount((count2) => count2 + 1);
        })
      );
    }
    return () => {
      cleanups.forEach((cleanup) => {
        cleanup == null ? void 0 : cleanup();
      });
    };
  }, [count]);
  return sizes;
};
var useSize = (refOrEl) => {
  const [size] = useSizes({
    observeMutation: false,
    getNodes: () => {
      const node = isRefObject(refOrEl) ? refOrEl.current : refOrEl;
      return [node];
    }
  });
  return size;
};
export {
  trackElementSize,
  useSize,
  useSizes
};
//# sourceMappingURL=index.mjs.map