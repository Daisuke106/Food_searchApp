{"version":3,"sources":["../src/highlight.tsx"],"sourcesContent":["/**\n * `Highlight` is a component that highlights specified strings within text. By default, it renders a `p` element.\n *\n * @see Docs https://yamada-ui.com/components/typography/highlight\n */\nimport type { HTMLUIProps, ThemeProps, CSSUIObject } from \"@yamada-ui/core\"\nimport {\n  ui,\n  forwardRef,\n  useComponentStyle,\n  omitThemeProps,\n} from \"@yamada-ui/core\"\nimport type { TextProps } from \"@yamada-ui/typography\"\nimport { Text } from \"@yamada-ui/typography\"\nimport { cx, isArray } from \"@yamada-ui/utils\"\nimport type { FC, ReactNode } from \"react\"\nimport { Fragment, useMemo } from \"react\"\n\ntype Options = { text: string; query: string | string[] }\n\ntype Chunk = { text: string; match: boolean }\n\nconst escapeRegexp = (term: string): string =>\n  term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, (char: string) => `\\\\${char}`)\n\nconst buildRegex = (query: string[]): RegExp | undefined => {\n  query = query.filter(Boolean).map((text) => escapeRegexp(text.trim()))\n\n  if (query.length) return new RegExp(`(${query.join(\"|\")})`, \"ig\")\n}\n\nconst highlightWords = ({ text, query }: Options): Chunk[] => {\n  const regex = buildRegex(isArray(query) ? query : [query])\n\n  if (!regex) return [{ text, match: false }]\n\n  return text\n    .split(regex)\n    .filter(Boolean)\n    .map((text) => ({ text, match: regex.test(text) }))\n}\n\nexport const useHighlight = ({ text, query }: Options): Chunk[] =>\n  useMemo(() => highlightWords({ text, query }), [text, query])\n\nexport type HighlightProps = TextProps & {\n  /**\n   * If `true`, `Fragment` is used for rendering.\n   *\n   * @default false\n   */\n  isFragment?: boolean\n  /**\n   * Can be a single string or an array of strings. These are the terms that are highlighted in the text.\n   */\n  query: string | string[]\n  /**\n   * Accepts a string or a function. If it's a function, it should return a `ReactNode` and accept an array of `Chunk` objects as its argument.\n   */\n  children: string | ((props: Chunk[]) => ReactNode)\n  /**\n   * Properties passed to the Mark component which is used to highlight the matched terms.\n   */\n  markProps?: MarkProps\n}\n\nexport const Highlight: FC<HighlightProps> = ({\n  isFragment = false,\n  query,\n  children: text,\n  markProps,\n  lineHeight = \"tall\",\n  ...rest\n}) => {\n  if (typeof text !== \"string\")\n    throw new Error(\"The children prop of Highlight must be a string\")\n\n  const chunks = useHighlight({ query, text })\n\n  const Component: FC = isFragment ? Fragment : Text\n\n  return (\n    <Component {...(!isFragment ? { lineHeight } : {})} {...rest}>\n      {chunks.map(({ text, match }, i) =>\n        match ? (\n          <Mark key={i} {...markProps}>\n            {text}\n          </Mark>\n        ) : (\n          <Fragment key={i}>{text}</Fragment>\n        ),\n      )}\n    </Component>\n  )\n}\n\nexport type MarkProps = HTMLUIProps<\"mark\"> & ThemeProps<\"Mark\">\n\nexport const Mark = forwardRef<MarkProps, \"mark\">((props, ref) => {\n  const [styles, mergedProps] = useComponentStyle(\"Mark\", props)\n  const { className, ...rest } = omitThemeProps(mergedProps)\n\n  const css: CSSUIObject = {\n    bg: \"transparent\",\n    whiteSpace: \"nowrap\",\n    ...styles,\n  }\n\n  return (\n    <ui.mark\n      ref={ref}\n      className={cx(\"ui-mark\", className)}\n      __css={css}\n      {...rest}\n    />\n  )\n})\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,kBAKO;AAEP,wBAAqB;AACrB,mBAA4B;AAE5B,mBAAkC;AAqExB;AA/DV,IAAM,eAAe,CAAC,SACpB,KAAK,QAAQ,wBAAwB,CAAC,SAAiB,KAAK,IAAI,EAAE;AAEpE,IAAM,aAAa,CAAC,UAAwC;AAC1D,UAAQ,MAAM,OAAO,OAAO,EAAE,IAAI,CAAC,SAAS,aAAa,KAAK,KAAK,CAAC,CAAC;AAErE,MAAI,MAAM;AAAQ,WAAO,IAAI,OAAO,IAAI,MAAM,KAAK,GAAG,CAAC,KAAK,IAAI;AAClE;AAEA,IAAM,iBAAiB,CAAC,EAAE,MAAM,MAAM,MAAwB;AAC5D,QAAM,QAAQ,eAAW,sBAAQ,KAAK,IAAI,QAAQ,CAAC,KAAK,CAAC;AAEzD,MAAI,CAAC;AAAO,WAAO,CAAC,EAAE,MAAM,OAAO,MAAM,CAAC;AAE1C,SAAO,KACJ,MAAM,KAAK,EACX,OAAO,OAAO,EACd,IAAI,CAACA,WAAU,EAAE,MAAAA,OAAM,OAAO,MAAM,KAAKA,KAAI,EAAE,EAAE;AACtD;AAEO,IAAM,eAAe,CAAC,EAAE,MAAM,MAAM,UACzC,sBAAQ,MAAM,eAAe,EAAE,MAAM,MAAM,CAAC,GAAG,CAAC,MAAM,KAAK,CAAC;AAuBvD,IAAM,YAAgC,CAAC;AAAA,EAC5C,aAAa;AAAA,EACb;AAAA,EACA,UAAU;AAAA,EACV;AAAA,EACA,aAAa;AAAA,EACb,GAAG;AACL,MAAM;AACJ,MAAI,OAAO,SAAS;AAClB,UAAM,IAAI,MAAM,iDAAiD;AAEnE,QAAM,SAAS,aAAa,EAAE,OAAO,KAAK,CAAC;AAE3C,QAAM,YAAgB,aAAa,wBAAW;AAE9C,SACE,4CAAC,aAAW,GAAI,CAAC,aAAa,EAAE,WAAW,IAAI,CAAC,GAAK,GAAG,MACrD,iBAAO;AAAA,IAAI,CAAC,EAAE,MAAAA,OAAM,MAAM,GAAG,MAC5B,QACE,4CAAC,QAAc,GAAG,WACf,UAAAA,SADQ,CAEX,IAEA,4CAAC,yBAAkB,UAAAA,SAAJ,CAAS;AAAA,EAE5B,GACF;AAEJ;AAIO,IAAM,WAAO,wBAA8B,CAAC,OAAO,QAAQ;AAChE,QAAM,CAAC,QAAQ,WAAW,QAAI,+BAAkB,QAAQ,KAAK;AAC7D,QAAM,EAAE,WAAW,GAAG,KAAK,QAAI,4BAAe,WAAW;AAEzD,QAAM,MAAmB;AAAA,IACvB,IAAI;AAAA,IACJ,YAAY;AAAA,IACZ,GAAG;AAAA,EACL;AAEA,SACE;AAAA,IAAC,eAAG;AAAA,IAAH;AAAA,MACC;AAAA,MACA,eAAW,iBAAG,WAAW,SAAS;AAAA,MAClC,OAAO;AAAA,MACN,GAAG;AAAA;AAAA,EACN;AAEJ,CAAC;","names":["text"]}