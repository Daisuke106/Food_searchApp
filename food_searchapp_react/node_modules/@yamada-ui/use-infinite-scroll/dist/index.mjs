"use client"

// src/index.ts
import {
  assignRef,
  isElement,
  useCallbackRef,
  useUnmountEffect
} from "@yamada-ui/utils";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
var isScrollable = (el, isVertical) => {
  const style = getComputedStyle(el);
  if (["auto", "scroll", "overlay"].includes(style.overflow))
    return true;
  if (isVertical) {
    return ["auto", "scroll", "overlay"].includes(style.overflowY);
  } else {
    return ["auto", "scroll", "overlay"].includes(style.overflowX);
  }
};
var onScroll = ({
  root,
  isVertical,
  isReverse,
  behavior,
  position
}) => {
  let options;
  const el = isElement(root) && isScrollable(root, isVertical) ? root : document.body;
  if (isVertical) {
    options = { top: position != null ? position : isReverse ? el.scrollHeight : 0, behavior };
  } else {
    options = { left: position != null ? position : isReverse ? el.scrollWidth : 0, behavior };
  }
  if (el === document.body) {
    window.scrollTo(options);
  } else {
    el.scrollTo(options);
  }
};
var getScrollPosition = (root, isVertical) => {
  const el = isElement(root) && isScrollable(root, isVertical) ? root : document.body;
  if (isVertical) {
    return el.scrollHeight - el.scrollTop;
  } else {
    return el.scrollWidth - el.scrollLeft;
  }
};
var useInfiniteScroll = ({
  orientation = "vertical",
  rootRef,
  rootMargin,
  threshold,
  initialLoad = false,
  startIndex = initialLoad ? 0 : 1,
  onLoad: onLoadProp,
  resetRef,
  indexRef: indexRefProp,
  isDisabled = false,
  isReverse = false,
  behavior
} = {}) => {
  const ref = useRef(null);
  const indexRef = useRef(startIndex);
  const processingRef = useRef(false);
  const observerRef = useRef(void 0);
  const isMountedRef = useRef(false);
  const prevScrollPosition = useRef(0);
  const [isFinish, setIsFinish] = useState(false);
  const onLoad = useCallbackRef(onLoadProp);
  const isVertical = orientation === "vertical";
  const options = useMemo(() => {
    const root = rootRef == null ? void 0 : rootRef.current;
    return { root, rootMargin, threshold };
  }, [rootMargin, rootRef, threshold]);
  const onReset = useCallback(
    (index = 1, runScroll = true) => {
      indexRef.current = index;
      setIsFinish(false);
      if (runScroll) {
        const root = rootRef == null ? void 0 : rootRef.current;
        onScroll({ root, isVertical, isReverse, behavior });
      }
      if (isDisabled)
        return;
      setTimeout(() => {
        const observer = observerRef.current;
        const el = ref.current;
        if (el)
          observer == null ? void 0 : observer.observe(el);
      });
    },
    [isDisabled, isReverse, rootRef, isVertical, behavior]
  );
  const onFinish = useCallback(() => {
    const observer = observerRef.current;
    const el = ref.current;
    if (el)
      observer == null ? void 0 : observer.unobserve(el);
    setIsFinish(true);
  }, []);
  const createObserver = useCallback(() => {
    const observer = new IntersectionObserver(async ([entry]) => {
      if (!entry.isIntersecting || processingRef.current)
        return;
      const props = { index: indexRef.current, entry, finish: onFinish };
      processingRef.current = true;
      const root = rootRef == null ? void 0 : rootRef.current;
      if (isReverse) {
        prevScrollPosition.current = getScrollPosition(root, isVertical);
      }
      await (onLoad == null ? void 0 : onLoad(props));
      if (isReverse) {
        const position = prevScrollPosition.current;
        onScroll({ root, isVertical, position });
      }
      indexRef.current += 1;
      processingRef.current = false;
    }, options);
    return observer;
  }, [onFinish, onLoad, options, rootRef, isReverse, isVertical]);
  useEffect(() => {
    const setupObserver = async () => {
      const el = ref.current;
      const isMounted = isMountedRef.current;
      const index = indexRef.current;
      if (initialLoad && !isMounted) {
        processingRef.current = true;
        await onLoad({ index, finish: onFinish });
        indexRef.current += 1;
        processingRef.current = false;
      }
      if (isDisabled)
        return;
      observerRef.current = createObserver();
      const observer = observerRef.current;
      if (isReverse && !isMounted) {
        const root = rootRef == null ? void 0 : rootRef.current;
        onScroll({ root, isVertical, isReverse });
        isMountedRef.current = true;
      }
      setTimeout(() => {
        if (el)
          observer.observe(el);
      });
      return () => {
        if (el)
          observer.unobserve(el);
      };
    };
    setupObserver();
  }, [
    createObserver,
    initialLoad,
    isDisabled,
    isReverse,
    isVertical,
    onFinish,
    onLoad,
    rootRef
  ]);
  useUnmountEffect(() => isMountedRef.current = false);
  assignRef(resetRef, onReset);
  assignRef(indexRefProp, (index) => indexRef.current = index);
  return { ref, isFinish };
};
export {
  useInfiniteScroll
};
//# sourceMappingURL=index.mjs.map