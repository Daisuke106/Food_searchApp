{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import {\n  assignRef,\n  isElement,\n  useCallbackRef,\n  useUnmountEffect,\n} from \"@yamada-ui/utils\"\nimport type { RefObject } from \"react\"\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\"\n\nconst isScrollable = (el: HTMLElement, isVertical: boolean) => {\n  const style = getComputedStyle(el)\n\n  if ([\"auto\", \"scroll\", \"overlay\"].includes(style.overflow)) return true\n\n  if (isVertical) {\n    return [\"auto\", \"scroll\", \"overlay\"].includes(style.overflowY)\n  } else {\n    return [\"auto\", \"scroll\", \"overlay\"].includes(style.overflowX)\n  }\n}\n\nconst onScroll = ({\n  root,\n  isVertical,\n  isReverse,\n  behavior,\n  position,\n}: {\n  root: HTMLElement | null | undefined\n  isVertical: boolean\n  isReverse?: boolean\n  behavior?: ScrollBehavior\n  position?: number\n}) => {\n  let options: ScrollToOptions\n  const el =\n    isElement(root) && isScrollable(root, isVertical) ? root : document.body\n\n  if (isVertical) {\n    options = { top: position ?? (isReverse ? el.scrollHeight : 0), behavior }\n  } else {\n    options = { left: position ?? (isReverse ? el.scrollWidth : 0), behavior }\n  }\n\n  if (el === document.body) {\n    window.scrollTo(options)\n  } else {\n    el.scrollTo(options)\n  }\n}\n\nconst getScrollPosition = (\n  root: HTMLElement | null | undefined,\n  isVertical: boolean,\n) => {\n  const el =\n    isElement(root) && isScrollable(root, isVertical) ? root : document.body\n\n  if (isVertical) {\n    return el.scrollHeight - el.scrollTop\n  } else {\n    return el.scrollWidth - el.scrollLeft\n  }\n}\n\nexport type UseInfiniteScrollProps = Omit<IntersectionObserverInit, \"root\"> & {\n  /**\n   * The orientation of the infinite scroll.\n   *\n   * @default 'vertical'\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * The element that is used as the viewport for checking visibility of the target.\n   * Defaults to the browser viewport if not specified or if `null`.\n   */\n  rootRef?: RefObject<HTMLElement>\n  /**\n   * Margin around the root. Can have values similar to the CSS margin property,\n   * e.g. \"10px 20px 30px 40px\" (top, right, bottom, left).\n   */\n  rootMargin?: string\n  /**\n   * Either a single number or an array of numbers which indicate at what percentage of the target's visibility the observer's callback should be executed.\n   */\n  threshold?: number | number[]\n  /**\n   * If set the `onLoad` function will start from the given index.\n   * If `initialLoad` is `true`, index starts from `0`.\n   *\n   * @default 1\n   */\n  startIndex?: number\n  /**\n   * The callback invoked when trigger is intersect.\n   */\n  onLoad?: ({\n    index,\n    entry,\n    finish,\n  }: {\n    index: number\n    finish: () => void\n    entry?: IntersectionObserverEntry\n  }) => Promise<void>\n  /**\n   * Ref to a reset function.\n   */\n  resetRef?: RefObject<(index?: number, runScroll?: boolean) => void>\n  /**\n   * Ref to a reset index function.\n   */\n  indexRef?: RefObject<(index: number) => void>\n  /**\n   * If `true`, the infinite scroll is disabled.\n   *\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   *  If `true`, reverse direction.\n   *\n   * @default false\n   */\n  isReverse?: boolean\n  /**\n   * If `true`, invoke `onLoad` function for the first time.\n   *\n   * @default false\n   */\n  initialLoad?: boolean\n  /**\n   * Determines whether scrolling is instant or animates smoothly.\n   */\n  behavior?: ScrollBehavior\n}\n\n/**\n * `useInfiniteScroll` is a custom hook for providing infinite scroll functionality.\n *\n * @see Docs https://yamada-ui.com/hooks/use-infinite-scroll\n */\nexport const useInfiniteScroll = <T extends HTMLElement = HTMLDivElement>({\n  orientation = \"vertical\",\n  rootRef,\n  rootMargin,\n  threshold,\n  initialLoad = false,\n  startIndex = initialLoad ? 0 : 1,\n  onLoad: onLoadProp,\n  resetRef,\n  indexRef: indexRefProp,\n  isDisabled = false,\n  isReverse = false,\n  behavior,\n}: UseInfiniteScrollProps = {}) => {\n  const ref = useRef<T>(null)\n  const indexRef = useRef<number>(startIndex)\n  const processingRef = useRef<boolean>(false)\n  const observerRef = useRef<IntersectionObserver | undefined>(undefined)\n  const isMountedRef = useRef<boolean>(false)\n  const prevScrollPosition = useRef<number>(0)\n  const [isFinish, setIsFinish] = useState<boolean>(false)\n  const onLoad = useCallbackRef(onLoadProp)\n  const isVertical = orientation === \"vertical\"\n  const options: IntersectionObserverInit = useMemo(() => {\n    const root = rootRef?.current\n\n    return { root, rootMargin, threshold }\n  }, [rootMargin, rootRef, threshold])\n\n  const onReset = useCallback(\n    (index: number = 1, runScroll: boolean = true) => {\n      indexRef.current = index\n\n      setIsFinish(false)\n\n      if (runScroll) {\n        const root = rootRef?.current\n\n        onScroll({ root, isVertical, isReverse, behavior })\n      }\n\n      if (isDisabled) return\n\n      setTimeout(() => {\n        const observer = observerRef.current\n        const el = ref.current\n\n        if (el) observer?.observe(el)\n      })\n    },\n    [isDisabled, isReverse, rootRef, isVertical, behavior],\n  )\n\n  const onFinish = useCallback(() => {\n    const observer = observerRef.current\n    const el = ref.current\n\n    if (el) observer?.unobserve(el)\n\n    setIsFinish(true)\n  }, [])\n\n  const createObserver = useCallback(() => {\n    const observer = new IntersectionObserver(async ([entry]) => {\n      if (!entry.isIntersecting || processingRef.current) return\n\n      const props = { index: indexRef.current, entry, finish: onFinish }\n\n      processingRef.current = true\n\n      const root = rootRef?.current\n\n      if (isReverse) {\n        prevScrollPosition.current = getScrollPosition(root, isVertical)\n      }\n\n      await onLoad?.(props)\n\n      if (isReverse) {\n        const position = prevScrollPosition.current\n\n        onScroll({ root, isVertical, position })\n      }\n\n      indexRef.current += 1\n      processingRef.current = false\n    }, options)\n\n    return observer\n  }, [onFinish, onLoad, options, rootRef, isReverse, isVertical])\n\n  useEffect(() => {\n    const setupObserver = async () => {\n      const el = ref.current\n      const isMounted = isMountedRef.current\n      const index = indexRef.current\n\n      if (initialLoad && !isMounted) {\n        processingRef.current = true\n\n        await onLoad({ index, finish: onFinish })\n\n        indexRef.current += 1\n        processingRef.current = false\n      }\n\n      if (isDisabled) return\n\n      observerRef.current = createObserver()\n\n      const observer = observerRef.current\n\n      if (isReverse && !isMounted) {\n        const root = rootRef?.current\n\n        onScroll({ root, isVertical, isReverse })\n\n        isMountedRef.current = true\n      }\n\n      setTimeout(() => {\n        if (el) observer.observe(el)\n      })\n\n      return () => {\n        if (el) observer.unobserve(el)\n      }\n    }\n\n    setupObserver()\n  }, [\n    createObserver,\n    initialLoad,\n    isDisabled,\n    isReverse,\n    isVertical,\n    onFinish,\n    onLoad,\n    rootRef,\n  ])\n\n  useUnmountEffect(() => (isMountedRef.current = false))\n\n  assignRef(resetRef, onReset)\n  assignRef(indexRefProp, (index) => (indexRef.current = index))\n\n  return { ref, isFinish }\n}\n"],"mappings":"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","names":[]}