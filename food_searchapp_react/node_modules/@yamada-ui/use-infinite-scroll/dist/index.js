"use client"
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  useInfiniteScroll: () => useInfiniteScroll
});
module.exports = __toCommonJS(src_exports);
var import_utils = require("@yamada-ui/utils");
var import_react = require("react");
var isScrollable = (el, isVertical) => {
  const style = getComputedStyle(el);
  if (["auto", "scroll", "overlay"].includes(style.overflow))
    return true;
  if (isVertical) {
    return ["auto", "scroll", "overlay"].includes(style.overflowY);
  } else {
    return ["auto", "scroll", "overlay"].includes(style.overflowX);
  }
};
var onScroll = ({
  root,
  isVertical,
  isReverse,
  behavior,
  position
}) => {
  let options;
  const el = (0, import_utils.isElement)(root) && isScrollable(root, isVertical) ? root : document.body;
  if (isVertical) {
    options = { top: position != null ? position : isReverse ? el.scrollHeight : 0, behavior };
  } else {
    options = { left: position != null ? position : isReverse ? el.scrollWidth : 0, behavior };
  }
  if (el === document.body) {
    window.scrollTo(options);
  } else {
    el.scrollTo(options);
  }
};
var getScrollPosition = (root, isVertical) => {
  const el = (0, import_utils.isElement)(root) && isScrollable(root, isVertical) ? root : document.body;
  if (isVertical) {
    return el.scrollHeight - el.scrollTop;
  } else {
    return el.scrollWidth - el.scrollLeft;
  }
};
var useInfiniteScroll = ({
  orientation = "vertical",
  rootRef,
  rootMargin,
  threshold,
  initialLoad = false,
  startIndex = initialLoad ? 0 : 1,
  onLoad: onLoadProp,
  resetRef,
  indexRef: indexRefProp,
  isDisabled = false,
  isReverse = false,
  behavior
} = {}) => {
  const ref = (0, import_react.useRef)(null);
  const indexRef = (0, import_react.useRef)(startIndex);
  const processingRef = (0, import_react.useRef)(false);
  const observerRef = (0, import_react.useRef)(void 0);
  const isMountedRef = (0, import_react.useRef)(false);
  const prevScrollPosition = (0, import_react.useRef)(0);
  const [isFinish, setIsFinish] = (0, import_react.useState)(false);
  const onLoad = (0, import_utils.useCallbackRef)(onLoadProp);
  const isVertical = orientation === "vertical";
  const options = (0, import_react.useMemo)(() => {
    const root = rootRef == null ? void 0 : rootRef.current;
    return { root, rootMargin, threshold };
  }, [rootMargin, rootRef, threshold]);
  const onReset = (0, import_react.useCallback)(
    (index = 1, runScroll = true) => {
      indexRef.current = index;
      setIsFinish(false);
      if (runScroll) {
        const root = rootRef == null ? void 0 : rootRef.current;
        onScroll({ root, isVertical, isReverse, behavior });
      }
      if (isDisabled)
        return;
      setTimeout(() => {
        const observer = observerRef.current;
        const el = ref.current;
        if (el)
          observer == null ? void 0 : observer.observe(el);
      });
    },
    [isDisabled, isReverse, rootRef, isVertical, behavior]
  );
  const onFinish = (0, import_react.useCallback)(() => {
    const observer = observerRef.current;
    const el = ref.current;
    if (el)
      observer == null ? void 0 : observer.unobserve(el);
    setIsFinish(true);
  }, []);
  const createObserver = (0, import_react.useCallback)(() => {
    const observer = new IntersectionObserver(async ([entry]) => {
      if (!entry.isIntersecting || processingRef.current)
        return;
      const props = { index: indexRef.current, entry, finish: onFinish };
      processingRef.current = true;
      const root = rootRef == null ? void 0 : rootRef.current;
      if (isReverse) {
        prevScrollPosition.current = getScrollPosition(root, isVertical);
      }
      await (onLoad == null ? void 0 : onLoad(props));
      if (isReverse) {
        const position = prevScrollPosition.current;
        onScroll({ root, isVertical, position });
      }
      indexRef.current += 1;
      processingRef.current = false;
    }, options);
    return observer;
  }, [onFinish, onLoad, options, rootRef, isReverse, isVertical]);
  (0, import_react.useEffect)(() => {
    const setupObserver = async () => {
      const el = ref.current;
      const isMounted = isMountedRef.current;
      const index = indexRef.current;
      if (initialLoad && !isMounted) {
        processingRef.current = true;
        await onLoad({ index, finish: onFinish });
        indexRef.current += 1;
        processingRef.current = false;
      }
      if (isDisabled)
        return;
      observerRef.current = createObserver();
      const observer = observerRef.current;
      if (isReverse && !isMounted) {
        const root = rootRef == null ? void 0 : rootRef.current;
        onScroll({ root, isVertical, isReverse });
        isMountedRef.current = true;
      }
      setTimeout(() => {
        if (el)
          observer.observe(el);
      });
      return () => {
        if (el)
          observer.unobserve(el);
      };
    };
    setupObserver();
  }, [
    createObserver,
    initialLoad,
    isDisabled,
    isReverse,
    isVertical,
    onFinish,
    onLoad,
    rootRef
  ]);
  (0, import_utils.useUnmountEffect)(() => isMountedRef.current = false);
  (0, import_utils.assignRef)(resetRef, onReset);
  (0, import_utils.assignRef)(indexRefProp, (index) => indexRef.current = index);
  return { ref, isFinish };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useInfiniteScroll
});
//# sourceMappingURL=index.js.map