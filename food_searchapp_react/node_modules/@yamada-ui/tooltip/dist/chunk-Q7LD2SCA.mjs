"use client"

// src/tooltip.tsx
import {
  ui,
  forwardRef,
  omitThemeProps,
  useComponentStyle
} from "@yamada-ui/core";
import { motion, AnimatePresence } from "@yamada-ui/motion";
import { Portal } from "@yamada-ui/portal";
import { scaleFadeProps, slideFadeProps } from "@yamada-ui/transitions";
import { useDisclosure } from "@yamada-ui/use-disclosure";
import { useEventListener } from "@yamada-ui/use-event-listener";
import { useOutsideClick } from "@yamada-ui/use-outside-click";
import { usePopper } from "@yamada-ui/use-popper";
import {
  cx,
  handlerAll,
  mergeRefs,
  getOwnerWindow,
  getOwnerDocument
} from "@yamada-ui/utils";
import { Children, cloneElement, useCallback, useEffect, useRef } from "react";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
var getTooltipProps = (animation = "scale", duration) => {
  const custom = {
    reverse: true,
    duration,
    enter: { visibility: "visible" },
    transitionEnd: { exit: { visibility: "hidden" } }
  };
  switch (animation) {
    case "scale":
      return {
        ...scaleFadeProps,
        custom: { ...custom, scale: 0.95 }
      };
    case "top":
      return {
        ...slideFadeProps,
        custom: { ...custom, offsetY: -16 }
      };
    case "right":
      return {
        ...slideFadeProps,
        custom: { ...custom, offsetX: 16 }
      };
    case "left":
      return {
        ...slideFadeProps,
        custom: { ...custom, offsetX: -16 }
      };
    case "bottom":
      return {
        ...slideFadeProps,
        custom: { ...custom, offsetY: 16 }
      };
  }
};
var Tooltip = forwardRef(
  ({
    closeOnPointerDown,
    z: zProp,
    zIndex: zIndexProp,
    portalProps,
    withPortal = true,
    ...props
  }, ref) => {
    var _a, _b;
    let [{ z, zIndex, ...styles }, mergedProps] = useComponentStyle(
      "Tooltip",
      props
    );
    const {
      className,
      children,
      label,
      placement,
      modifiers,
      gutter,
      offset,
      openDelay = 0,
      closeDelay = 0,
      isDisabled,
      closeOnClick,
      closeOnScroll,
      closeOnMouseDown,
      closeOnEsc = true,
      animation,
      duration,
      isOpen: isOpenProp,
      defaultIsOpen: defaultIsOpenProp,
      onOpen: onOpenProp,
      onClose: onCloseProp,
      ...rest
    } = omitThemeProps(mergedProps);
    closeOnPointerDown = closeOnMouseDown;
    const { isOpen, onOpen, onClose } = useDisclosure({
      isOpen: isOpenProp,
      defaultIsOpen: defaultIsOpenProp,
      onOpen: onOpenProp,
      onClose: onCloseProp
    });
    const triggerRef = useRef(null);
    const openTimeout = useRef();
    const closeTimeout = useRef();
    const { referenceRef, getPopperProps, transformOrigin } = usePopper({
      enabled: isOpen,
      placement,
      modifiers,
      gutter,
      offset
    });
    const closeNow = useCallback(() => {
      if (closeTimeout.current) {
        clearTimeout(closeTimeout.current);
        closeTimeout.current = void 0;
      }
      onClose();
    }, [onClose]);
    const openWithDelay = useCallback(() => {
      if (!isDisabled && !openTimeout.current) {
        if (isOpen)
          closeNow();
        const win = getOwnerWindow(triggerRef.current);
        openTimeout.current = win.setTimeout(onOpen, openDelay);
      }
    }, [isDisabled, isOpen, openDelay, closeNow, onOpen]);
    const closeWithDelay = useCallback(() => {
      if (openTimeout.current) {
        clearTimeout(openTimeout.current);
        openTimeout.current = void 0;
      }
      const win = getOwnerWindow(triggerRef.current);
      closeTimeout.current = win.setTimeout(closeNow, closeDelay);
    }, [closeDelay, closeNow]);
    const onClick = useCallback(
      () => isOpen && closeOnClick ? closeWithDelay() : void 0,
      [isOpen, closeOnClick, closeWithDelay]
    );
    const onPointerDown = useCallback(
      () => isOpen && closeOnPointerDown ? closeWithDelay() : void 0,
      [isOpen, closeOnPointerDown, closeWithDelay]
    );
    const onKeyDown = useCallback(
      (ev) => isOpen && ev.key === "Escape" ? closeWithDelay() : void 0,
      [isOpen, closeWithDelay]
    );
    useEventListener(
      () => getOwnerDocument(triggerRef.current),
      "keydown",
      (ev) => closeOnEsc ? onKeyDown(ev) : void 0
    );
    useEventListener(
      () => getOwnerDocument(triggerRef.current),
      "scroll",
      () => isOpen && closeOnScroll ? closeNow() : void 0
    );
    useEventListener(
      () => triggerRef.current,
      "pointerleave",
      (e) => {
        if (e.pointerType !== "touch")
          closeWithDelay();
      }
    );
    useEventListener(
      () => triggerRef.current,
      "touchstart",
      () => {
        if (isOpen)
          closeWithDelay();
        else
          openWithDelay();
      },
      { passive: true }
    );
    useOutsideClick({
      ref: triggerRef,
      handler: () => {
        closeWithDelay();
      }
    });
    useEffect(
      () => () => {
        clearTimeout(openTimeout.current);
        clearTimeout(closeTimeout.current);
      },
      []
    );
    const getTriggerProps = useCallback(
      (props2 = {}, ref2 = null) => ({
        ...props2,
        ref: mergeRefs(triggerRef, ref2, referenceRef),
        onPointerEnter: handlerAll(props2.onPointerEnter, openWithDelay),
        onClick: handlerAll(props2.onClick, onClick),
        onPointerDown: handlerAll(props2.onPointerDown, onPointerDown),
        onFocus: handlerAll(props2.onFocus, openWithDelay),
        onBlur: handlerAll(props2.onBlur, closeWithDelay)
      }),
      [referenceRef, onClick, onPointerDown, openWithDelay, closeWithDelay]
    );
    const child = Children.only(children);
    const trigger = cloneElement(child, getTriggerProps(child.props, child.ref));
    const css = {
      position: "relative",
      ...styles
    };
    if (!label)
      return /* @__PURE__ */ jsx(Fragment, { children });
    const resolvedZIndex = (_b = (_a = zIndexProp != null ? zIndexProp : zProp) != null ? _a : zIndex) != null ? _b : z;
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      trigger,
      /* @__PURE__ */ jsx(AnimatePresence, { children: isOpen ? /* @__PURE__ */ jsx(Portal, { isDisabled: !withPortal, ...portalProps, children: /* @__PURE__ */ jsx(
        ui.div,
        {
          ...getPopperProps(),
          zIndex: resolvedZIndex,
          pointerEvents: "none",
          children: /* @__PURE__ */ jsx(
            ui.div,
            {
              as: motion.div,
              ref,
              className: cx("ui-tooltip", className),
              style: { transformOrigin },
              ...animation !== "none" ? getTooltipProps(animation, duration) : {},
              initial: "exit",
              animate: isOpen ? "enter" : "exit",
              exit: "exit",
              __css: css,
              ...rest,
              children: label
            }
          )
        }
      ) }) : null })
    ] });
  }
);

export {
  Tooltip
};
//# sourceMappingURL=chunk-Q7LD2SCA.mjs.map