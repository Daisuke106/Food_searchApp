{"version":3,"sources":["../src/focus-lock.tsx"],"sourcesContent":["import type { FocusableElement } from \"@yamada-ui/utils\"\nimport { getAllFocusable, interopDefault } from \"@yamada-ui/utils\"\nimport type { FC, ReactNode, RefObject } from \"react\"\nimport { useCallback } from \"react\"\nimport ReactFocusLock from \"react-focus-lock\"\n\nconst InternalFocusLock = interopDefault(ReactFocusLock)\n\nexport type FocusLockProps = {\n  /**\n   * `ref` of the element to receive focus initially.\n   */\n  initialFocusRef?: RefObject<FocusableElement>\n  /**\n   * `ref` of the element to return focus to when `FocusLock` unmounts.\n   */\n  finalFocusRef?: RefObject<FocusableElement>\n  /**\n   * The `ref` of the wrapper for which the focus-lock wraps.\n   */\n  contentRef?: RefObject<HTMLElement>\n  /**\n   * If `true`, focus will be restored to the element that triggered the `FocusLock` once it unmounts.\n   *\n   * @default false\n   */\n  restoreFocus?: boolean\n  children: ReactNode\n  /**\n   * If `true`, focus trapping will be disabled.\n   *\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the first focusable element within the `children` will auto-focused once `FocusLock` mounts.\n   *\n   * @default false\n   */\n  autoFocus?: boolean\n  /**\n   * If `true`, disables text selections inside, and outside focus lock.\n   *\n   * @default false\n   */\n  persistentFocus?: boolean\n  /**\n   * Enables aggressive focus capturing within iframes.\n   * - If `true`: keep focus in the lock, no matter where lock is active.\n   * - If `false`:  allows focus to move outside of iframe.\n   *\n   * @default false\n   */\n  lockFocusAcrossFrames?: boolean\n}\n\n/**\n * `FocusLock` is a component that improves accessibility by restricting focus within elements such as modals and dialogs, and locking the focus within that range.\n *\n * @see Docs https://yamada-ui.com/components/other/focus-lock\n */\n\nexport const FocusLock: FC<FocusLockProps> = ({\n  initialFocusRef,\n  finalFocusRef,\n  contentRef,\n  restoreFocus,\n  children,\n  isDisabled,\n  autoFocus,\n  persistentFocus,\n  lockFocusAcrossFrames,\n}) => {\n  const onActivation = useCallback(() => {\n    if (initialFocusRef?.current) {\n      initialFocusRef.current.focus()\n    } else if (contentRef?.current) {\n      const focusables = getAllFocusable(contentRef.current)\n\n      if (focusables.length === 0)\n        requestAnimationFrame(() => {\n          contentRef.current?.focus()\n        })\n    }\n  }, [initialFocusRef, contentRef])\n\n  const onDeactivation = useCallback(() => {\n    finalFocusRef?.current?.focus()\n  }, [finalFocusRef])\n\n  const returnFocus = restoreFocus && !finalFocusRef\n\n  return (\n    <InternalFocusLock\n      crossFrame={lockFocusAcrossFrames}\n      persistentFocus={persistentFocus}\n      autoFocus={autoFocus}\n      disabled={isDisabled}\n      onActivation={onActivation}\n      onDeactivation={onDeactivation}\n      returnFocus={returnFocus}\n    >\n      {children}\n    </InternalFocusLock>\n  )\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,mBAAgD;AAEhD,mBAA4B;AAC5B,8BAA2B;AAyFvB;AAvFJ,IAAM,wBAAoB,6BAAe,wBAAAA,OAAc;AAwDhD,IAAM,YAAgC,CAAC;AAAA,EAC5C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AACJ,QAAM,mBAAe,0BAAY,MAAM;AACrC,QAAI,mDAAiB,SAAS;AAC5B,sBAAgB,QAAQ,MAAM;AAAA,IAChC,WAAW,yCAAY,SAAS;AAC9B,YAAM,iBAAa,8BAAgB,WAAW,OAAO;AAErD,UAAI,WAAW,WAAW;AACxB,8BAAsB,MAAM;AAhFpC;AAiFU,2BAAW,YAAX,mBAAoB;AAAA,QACtB,CAAC;AAAA,IACL;AAAA,EACF,GAAG,CAAC,iBAAiB,UAAU,CAAC;AAEhC,QAAM,qBAAiB,0BAAY,MAAM;AAtF3C;AAuFI,yDAAe,YAAf,mBAAwB;AAAA,EAC1B,GAAG,CAAC,aAAa,CAAC;AAElB,QAAM,cAAc,gBAAgB,CAAC;AAErC,SACE;AAAA,IAAC;AAAA;AAAA,MACC,YAAY;AAAA,MACZ;AAAA,MACA;AAAA,MACA,UAAU;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,MAEC;AAAA;AAAA,EACH;AAEJ;","names":["ReactFocusLock"]}