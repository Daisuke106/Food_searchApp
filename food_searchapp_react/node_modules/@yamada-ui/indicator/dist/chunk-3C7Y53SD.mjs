"use client"

// src/indicator.tsx
import {
  ui,
  forwardRef,
  omitThemeProps,
  useComponentStyle
} from "@yamada-ui/core";
import { useAnimation } from "@yamada-ui/use-animation";
import { useValue } from "@yamada-ui/use-value";
import { cx } from "@yamada-ui/utils";
import { useMemo } from "react";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
var getPlacementStyle = (placement, offset) => {
  const styles = {};
  let translateX = "";
  let translateY = "";
  if (placement.includes("top")) {
    styles.top = offset;
    translateY = "-50%";
  } else if (placement.includes("bottom")) {
    styles.bottom = offset;
    translateY = "50%";
  } else {
    styles.top = "50%";
    translateY = "-50%";
  }
  if (placement.includes("left")) {
    styles.left = offset;
    translateX = "-50%";
  } else if (placement.includes("right")) {
    styles.right = offset;
    translateX = "50%";
  } else {
    styles.left = "50%";
    translateX = "-50%";
  }
  styles.transform = `translate(${translateX}, ${translateY})`;
  return styles;
};
var Indicator = forwardRef((props, ref) => {
  const [styles, mergedProps] = useComponentStyle("Indicator", props);
  let {
    className,
    inline = false,
    placement = "top-right",
    offset = 0,
    label,
    overflowCount = 99,
    showZero = true,
    children,
    isDisabled,
    containerProps,
    ping,
    pingColor = "var(--ui-ping)",
    pingDuration = "1.4s",
    pingCount = "infinite",
    pingScale = 1.8,
    ...rest
  } = omitThemeProps(mergedProps, ["withBorder"]);
  const animation = useAnimation({
    keyframes: {
      "75%, 100%": {
        transform: `scale(${pingScale})`,
        opacity: 0
      }
    },
    fillMode: "forwards",
    duration: pingDuration,
    timingFunction: "cubic-bezier(0, 0, 0.2, 1)",
    iterationCount: pingCount
  });
  const isNumeric = typeof label === "number";
  if (isNumeric && !showZero && label <= 0)
    isDisabled != null ? isDisabled : isDisabled = true;
  const computedInline = useValue(inline);
  const computedPlacement = useValue(placement);
  const computedOffset = useValue(offset);
  const renderLabel = useMemo(() => {
    if (isNumeric) {
      if (label > overflowCount) {
        return /* @__PURE__ */ jsxs(Fragment, { children: [
          overflowCount,
          /* @__PURE__ */ jsx(ui.span, { lineHeight: 1, children: "+" })
        ] });
      } else {
        return label;
      }
    } else {
      return label;
    }
  }, [isNumeric, label, overflowCount]);
  const css = {
    position: "absolute",
    ...getPlacementStyle(computedPlacement, computedOffset),
    ...isNumeric ? { fontWeight: "medium" } : {},
    ...styles
  };
  return /* @__PURE__ */ jsxs(
    ui.div,
    {
      ref,
      className: cx("ui-indicator", className),
      __css: {
        position: "relative",
        display: computedInline ? "inline-block" : "block"
      },
      ...containerProps,
      children: [
        !isDisabled ? /* @__PURE__ */ jsxs(
          ui.div,
          {
            ref,
            className: cx("ui-indicator__icon", className),
            __css: css,
            ...rest,
            children: [
              renderLabel,
              ping ? /* @__PURE__ */ jsx(
                ui.div,
                {
                  className: "ui-indicator__icon__ping",
                  __css: {
                    position: "absolute",
                    boxSize: "100%",
                    rounded: "fallback(full, 9999px)",
                    opacity: 0.75,
                    zIndex: -1,
                    bg: pingColor
                  },
                  animation
                }
              ) : null
            ]
          }
        ) : null,
        children
      ]
    }
  );
});

export {
  Indicator
};
//# sourceMappingURL=chunk-3C7Y53SD.mjs.map