import * as react_jsx_runtime from 'react/jsx-runtime';
import * as react from 'react';
import { ReactElement, RefObject, Dispatch, SetStateAction, ChangeEvent, MouseEvent } from 'react';
import * as _yamada_ui_use_descendant from '@yamada-ui/use-descendant';
import * as _yamada_ui_core from '@yamada-ui/core';
import { HTMLUIProps, UIPropGetter, CSSUIObject } from '@yamada-ui/core';
import { FormControlOptions } from '@yamada-ui/form-control';
import { MotionUIPropGetter } from '@yamada-ui/motion';
import { PopoverProps } from '@yamada-ui/popover';
import { Dict, DOMAttributes, Union } from '@yamada-ui/utils';

type AutocompleteOptionOptions = {
    /**
     * The autocomplete option icon to use.
     */
    icon?: ReactElement;
};
type AutocompleteOptionProps = UseAutocompleteOptionProps & AutocompleteOptionOptions;
declare const AutocompleteOption: _yamada_ui_core.Component<"li", AutocompleteOptionProps>;

type AutocompleteBaseItem = Omit<AutocompleteOptionProps, "value" | "children"> & {
    label?: string;
};
type AutocompleteItemWithValue = AutocompleteBaseItem & {
    value?: string;
};
type AutocompleteItemWithItems = AutocompleteBaseItem & {
    items?: AutocompleteItemWithValue[];
};
type AutocompleteItem = AutocompleteItemWithValue | AutocompleteItemWithItems;
declare const AutocompleteDescendantsContextProvider: react.Provider<{
    register: (nodeOrOptions: HTMLElement | {
        disabled?: boolean | undefined;
        id?: string | undefined;
        filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined;
    } | null) => void | ((node: HTMLElement | null) => void);
    unregister: (node: HTMLElement) => void;
    destroy: () => void;
    count: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => number;
    values: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}>[];
    value: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    indexOf: (node: HTMLElement | null) => number;
    firstValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    lastValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    prevValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined; /**
     * The value of the autocomplete.
     */
    nextValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    enabledCount: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => number;
    enabledValues: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}>[];
    enabledValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined; /**
     * The initial value of the autocomplete.
     */
    enabledIndexOf: (node: HTMLElement | null, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => number;
    enabledFirstValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    enabledLastValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    enabledPrevValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    enabledNextValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
}>;
declare const useAutocompleteDescendantsContext: () => {
    register: (nodeOrOptions: HTMLElement | {
        disabled?: boolean | undefined;
        id?: string | undefined;
        filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined;
    } | null) => void | ((node: HTMLElement | null) => void);
    unregister: (node: HTMLElement) => void;
    destroy: () => void;
    count: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => number;
    values: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}>[];
    value: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    indexOf: (node: HTMLElement | null) => number;
    firstValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    lastValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    prevValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined; /**
     * The value of the autocomplete.
     */
    nextValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    enabledCount: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => number;
    enabledValues: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}>[];
    enabledValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined; /**
     * The initial value of the autocomplete.
     */
    enabledIndexOf: (node: HTMLElement | null, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => number;
    enabledFirstValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    enabledLastValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    enabledPrevValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    enabledNextValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
};
declare const useAutocompleteDescendants: () => {
    register: (nodeOrOptions: HTMLElement | {
        disabled?: boolean | undefined;
        id?: string | undefined;
        filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined;
    } | null) => void | ((node: HTMLElement | null) => void);
    unregister: (node: HTMLElement) => void;
    destroy: () => void;
    count: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => number;
    values: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}>[];
    value: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    indexOf: (node: HTMLElement | null) => number;
    firstValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    lastValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    prevValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined; /**
     * The value of the autocomplete.
     */
    nextValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    enabledCount: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => number;
    enabledValues: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}>[];
    enabledValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined; /**
     * The initial value of the autocomplete.
     */
    enabledIndexOf: (node: HTMLElement | null, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => number;
    enabledFirstValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    enabledLastValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    enabledPrevValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    enabledNextValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
};
declare const useAutocompleteDescendant: (options?: {
    disabled?: boolean | undefined;
    id?: string | undefined;
    filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined;
} | undefined) => {
    descendants: {
        register: (nodeOrOptions: HTMLElement | _yamada_ui_use_descendant.DescendantOptions<HTMLElement, Record<string, any>> | null) => void | ((node: HTMLElement | null) => void);
        unregister: (node: HTMLElement) => void;
        destroy: () => void;
        count: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined) => number;
        values: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, Record<string, any>>[];
        value: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, Record<string, any>> | undefined;
        indexOf: (node: HTMLElement | null) => number;
        firstValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, Record<string, any>> | undefined;
        lastValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, Record<string, any>> | undefined;
        prevValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, Record<string, any>> | undefined; /**
         * The value of the autocomplete.
         */
        nextValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, Record<string, any>> | undefined;
        enabledCount: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined) => number;
        enabledValues: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, Record<string, any>>[];
        enabledValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, Record<string, any>> | undefined; /**
         * The initial value of the autocomplete.
         */
        enabledIndexOf: (node: HTMLElement | null, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined) => number;
        enabledFirstValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, Record<string, any>> | undefined;
        enabledLastValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, Record<string, any>> | undefined;
        enabledPrevValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, Record<string, any>> | undefined;
        enabledNextValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, Record<string, any>> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, Record<string, any>> | undefined;
    };
    index: number;
    enabledIndex: number;
    register: (node: HTMLElement | null) => void;
};
type AutocompleteContext = Omit<UseAutocompleteProps, "value" | "defaultValue" | "onChange" | "onCreate"> & {
    value: string | string[];
    label: string | string[] | undefined;
    inputValue: string;
    isHit: boolean;
    isEmpty: boolean;
    isAllSelected: boolean;
    onChange: (newValue: string) => void;
    onChangeLabel: (newValue: string, runOmit?: boolean) => void;
    pickOptions: (value: string) => void;
    rebirthOptions: (runFocus?: boolean) => void;
    inputProps: DOMAttributes;
    isOpen: boolean;
    onOpen: () => void;
    onClose: () => void;
    onCreate: () => void;
    onFocusFirst: () => void;
    onFocusLast: () => void;
    onFocusNext: (index?: number) => void;
    onFocusPrev: (index?: number) => void;
    focusedIndex: number;
    setFocusedIndex: Dispatch<SetStateAction<number>>;
    listRef: RefObject<HTMLUListElement>;
    inputRef: RefObject<HTMLInputElement>;
    formControlProps: Record<string, any>;
    styles: Record<string, CSSUIObject>;
};
declare const AutocompleteProvider: react.Provider<AutocompleteContext>;
declare const useAutocompleteContext: () => AutocompleteContext;
type UseAutocompleteBaseProps<T extends string | string[] = string> = Omit<PopoverProps, "initialFocusRef" | "closeOnButton" | "trigger" | "autoFocus" | "restoreFocus" | "openDelay" | "closeDelay"> & FormControlOptions & {
    /**
     * The value of the autocomplete.
     */
    value?: T;
    /**
     * The initial value of the autocomplete.
     */
    defaultValue?: T;
    /**
     * The callback invoked when value state changes.
     */
    onChange?: (value: T) => void;
    /**
     * The callback invoked when search input.
     */
    onSearch?: (ev: ChangeEvent<HTMLInputElement>) => void;
    /**
     * The callback invoked when autocomplete option created.
     */
    onCreate?: (newItem: AutocompleteItem, newItems: AutocompleteItem[]) => void;
    /**
     * Function to format text when search input.
     */
    format?: (value: string) => string;
    /**
     * The position to be inserted when the autocomplete option is created.
     *
     * @default 'first'
     */
    insertPositionItem?: Union<"first" | "last"> | [string, "first" | "last"];
    /**
     * If `true`, the list element will be closed when value is selected.
     *
     * @default true
     */
    closeOnSelect?: boolean;
    /**
     * The message displayed when the search yields no hits.
     *
     * @default 'No results found'
     */
    emptyMessage?: string;
    /**
     * If `true`, enables the creation of autocomplete option.
     *
     * @default false
     */
    allowCreate?: boolean;
    /**
     * If `true`, enables the free input.
     */
    allowFree?: boolean;
    /**
     * If `true`, the selected item(s) will be excluded from the list.
     *
     * @default false
     */
    omitSelectedValues?: boolean;
    /**
     * The maximum selectable value.
     */
    maxSelectValues?: number;
    /**
     * Props for select option element.
     */
    optionProps?: Omit<AutocompleteOptionProps, "value" | "children">;
    /**
     * If provided, generate options based on items.
     */
    items?: AutocompleteItem[];
};
type UseAutocompleteProps<T extends string | string[] = string> = Omit<HTMLUIProps<"input">, keyof UseAutocompleteBaseProps | "list" | "disabled" | "required" | "readOnly" | "size"> & UseAutocompleteBaseProps<T>;
declare const useAutocomplete: <T extends string | string[] = string>({ value: valueProp, defaultValue, onChange: onChangeProp, onCreate: onCreateProp, onSearch: onSearchProp, closeOnSelect, omitSelectedValues, maxSelectValues, closeOnBlur, closeOnEsc, allowCreate, allowFree, insertPositionItem, emptyMessage, format, placement, duration, optionProps, placeholder, items, children, isOpen: isOpenProp, defaultIsOpen, onOpen: onOpenProp, onClose: onCloseProp, ...rest }: UseAutocompleteProps<T>) => {
    id: string | undefined;
    descendants: {
        register: (nodeOrOptions: HTMLElement | {
            disabled?: boolean | undefined;
            id?: string | undefined;
            filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined;
        } | null) => void | ((node: HTMLElement | null) => void);
        unregister: (node: HTMLElement) => void;
        destroy: () => void;
        count: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => number;
        values: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}>[];
        value: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
        indexOf: (node: HTMLElement | null) => number;
        firstValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
        lastValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
        prevValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined; /**
         * The value of the autocomplete.
         */
        nextValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
        enabledCount: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => number;
        enabledValues: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}>[];
        enabledValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined; /**
         * The initial value of the autocomplete.
         */
        enabledIndexOf: (node: HTMLElement | null, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => number;
        enabledFirstValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
        enabledLastValue: (filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
        enabledPrevValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
        enabledNextValue: (index: number, filter?: _yamada_ui_use_descendant.FilterDescendant<HTMLElement, {}> | undefined, loop?: boolean) => _yamada_ui_use_descendant.Descendant<HTMLElement, {}> | undefined;
    };
    value: T;
    label: T | undefined;
    inputValue: string;
    isHit: boolean;
    isEmpty: boolean;
    computedChildren: (react_jsx_runtime.JSX.Element | undefined)[] | undefined;
    focusedIndex: number;
    omitSelectedValues: boolean;
    closeOnSelect: boolean;
    allowCreate: boolean;
    allowFree: boolean;
    emptyMessage: string;
    isOpen: boolean;
    isAllSelected: boolean;
    listRef: RefObject<HTMLUListElement>;
    inputRef: RefObject<HTMLInputElement>;
    optionProps: Omit<AutocompleteOptionProps, "value" | "children"> | undefined;
    formControlProps: {
        [x: string]: any;
    };
    setFocusedIndex: Dispatch<SetStateAction<number>>;
    onChangeLabel: (newValue: string, runOmit?: boolean) => void;
    onChange: (newValue: string, runRebirth?: boolean) => void;
    onSearch: (ev: ChangeEvent<HTMLInputElement>) => void;
    onCreate: () => void;
    onClear: (ev: MouseEvent<HTMLDivElement>) => void;
    onCompositionStart: () => void;
    onCompositionEnd: () => void;
    pickOptions: (value: string) => void;
    rebirthOptions: (runFocus?: boolean) => void;
    onOpen: () => void;
    onClose: () => void;
    onFocusFirst: () => void;
    onFocusLast: () => void;
    onFocusSelected: () => void;
    onFocusNext: (index?: number) => void;
    onFocusPrev: (index?: number) => void;
    getPopoverProps: (props?: PopoverProps) => PopoverProps;
    getContainerProps: UIPropGetter;
    getFieldProps: UIPropGetter;
    inputProps: Omit<Dict, string>;
};
type UseAutocompleteReturn = ReturnType<typeof useAutocomplete>;
declare const useAutocompleteInput: () => {
    getInputProps: UIPropGetter<"input">;
};
type UseAutocompleteInputReturn = ReturnType<typeof useAutocompleteInput>;
declare const useAutocompleteList: () => {
    getListProps: MotionUIPropGetter<"ul">;
};
type UseAutocompleteOptionGroupProps = HTMLUIProps<"ul"> & {
    /**
     * The label of the autocomplete option group.
     */
    label: string;
};
declare const useAutocompleteOptionGroup: ({ label, ...rest }: UseAutocompleteOptionGroupProps) => {
    label: string;
    getContainerProps: UIPropGetter;
    getGroupProps: UIPropGetter;
};
type UseAutocompleteOptionGroupReturn = ReturnType<typeof useAutocompleteOptionGroup>;
type UseAutocompleteOptionProps = Omit<HTMLUIProps<"li">, "value" | "children"> & {
    /**
     * The value of the select option.
     */
    value?: string;
    /**
     * The label of the select option.
     */
    children?: string;
    /**
     * If `true`, the select option will be disabled.
     *
     * @default false
     */
    isDisabled?: boolean;
    /**
     * If `true`, the select option will be focusable.
     *
     * @default false
     */
    isFocusable?: boolean;
    /**
     * If `true`, the list element will be closed when selected.
     *
     * @default false
     */
    closeOnSelect?: boolean;
};
declare const useAutocompleteOption: (props: UseAutocompleteOptionProps) => {
    isSelected: boolean;
    isFocused: boolean;
    customIcon: react.ReactElement<any, string | react.JSXElementConstructor<any>> | undefined;
    children: string | undefined;
    getOptionProps: UIPropGetter<"li">;
};
type UseAutocompleteOptionReturn = ReturnType<typeof useAutocompleteOption>;
declare const useAutocompleteCreate: () => {
    getCreateProps: UIPropGetter<"li">;
};
type UseAutocompleteCreateReturn = ReturnType<typeof useAutocompleteCreate>;
declare const useAutocompleteEmpty: () => {
    getEmptyProps: UIPropGetter<"li">;
};
type UseAutocompleteEmptyReturn = ReturnType<typeof useAutocompleteEmpty>;

export { AutocompleteOption as A, type UseAutocompleteOptionGroupProps as U, type AutocompleteOptionProps as a, type AutocompleteItem as b, type UseAutocompleteProps as c, AutocompleteDescendantsContextProvider as d, useAutocompleteDescendants as e, useAutocompleteDescendant as f, AutocompleteProvider as g, useAutocompleteContext as h, useAutocomplete as i, type UseAutocompleteReturn as j, useAutocompleteInput as k, type UseAutocompleteInputReturn as l, useAutocompleteList as m, useAutocompleteOptionGroup as n, type UseAutocompleteOptionGroupReturn as o, type UseAutocompleteOptionProps as p, useAutocompleteOption as q, type UseAutocompleteOptionReturn as r, useAutocompleteCreate as s, type UseAutocompleteCreateReturn as t, useAutocompleteDescendantsContext as u, useAutocompleteEmpty as v, type UseAutocompleteEmptyReturn as w };
