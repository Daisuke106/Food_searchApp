"use client"
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/autocomplete-option.tsx
var autocomplete_option_exports = {};
__export(autocomplete_option_exports, {
  AutocompleteOption: () => AutocompleteOption
});
module.exports = __toCommonJS(autocomplete_option_exports);
var import_core3 = require("@yamada-ui/core");
var import_utils3 = require("@yamada-ui/utils");

// src/autocomplete-icon.tsx
var import_core2 = require("@yamada-ui/core");
var import_icon = require("@yamada-ui/icon");
var import_use_clickable = require("@yamada-ui/use-clickable");
var import_utils2 = require("@yamada-ui/utils");
var import_react2 = require("react");

// src/use-autocomplete.tsx
var import_core = require("@yamada-ui/core");
var import_form_control = require("@yamada-ui/form-control");
var import_popover = require("@yamada-ui/popover");
var import_use_controllable_state = require("@yamada-ui/use-controllable-state");
var import_use_descendant = require("@yamada-ui/use-descendant");
var import_use_disclosure = require("@yamada-ui/use-disclosure");
var import_use_outside_click = require("@yamada-ui/use-outside-click");
var import_utils = require("@yamada-ui/utils");
var import_react = require("react");
var import_jsx_runtime = require("react/jsx-runtime");
var isTargetOption = (target) => {
  var _a;
  return (0, import_utils.isHTMLElement)(target) && !!((_a = target == null ? void 0 : target.getAttribute("role")) == null ? void 0 : _a.startsWith("autocomplete-item"));
};
var {
  DescendantsContextProvider: AutocompleteDescendantsContextProvider,
  useDescendantsContext: useAutocompleteDescendantsContext,
  useDescendants: useAutocompleteDescendants,
  useDescendant: useAutocompleteDescendant
} = (0, import_use_descendant.createDescendant)();
var [AutocompleteProvider, useAutocompleteContext] = (0, import_utils.createContext)({
  name: "AutocompleteContext",
  errorMessage: `useAutocompleteContext returned is 'undefined'. Seems you forgot to wrap the components in "<Autocomplete />" or "<MultiAutocomplete />"`
});
var useAutocompleteOption = (props) => {
  var _a, _b;
  const {
    value,
    omitSelectedValues,
    onChange,
    onChangeLabel,
    focusedIndex,
    setFocusedIndex,
    onClose,
    closeOnSelect: generalCloseOnSelect,
    optionProps,
    inputRef,
    onFocusNext
  } = useAutocompleteContext();
  let {
    icon: customIcon,
    isDisabled,
    isFocusable,
    closeOnSelect: customCloseOnSelect,
    children,
    value: optionValue,
    ...computedProps
  } = { ...optionProps, ...props };
  const trulyDisabled = !!isDisabled && !isFocusable;
  const itemRef = (0, import_react.useRef)(null);
  const { index, register, descendants } = useAutocompleteDescendant({
    disabled: trulyDisabled
  });
  const values = descendants.values();
  const frontValues = values.slice(0, index);
  const isMulti = (0, import_utils.isArray)(value);
  const isDuplicated = !isMulti ? frontValues.some(({ node }) => node.dataset.value === (optionValue != null ? optionValue : "")) : false;
  const isSelected = !isDuplicated && (!isMulti ? (optionValue != null ? optionValue : "") === value : value.includes(optionValue != null ? optionValue : ""));
  const isTarget = "target" in ((_b = (_a = itemRef.current) == null ? void 0 : _a.dataset) != null ? _b : {});
  const isFocused = index === focusedIndex;
  const onClick = (0, import_react.useCallback)(
    (ev) => {
      ev.stopPropagation();
      if (isDisabled) {
        if (inputRef.current)
          inputRef.current.focus();
        return;
      }
      if (!isTargetOption(ev.currentTarget)) {
        if (inputRef.current)
          inputRef.current.focus();
        return;
      }
      setFocusedIndex(index);
      onChange(optionValue != null ? optionValue : "");
      if (inputRef.current)
        inputRef.current.focus();
      if (customCloseOnSelect != null ? customCloseOnSelect : generalCloseOnSelect)
        onClose();
      if (omitSelectedValues)
        onFocusNext(index);
    },
    [
      onFocusNext,
      omitSelectedValues,
      isDisabled,
      optionValue,
      setFocusedIndex,
      index,
      onChange,
      customCloseOnSelect,
      generalCloseOnSelect,
      onClose,
      inputRef
    ]
  );
  (0, import_utils.useUpdateEffect)(() => {
    if (isSelected)
      onChangeLabel(optionValue != null ? optionValue : "", false);
  }, [optionValue]);
  const getOptionProps = (0, import_react.useCallback)(
    (props2 = {}, ref = null) => {
      const style = {
        border: "0px",
        clip: "rect(0px, 0px, 0px, 0px)",
        height: "1px",
        width: "1px",
        margin: "-1px",
        padding: "0px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        position: "absolute"
      };
      return {
        ref: (0, import_utils.mergeRefs)(itemRef, ref, register),
        ...computedProps,
        ...props2,
        role: "autocomplete-item",
        tabIndex: -1,
        style: !isTarget || omitSelectedValues && isSelected ? style : void 0,
        "data-target": (0, import_utils.dataAttr)(true),
        "data-value": optionValue != null ? optionValue : "",
        "data-focus": (0, import_utils.dataAttr)(isFocused),
        "data-disabled": (0, import_utils.dataAttr)(isDisabled),
        "aria-checked": (0, import_utils.ariaAttr)(isSelected),
        "aria-disabled": (0, import_utils.ariaAttr)(isDisabled),
        onClick: (0, import_utils.handlerAll)(computedProps.onClick, props2.onClick, onClick)
      };
    },
    [
      optionValue,
      computedProps,
      isDisabled,
      isFocused,
      isSelected,
      isTarget,
      omitSelectedValues,
      onClick,
      register
    ]
  );
  return {
    isSelected,
    isFocused,
    customIcon,
    children,
    getOptionProps
  };
};

// src/autocomplete-icon.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
var AutocompleteIcon = (0, import_core2.forwardRef)(
  ({ className, children, __css, ...rest }, ref) => {
    const { styles } = useAutocompleteContext();
    const css = {
      position: "absolute",
      top: "50%",
      transform: "translateY(-50%)",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      pointerEvents: "none",
      cursor: "pointer",
      ...styles.icon,
      ...__css
    };
    const validChildren = (0, import_utils2.getValidChildren)(children);
    const cloneChildren = validChildren.map(
      (child) => (0, import_react2.cloneElement)(child, {
        focusable: false,
        "aria-hidden": true,
        style: {
          maxWidth: "1em",
          maxHeight: "1em",
          color: "currentColor"
        }
      })
    );
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
      import_core2.ui.div,
      {
        ref,
        className: (0, import_utils2.cx)("ui-autocomplete__icon", className),
        __css: css,
        ...rest,
        children: (0, import_utils2.isValidElement)(children) ? cloneChildren : /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_icon.ChevronIcon, {})
      }
    );
  }
);
var AutocompleteItemIcon = (0, import_core2.forwardRef)(({ className, ...rest }, ref) => {
  const { styles } = useAutocompleteContext();
  const css = {
    flexShrink: 0,
    display: "inline-flex",
    justifyContent: "center",
    alignItems: "center",
    fontSize: "0.85em",
    ...styles.itemIcon
  };
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    import_core2.ui.span,
    {
      ref,
      className: (0, import_utils2.cx)("ui-autocomplete__item__icon", className),
      __css: css,
      ...rest
    }
  );
});

// src/autocomplete-option.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
var AutocompleteOption = (0, import_core3.forwardRef)(
  ({ className, icon, ...rest }, ref) => {
    const { styles } = useAutocompleteContext();
    const { isSelected, customIcon, children, getOptionProps } = useAutocompleteOption(rest);
    icon != null ? icon : icon = customIcon;
    const css = {
      textDecoration: "none",
      color: "inherit",
      userSelect: "none",
      display: "flex",
      width: "100%",
      alignItems: "center",
      textAlign: "start",
      flex: "0 0 auto",
      outline: 0,
      gap: "0.75rem",
      ...styles.item
    };
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(
      import_core3.ui.li,
      {
        className: (0, import_utils3.cx)("ui-autocomplete__item", className),
        __css: css,
        ...getOptionProps({}, ref),
        children: [
          icon !== null ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(AutocompleteItemIcon, { opacity: isSelected ? 1 : 0, children: icon || /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(CheckIcon, {}) }) : null,
          /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_core3.ui.span, { style: { flex: 1 }, "data-label": true, children })
        ]
      }
    );
  }
);
var CheckIcon = () => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("svg", { viewBox: "0 0 14 14", width: "1em", height: "1em", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
  "polygon",
  {
    fill: "currentColor",
    points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039"
  }
) });
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AutocompleteOption
});
//# sourceMappingURL=autocomplete-option.js.map