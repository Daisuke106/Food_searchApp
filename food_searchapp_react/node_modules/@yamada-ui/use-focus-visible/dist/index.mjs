"use client"

// src/index.ts
import { isMac } from "@yamada-ui/utils";
import { useEffect, useState } from "react";
var hasSetup = false;
var modality = null;
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var handlers = /* @__PURE__ */ new Set();
var trigger = (modality2, ev) => handlers.forEach((handler) => handler(modality2, ev));
var onValid = (e) => {
  return !(e.metaKey || !isMac && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
};
var onKeyboard = (ev) => {
  hasEventBeforeFocus = true;
  if (onValid(ev)) {
    modality = "keyboard";
    trigger("keyboard", ev);
  }
};
var onPointer = (ev) => {
  modality = "pointer";
  if (ev.type === "mousedown" || ev.type === "pointerdown" || ev.type === "pointerup") {
    hasEventBeforeFocus = true;
    const target = ev.composedPath ? ev.composedPath()[0] : ev.target;
    if (target.matches(":focus-visible"))
      return;
    trigger("pointer", ev);
  }
};
var isVirtualClick = (ev) => {
  if (ev.mozInputSource === 0 && ev.isTrusted)
    return true;
  return ev.detail === 0 && !ev.pointerType;
};
var onClick = (ev) => {
  if (!isVirtualClick(ev))
    return;
  hasEventBeforeFocus = true;
  modality = "virtual";
};
var onFocus = (ev) => {
  if (ev.target === window || ev.target === document)
    return;
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    modality = "virtual";
    trigger("virtual", ev);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
};
var onBlur = () => {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
};
var isFocusVisible = () => modality !== "pointer";
var setGlobalFocusEvents = () => {
  if (typeof window === "undefined" || hasSetup)
    return;
  const { focus } = HTMLElement.prototype;
  HTMLElement.prototype.focus = function customFocus(...args) {
    hasEventBeforeFocus = true;
    if (this)
      focus.apply(this, args);
  };
  document.addEventListener("keydown", onKeyboard, true);
  document.addEventListener("keyup", onKeyboard, true);
  document.addEventListener("click", onClick, true);
  window.addEventListener("focus", onFocus, true);
  window.addEventListener("blur", onBlur, false);
  if (typeof PointerEvent !== "undefined") {
    document.addEventListener("pointerdown", onPointer, true);
    document.addEventListener("pointermove", onPointer, true);
    document.addEventListener("pointerup", onPointer, true);
  } else {
    document.addEventListener("mousedown", onPointer, true);
    document.addEventListener("mousemove", onPointer, true);
    document.addEventListener("mouseup", onPointer, true);
  }
  hasSetup = true;
};
var trackFocusVisible = (func, { force } = {}) => {
  if (force)
    hasSetup = false;
  setGlobalFocusEvents();
  func(isFocusVisible());
  const handler = () => func(isFocusVisible());
  handlers.add(handler);
  return () => {
    handlers.delete(handler);
  };
};
var useFocusVisible = (options) => {
  const [focusVisible, setFocusVisible] = useState(false);
  const [focus, setFocus] = useState(false);
  useEffect(() => {
    return trackFocusVisible(setFocusVisible, options);
  }, [options]);
  return {
    focusVisible: focusVisible && focus,
    onFocus: () => setFocus(true),
    onBlur: () => setFocus(false)
  };
};
export {
  trackFocusVisible,
  useFocusVisible
};
//# sourceMappingURL=index.mjs.map