"use client"
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  trackFocusVisible: () => trackFocusVisible,
  useFocusVisible: () => useFocusVisible
});
module.exports = __toCommonJS(src_exports);
var import_utils = require("@yamada-ui/utils");
var import_react = require("react");
var hasSetup = false;
var modality = null;
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var handlers = /* @__PURE__ */ new Set();
var trigger = (modality2, ev) => handlers.forEach((handler) => handler(modality2, ev));
var onValid = (e) => {
  return !(e.metaKey || !import_utils.isMac && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
};
var onKeyboard = (ev) => {
  hasEventBeforeFocus = true;
  if (onValid(ev)) {
    modality = "keyboard";
    trigger("keyboard", ev);
  }
};
var onPointer = (ev) => {
  modality = "pointer";
  if (ev.type === "mousedown" || ev.type === "pointerdown" || ev.type === "pointerup") {
    hasEventBeforeFocus = true;
    const target = ev.composedPath ? ev.composedPath()[0] : ev.target;
    if (target.matches(":focus-visible"))
      return;
    trigger("pointer", ev);
  }
};
var isVirtualClick = (ev) => {
  if (ev.mozInputSource === 0 && ev.isTrusted)
    return true;
  return ev.detail === 0 && !ev.pointerType;
};
var onClick = (ev) => {
  if (!isVirtualClick(ev))
    return;
  hasEventBeforeFocus = true;
  modality = "virtual";
};
var onFocus = (ev) => {
  if (ev.target === window || ev.target === document)
    return;
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    modality = "virtual";
    trigger("virtual", ev);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
};
var onBlur = () => {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
};
var isFocusVisible = () => modality !== "pointer";
var setGlobalFocusEvents = () => {
  if (typeof window === "undefined" || hasSetup)
    return;
  const { focus } = HTMLElement.prototype;
  HTMLElement.prototype.focus = function customFocus(...args) {
    hasEventBeforeFocus = true;
    if (this)
      focus.apply(this, args);
  };
  document.addEventListener("keydown", onKeyboard, true);
  document.addEventListener("keyup", onKeyboard, true);
  document.addEventListener("click", onClick, true);
  window.addEventListener("focus", onFocus, true);
  window.addEventListener("blur", onBlur, false);
  if (typeof PointerEvent !== "undefined") {
    document.addEventListener("pointerdown", onPointer, true);
    document.addEventListener("pointermove", onPointer, true);
    document.addEventListener("pointerup", onPointer, true);
  } else {
    document.addEventListener("mousedown", onPointer, true);
    document.addEventListener("mousemove", onPointer, true);
    document.addEventListener("mouseup", onPointer, true);
  }
  hasSetup = true;
};
var trackFocusVisible = (func, { force } = {}) => {
  if (force)
    hasSetup = false;
  setGlobalFocusEvents();
  func(isFocusVisible());
  const handler = () => func(isFocusVisible());
  handlers.add(handler);
  return () => {
    handlers.delete(handler);
  };
};
var useFocusVisible = (options) => {
  const [focusVisible, setFocusVisible] = (0, import_react.useState)(false);
  const [focus, setFocus] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    return trackFocusVisible(setFocusVisible, options);
  }, [options]);
  return {
    focusVisible: focusVisible && focus,
    onFocus: () => setFocus(true),
    onBlur: () => setFocus(false)
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  trackFocusVisible,
  useFocusVisible
});
//# sourceMappingURL=index.js.map