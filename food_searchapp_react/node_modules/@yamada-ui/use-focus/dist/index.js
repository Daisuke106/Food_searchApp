"use client"
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  useFocusOnHide: () => useFocusOnHide,
  useFocusOnPointerDown: () => useFocusOnPointerDown,
  useFocusOnShow: () => useFocusOnShow
});
module.exports = __toCommonJS(src_exports);
var import_use_event_listener = require("@yamada-ui/use-event-listener");
var import_utils = require("@yamada-ui/utils");
var import_react = require("react");
var preventReturnFocus = (containerRef) => {
  const el = containerRef.current;
  if (!el)
    return false;
  const activeElement = (0, import_utils.getActiveElement)(el);
  if (!activeElement)
    return false;
  if (el.contains(activeElement))
    return false;
  if ((0, import_utils.isTabbable)(activeElement))
    return true;
  return false;
};
var useFocusOnHide = (containerRef, { shouldFocus: shouldFocusProp, visible, focusRef }) => {
  const shouldFocus = shouldFocusProp && !visible;
  (0, import_utils.useUpdateEffect)(() => {
    if (!shouldFocus)
      return;
    if (preventReturnFocus(containerRef))
      return;
    const el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;
    if (el) {
      requestAnimationFrame(() => {
        el.focus();
      });
    }
  }, [shouldFocus, containerRef, focusRef]);
};
var useFocusOnShow = (target, { focusRef, preventScroll, shouldFocus, visible } = {
  preventScroll: true,
  shouldFocus: false
}) => {
  const element = (0, import_utils.isRefObject)(target) ? target.current : target;
  const autoFocusValue = shouldFocus && visible;
  const autoFocusRef = (0, import_react.useRef)(autoFocusValue);
  const lastVisibleRef = (0, import_react.useRef)(visible);
  (0, import_utils.useSafeLayoutEffect)(() => {
    if (!lastVisibleRef.current && visible)
      autoFocusRef.current = autoFocusValue;
    lastVisibleRef.current = visible;
  }, [visible, autoFocusValue]);
  const onFocus = (0, import_react.useCallback)(() => {
    if (!visible || !element || !autoFocusRef.current)
      return;
    autoFocusRef.current = false;
    if (element.contains(document.activeElement))
      return;
    if (focusRef == null ? void 0 : focusRef.current) {
      requestAnimationFrame(() => {
        var _a;
        (_a = focusRef.current) == null ? void 0 : _a.focus({ preventScroll });
      });
    } else {
      const tabbableEls = (0, import_utils.getAllFocusable)(element);
      if (tabbableEls.length > 0)
        requestAnimationFrame(() => {
          tabbableEls[0].focus({ preventScroll });
        });
    }
  }, [visible, preventScroll, element, focusRef]);
  (0, import_utils.useUpdateEffect)(() => {
    onFocus();
  }, [onFocus]);
  (0, import_use_event_listener.useEventListener)(element, "transitionend", onFocus);
};
var useFocusOnPointerDown = ({
  ref,
  elements,
  enabled
}) => {
  const doc = () => {
    var _a, _b;
    return (_b = (_a = ref.current) == null ? void 0 : _a.ownerDocument) != null ? _b : document;
  };
  (0, import_use_event_listener.useEventListener)(doc, "pointerdown", (ev) => {
    if (!(0, import_utils.isSafari)() || !enabled)
      return;
    const target = ev.target;
    const els = elements != null ? elements : [ref];
    const isValidTarget = els.some((elementOrRef) => {
      const el = (0, import_utils.isRefObject)(elementOrRef) ? elementOrRef.current : elementOrRef;
      return (el == null ? void 0 : el.contains(target)) || el === target;
    });
    if (doc().activeElement !== target && isValidTarget) {
      ev.preventDefault();
      target.focus();
    }
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useFocusOnHide,
  useFocusOnPointerDown,
  useFocusOnShow
});
//# sourceMappingURL=index.js.map