"use client"

// src/index.ts
import { useLatestRef } from "@yamada-ui/use-latest-ref";
import {
  addPointerEvent,
  getEventPoint,
  isMultiTouchEvent
} from "@yamada-ui/utils";
import sync, { cancelSync, getFrameData } from "framesync";
import { useEffect, useRef } from "react";
var subtract = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });
var getPanInfo = (info, history) => ({
  point: info.point,
  delta: subtract(info.point, history[history.length - 1]),
  offset: subtract(info.point, history[0]),
  velocity: getVelocity(history, 0.1)
});
var toMilliseconds = (v) => v * 1e3;
var getVelocity = (history, timeDelta) => {
  if (history.length < 2)
    return { x: 0, y: 0 };
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = history[history.length - 1];
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint)
    return { x: 0, y: 0 };
  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time === 0)
    return { x: 0, y: 0 };
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity)
    currentVelocity.x = 0;
  if (currentVelocity.y === Infinity)
    currentVelocity.y = 0;
  return currentVelocity;
};
var pipe = (...fns) => (v) => fns.reduce((a, b) => b(a), v);
var distance1D = (a, b) => Math.abs(a - b);
var isPoint = (point) => "x" in point && "y" in point;
var distance = (a, b) => {
  if (typeof a === "number" && typeof b === "number")
    return distance1D(a, b);
  if (isPoint(a) && isPoint(b)) {
    const xDelta = distance1D(a.x, b.x);
    const yDelta = distance1D(a.y, b.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }
  return 0;
};
var panEvent = (ev, handlers, threshold = 3) => {
  var _a;
  if (isMultiTouchEvent(ev))
    return;
  const win = (_a = ev.view) != null ? _a : window;
  const info = { point: getEventPoint(ev) };
  const { timestamp } = getFrameData();
  const { onSessionStart, onStart, onMove, onEnd, onSessionEnd } = handlers;
  const history = [{ ...info.point, timestamp }];
  let startEvent = null;
  let lastEvent = null;
  let lastEventInfo = null;
  ev.stopPropagation();
  ev.preventDefault();
  onSessionStart == null ? void 0 : onSessionStart(ev, getPanInfo(info, history));
  const updatePoint = () => {
    if (!(lastEvent && lastEventInfo))
      return;
    const info2 = getPanInfo(lastEventInfo, history);
    const isPanStarted = startEvent !== null;
    const isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= threshold;
    if (!isPanStarted && !isDistancePastThreshold)
      return;
    const { timestamp: timestamp2 } = getFrameData();
    history.push({ ...info2.point, timestamp: timestamp2 });
    if (!isPanStarted) {
      onStart == null ? void 0 : onStart(lastEvent, info2);
      startEvent = lastEvent;
    }
    onMove == null ? void 0 : onMove(lastEvent, info2);
  };
  const onPointerMove = (ev2, info2) => {
    lastEvent = ev2;
    lastEventInfo = info2;
    sync.update(updatePoint, true);
  };
  const onPointerUp = (ev2, info2) => {
    const panInfo = getPanInfo(info2, history);
    onSessionEnd == null ? void 0 : onSessionEnd(ev2, panInfo);
    end();
    if (!onEnd || !startEvent)
      return;
    onEnd == null ? void 0 : onEnd(ev2, panInfo);
  };
  const updateHandlers = (newHandlers) => {
    handlers = newHandlers;
  };
  let removeListeners = pipe(
    addPointerEvent(win, "pointermove", onPointerMove),
    addPointerEvent(win, "pointerup", onPointerUp),
    addPointerEvent(win, "pointercancel", onPointerUp)
  );
  const end = () => {
    removeListeners == null ? void 0 : removeListeners();
    cancelSync.update(updatePoint);
  };
  return {
    updateHandlers,
    end
  };
};
var usePanEvent = (ref, {
  onMove,
  onStart,
  onEnd,
  onSessionStart,
  onSessionEnd,
  threshold
}) => {
  const hasPanEvents = !!onMove || !!onStart || !!onEnd || !!onSessionStart || !!onSessionEnd;
  const panSession = useRef(null);
  const handlersRef = useLatestRef({
    onSessionStart,
    onSessionEnd,
    onStart,
    onMove,
    onEnd: (ev, info) => {
      panSession.current = null;
      onEnd == null ? void 0 : onEnd(ev, info);
    }
  });
  useEffect(() => {
    var _a;
    (_a = panSession.current) == null ? void 0 : _a.updateHandlers(handlersRef.current);
  });
  useEffect(() => {
    const node = ref.current;
    if (!node || !hasPanEvents)
      return;
    const onPointerDown = (ev) => {
      panSession.current = panEvent(ev, handlersRef.current, threshold);
    };
    return addPointerEvent(node, "pointerdown", onPointerDown);
  }, [ref, hasPanEvents, handlersRef, threshold]);
  useEffect(() => {
    return () => {
      var _a;
      (_a = panSession.current) == null ? void 0 : _a.end();
      panSession.current = null;
    };
  }, []);
};
export {
  usePanEvent
};
//# sourceMappingURL=index.mjs.map