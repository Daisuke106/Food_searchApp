{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { useLatestRef } from \"@yamada-ui/use-latest-ref\"\nimport type { AnyPointerEvent, Point, PointerEventInfo } from \"@yamada-ui/utils\"\nimport {\n  addPointerEvent,\n  getEventPoint,\n  isMultiTouchEvent,\n} from \"@yamada-ui/utils\"\nimport sync, { cancelSync, getFrameData } from \"framesync\"\nimport type { RefObject } from \"react\"\nimport { useEffect, useRef } from \"react\"\n\ntype PanEventInfo = {\n  point: Point\n  delta: Point\n  offset: Point\n  velocity: Point\n}\n\ntype PanEventHandler = (ev: AnyPointerEvent, info: PanEventInfo) => void\n\ntype TimestampedPoint = Point & { timestamp: number }\n\ntype PanEventHistory = TimestampedPoint[]\n\ntype PanEventHandlers = {\n  onSessionStart: PanEventHandler\n  onSessionEnd: PanEventHandler\n  onStart: PanEventHandler\n  onMove: PanEventHandler\n  onEnd: PanEventHandler\n}\n\nconst subtract = (a: Point, b: Point) => ({ x: a.x - b.x, y: a.y - b.y })\n\nconst getPanInfo = (info: PointerEventInfo, history: PanEventHistory) => ({\n  point: info.point,\n  delta: subtract(info.point, history[history.length - 1]),\n  offset: subtract(info.point, history[0]),\n  velocity: getVelocity(history, 0.1),\n})\n\nconst toMilliseconds = (v: number) => v * 1000\n\nconst getVelocity = (history: TimestampedPoint[], timeDelta: number): Point => {\n  if (history.length < 2) return { x: 0, y: 0 }\n\n  let i = history.length - 1\n  let timestampedPoint: TimestampedPoint | null = null\n\n  const lastPoint = history[history.length - 1]\n\n  while (i >= 0) {\n    timestampedPoint = history[i]\n\n    if (\n      lastPoint.timestamp - timestampedPoint.timestamp >\n      toMilliseconds(timeDelta)\n    ) {\n      break\n    }\n\n    i--\n  }\n\n  if (!timestampedPoint) return { x: 0, y: 0 }\n\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000\n\n  if (time === 0) return { x: 0, y: 0 }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time,\n  }\n\n  if (currentVelocity.x === Infinity) currentVelocity.x = 0\n\n  if (currentVelocity.y === Infinity) currentVelocity.y = 0\n\n  return currentVelocity\n}\n\nconst pipe =\n  <Y extends any>(...fns: ((a: Y) => Y)[]) =>\n  (v: Y) =>\n    fns.reduce((a, b) => b(a), v)\n\nconst distance1D = (a: number, b: number) => Math.abs(a - b)\n\nconst isPoint = (point: any): point is { x: number; y: number } =>\n  \"x\" in point && \"y\" in point\n\nconst distance = <Y extends Point | number>(a: Y, b: Y) => {\n  if (typeof a === \"number\" && typeof b === \"number\") return distance1D(a, b)\n\n  if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x)\n    const yDelta = distance1D(a.y, b.y)\n\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2)\n  }\n\n  return 0\n}\n\nconst panEvent = (\n  ev: AnyPointerEvent,\n  handlers: Partial<PanEventHandlers>,\n  threshold: number = 3,\n) => {\n  if (isMultiTouchEvent(ev)) return\n\n  const win = ev.view ?? window\n  const info = { point: getEventPoint(ev) }\n  const { timestamp } = getFrameData()\n  const { onSessionStart, onStart, onMove, onEnd, onSessionEnd } = handlers\n\n  const history: PanEventHistory = [{ ...info.point, timestamp }]\n\n  let startEvent: AnyPointerEvent | null = null\n  let lastEvent: AnyPointerEvent | null = null\n  let lastEventInfo: PointerEventInfo | null = null\n\n  ev.stopPropagation()\n  ev.preventDefault()\n\n  onSessionStart?.(ev, getPanInfo(info, history))\n\n  const updatePoint = () => {\n    if (!(lastEvent && lastEventInfo)) return\n\n    const info = getPanInfo(lastEventInfo, history)\n\n    const isPanStarted = startEvent !== null\n\n    const isDistancePastThreshold =\n      distance(info.offset, { x: 0, y: 0 }) >= threshold\n\n    if (!isPanStarted && !isDistancePastThreshold) return\n\n    const { timestamp } = getFrameData()\n\n    history.push({ ...info.point, timestamp })\n\n    if (!isPanStarted) {\n      onStart?.(lastEvent, info)\n\n      startEvent = lastEvent\n    }\n\n    onMove?.(lastEvent, info)\n  }\n\n  const onPointerMove = (ev: AnyPointerEvent, info: PointerEventInfo) => {\n    lastEvent = ev\n    lastEventInfo = info\n\n    sync.update(updatePoint, true)\n  }\n\n  const onPointerUp = (ev: AnyPointerEvent, info: PointerEventInfo) => {\n    const panInfo = getPanInfo(info, history)\n\n    onSessionEnd?.(ev, panInfo)\n\n    end()\n\n    if (!onEnd || !startEvent) return\n\n    onEnd?.(ev, panInfo)\n  }\n\n  const updateHandlers = (newHandlers: Partial<PanEventHandlers>) => {\n    handlers = newHandlers\n  }\n\n  let removeListeners = pipe(\n    addPointerEvent(win, \"pointermove\", onPointerMove),\n    addPointerEvent(win, \"pointerup\", onPointerUp),\n    addPointerEvent(win, \"pointercancel\", onPointerUp),\n  )\n\n  const end = () => {\n    removeListeners?.()\n\n    cancelSync.update(updatePoint)\n  }\n\n  return {\n    updateHandlers,\n    end,\n  }\n}\n\ntype ReturnPanEvent = ReturnType<typeof panEvent>\n\nexport type UsePanEventProps = {\n  onMove?: PanEventHandler\n  onStart?: PanEventHandler\n  onEnd?: PanEventHandler\n  onSessionStart?: PanEventHandler\n  onSessionEnd?: PanEventHandler\n  threshold?: number\n}\n\nexport const usePanEvent = (\n  ref: RefObject<HTMLElement>,\n  {\n    onMove,\n    onStart,\n    onEnd,\n    onSessionStart,\n    onSessionEnd,\n    threshold,\n  }: UsePanEventProps,\n) => {\n  const hasPanEvents =\n    !!onMove || !!onStart || !!onEnd || !!onSessionStart || !!onSessionEnd\n\n  const panSession = useRef<ReturnPanEvent | null>(null)\n\n  const handlersRef = useLatestRef<Partial<PanEventHandlers>>({\n    onSessionStart,\n    onSessionEnd,\n    onStart,\n    onMove,\n    onEnd: (ev, info) => {\n      panSession.current = null\n\n      onEnd?.(ev, info)\n    },\n  })\n\n  useEffect(() => {\n    panSession.current?.updateHandlers(handlersRef.current)\n  })\n\n  useEffect(() => {\n    const node = ref.current\n\n    if (!node || !hasPanEvents) return\n\n    const onPointerDown = (ev: AnyPointerEvent) => {\n      panSession.current = panEvent(ev, handlersRef.current, threshold)\n    }\n\n    return addPointerEvent(node, \"pointerdown\", onPointerDown)\n  }, [ref, hasPanEvents, handlersRef, threshold])\n\n  useEffect(() => {\n    return () => {\n      panSession.current?.end()\n      panSession.current = null\n    }\n  }, [])\n}\n"],"mappings":"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","names":["info","timestamp","ev","sync"]}