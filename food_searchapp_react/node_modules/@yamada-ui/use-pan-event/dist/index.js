"use client"
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  usePanEvent: () => usePanEvent
});
module.exports = __toCommonJS(src_exports);
var import_use_latest_ref = require("@yamada-ui/use-latest-ref");
var import_utils = require("@yamada-ui/utils");
var import_framesync = __toESM(require("framesync"));
var import_react = require("react");
var subtract = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });
var getPanInfo = (info, history) => ({
  point: info.point,
  delta: subtract(info.point, history[history.length - 1]),
  offset: subtract(info.point, history[0]),
  velocity: getVelocity(history, 0.1)
});
var toMilliseconds = (v) => v * 1e3;
var getVelocity = (history, timeDelta) => {
  if (history.length < 2)
    return { x: 0, y: 0 };
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = history[history.length - 1];
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint)
    return { x: 0, y: 0 };
  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time === 0)
    return { x: 0, y: 0 };
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity)
    currentVelocity.x = 0;
  if (currentVelocity.y === Infinity)
    currentVelocity.y = 0;
  return currentVelocity;
};
var pipe = (...fns) => (v) => fns.reduce((a, b) => b(a), v);
var distance1D = (a, b) => Math.abs(a - b);
var isPoint = (point) => "x" in point && "y" in point;
var distance = (a, b) => {
  if (typeof a === "number" && typeof b === "number")
    return distance1D(a, b);
  if (isPoint(a) && isPoint(b)) {
    const xDelta = distance1D(a.x, b.x);
    const yDelta = distance1D(a.y, b.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }
  return 0;
};
var panEvent = (ev, handlers, threshold = 3) => {
  var _a;
  if ((0, import_utils.isMultiTouchEvent)(ev))
    return;
  const win = (_a = ev.view) != null ? _a : window;
  const info = { point: (0, import_utils.getEventPoint)(ev) };
  const { timestamp } = (0, import_framesync.getFrameData)();
  const { onSessionStart, onStart, onMove, onEnd, onSessionEnd } = handlers;
  const history = [{ ...info.point, timestamp }];
  let startEvent = null;
  let lastEvent = null;
  let lastEventInfo = null;
  ev.stopPropagation();
  ev.preventDefault();
  onSessionStart == null ? void 0 : onSessionStart(ev, getPanInfo(info, history));
  const updatePoint = () => {
    if (!(lastEvent && lastEventInfo))
      return;
    const info2 = getPanInfo(lastEventInfo, history);
    const isPanStarted = startEvent !== null;
    const isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= threshold;
    if (!isPanStarted && !isDistancePastThreshold)
      return;
    const { timestamp: timestamp2 } = (0, import_framesync.getFrameData)();
    history.push({ ...info2.point, timestamp: timestamp2 });
    if (!isPanStarted) {
      onStart == null ? void 0 : onStart(lastEvent, info2);
      startEvent = lastEvent;
    }
    onMove == null ? void 0 : onMove(lastEvent, info2);
  };
  const onPointerMove = (ev2, info2) => {
    lastEvent = ev2;
    lastEventInfo = info2;
    import_framesync.default.update(updatePoint, true);
  };
  const onPointerUp = (ev2, info2) => {
    const panInfo = getPanInfo(info2, history);
    onSessionEnd == null ? void 0 : onSessionEnd(ev2, panInfo);
    end();
    if (!onEnd || !startEvent)
      return;
    onEnd == null ? void 0 : onEnd(ev2, panInfo);
  };
  const updateHandlers = (newHandlers) => {
    handlers = newHandlers;
  };
  let removeListeners = pipe(
    (0, import_utils.addPointerEvent)(win, "pointermove", onPointerMove),
    (0, import_utils.addPointerEvent)(win, "pointerup", onPointerUp),
    (0, import_utils.addPointerEvent)(win, "pointercancel", onPointerUp)
  );
  const end = () => {
    removeListeners == null ? void 0 : removeListeners();
    import_framesync.cancelSync.update(updatePoint);
  };
  return {
    updateHandlers,
    end
  };
};
var usePanEvent = (ref, {
  onMove,
  onStart,
  onEnd,
  onSessionStart,
  onSessionEnd,
  threshold
}) => {
  const hasPanEvents = !!onMove || !!onStart || !!onEnd || !!onSessionStart || !!onSessionEnd;
  const panSession = (0, import_react.useRef)(null);
  const handlersRef = (0, import_use_latest_ref.useLatestRef)({
    onSessionStart,
    onSessionEnd,
    onStart,
    onMove,
    onEnd: (ev, info) => {
      panSession.current = null;
      onEnd == null ? void 0 : onEnd(ev, info);
    }
  });
  (0, import_react.useEffect)(() => {
    var _a;
    (_a = panSession.current) == null ? void 0 : _a.updateHandlers(handlersRef.current);
  });
  (0, import_react.useEffect)(() => {
    const node = ref.current;
    if (!node || !hasPanEvents)
      return;
    const onPointerDown = (ev) => {
      panSession.current = panEvent(ev, handlersRef.current, threshold);
    };
    return (0, import_utils.addPointerEvent)(node, "pointerdown", onPointerDown);
  }, [ref, hasPanEvents, handlersRef, threshold]);
  (0, import_react.useEffect)(() => {
    return () => {
      var _a;
      (_a = panSession.current) == null ? void 0 : _a.end();
      panSession.current = null;
    };
  }, []);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  usePanEvent
});
//# sourceMappingURL=index.js.map