// src/rating-item.tsx
import { ui, forwardRef as forwardRef2 } from "@yamada-ui/core";
import { Icon } from "@yamada-ui/icon";
import { cx as cx2, getValidChildren, isString, runIfFunc as runIfFunc3 } from "@yamada-ui/utils";
import { cloneElement } from "react";

// src/use-rating.tsx
import {
  formControlProperties,
  useFormControlProps
} from "@yamada-ui/form-control";
import { useControllableState } from "@yamada-ui/use-controllable-state";
import { trackFocusVisible } from "@yamada-ui/use-focus-visible";
import {
  clampNumber,
  createContext,
  dataAttr,
  handlerAll,
  mergeRefs,
  pickObject,
  runIfFunc as runIfFunc2
} from "@yamada-ui/utils";
import { useCallback, useEffect, useId, useRef, useState } from "react";

// src/rating-group.tsx
import { forwardRef } from "@yamada-ui/core";
import { Motion } from "@yamada-ui/motion";
import { cx, runIfFunc } from "@yamada-ui/utils";
import { jsx } from "react/jsx-runtime";
var RatingGroup = forwardRef(
  ({ className, value: groupValue, items, color, ...rest }, ref) => {
    const { styles, decimal, groupProps, getGroupProps } = useRatingContext();
    const computedGroupProps = runIfFunc(groupProps, groupValue);
    const css = { ...styles.group };
    return /* @__PURE__ */ jsx(
      Motion,
      {
        className: cx("ui-rating__group", className),
        __css: css,
        ...getGroupProps(
          { value: groupValue, ...computedGroupProps, ...rest },
          ref
        ),
        children: Array(items).fill(0).map((_, index) => {
          const fractionValue = decimal * (groupValue === 1 ? index : index + 1);
          const value = getRoundedValue(
            groupValue - 1 + fractionValue,
            decimal
          );
          return /* @__PURE__ */ jsx(
            RatingItem,
            {
              groupValue,
              value,
              fractionValue,
              color
            },
            `${groupValue}-${fractionValue}`
          );
        })
      }
    );
  }
);

// src/use-rating.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
var getRoundedValue = (value, to) => {
  var _a;
  const rounded = Math.round(value / to) * to;
  const precision = ((_a = `${to}`.split(".")[1]) == null ? void 0 : _a.length) || 0;
  return Number(rounded.toFixed(precision));
};
var [RatingProvider, useRatingContext] = createContext({
  name: "RatingContext",
  errorMessage: `useRatingContext returned is 'undefined'. Seems you forgot to wrap the components in "<Rating />"`
});
var useRating = ({
  name,
  color,
  value: valueProp,
  defaultValue = 0,
  onChange: onChangeProp,
  items = 5,
  fractions = 1,
  highlightSelectedOnly = false,
  onHover,
  groupProps,
  itemProps,
  inputProps,
  emptyIcon,
  filledIcon,
  ...props
}) => {
  let { id, "aria-readonly": _isReadOnly, ...rest } = useFormControlProps(props);
  const { disabled, readOnly } = rest;
  const containerRef = useRef(null);
  const [value, setValue] = useControllableState({
    value: valueProp,
    defaultValue,
    onChange: onChangeProp
  });
  const [hoveredValue, setHoveredValue] = useState(-1);
  const [isOutside, setIsOutside] = useState(true);
  id != null ? id : id = useId();
  name != null ? name : name = `rating-${id}`;
  const formControlProps = pickObject(rest, formControlProperties);
  const resolvedFractions = Math.floor(fractions);
  const resolvedItems = Math.floor(items);
  const decimal = 1 / resolvedFractions;
  const roundedValue = getRoundedValue(value, decimal);
  const resolvedValue = hoveredValue !== -1 ? hoveredValue : roundedValue;
  const getHoveredValue = useCallback(
    (x) => {
      const { left, width } = containerRef.current.getBoundingClientRect();
      const itemWidth = width / resolvedItems;
      const hoveredValue2 = (x - left) / itemWidth;
      const value2 = clampNumber(
        getRoundedValue(hoveredValue2 + decimal / 2, decimal),
        decimal,
        resolvedItems
      );
      return value2;
    },
    [decimal, resolvedItems]
  );
  const onMouseEnter = useCallback(() => {
    if (!disabled && !readOnly)
      setIsOutside(false);
  }, [disabled, readOnly]);
  const onMouseLeave = useCallback(() => {
    if (disabled || readOnly)
      return;
    setHoveredValue(-1);
    setIsOutside(true);
    if (hoveredValue !== -1)
      onHover == null ? void 0 : onHover(-1);
  }, [disabled, hoveredValue, onHover, readOnly, setHoveredValue]);
  const onTouchStart = useCallback(
    (ev) => {
      ev.preventDefault();
      const el = ev.touches[0];
      if (!el)
        return;
      const value2 = getHoveredValue(el.clientX);
      setValue(value2);
    },
    [getHoveredValue, setValue]
  );
  const onTouchEnd = useCallback((ev) => {
    ev.preventDefault();
  }, []);
  const onMouseMove = useCallback(
    (ev) => {
      if (disabled || readOnly)
        return;
      const roundedValue2 = getHoveredValue(ev.clientX);
      setHoveredValue(roundedValue2);
      if (roundedValue2 !== hoveredValue)
        onHover == null ? void 0 : onHover(roundedValue2);
    },
    [disabled, getHoveredValue, hoveredValue, readOnly, onHover]
  );
  const getContainerProps = useCallback(
    (props2 = {}, ref = null) => ({
      ref: mergeRefs(ref, containerRef),
      ...rest,
      ...props2,
      id,
      onMouseEnter: handlerAll(
        onMouseEnter,
        props2.onMouseEnter,
        rest.onMouseEnter
      ),
      onMouseMove: handlerAll(onMouseMove, props2.onMouseMove, rest.onMouseMove),
      onMouseLeave: handlerAll(
        onMouseLeave,
        props2.onMouseLeave,
        rest.onMouseLeave
      ),
      onTouchStart: handlerAll(
        onTouchStart,
        props2.onTouchStart,
        rest.onTouchStart
      ),
      onTouchEnd: handlerAll(onTouchEnd, props2.onTouchEnd, rest.onTouchEnd)
    }),
    [
      onMouseEnter,
      onMouseLeave,
      onMouseMove,
      onTouchEnd,
      onTouchStart,
      id,
      rest
    ]
  );
  const getGroupProps = useCallback(
    ({ value: value2, ...props2 }, ref = null) => {
      const isActive = !readOnly && Math.ceil(hoveredValue) === value2;
      return {
        ref,
        whileTap: !disabled && !readOnly ? { y: -4 } : void 0,
        ...props2,
        tabIndex: -1,
        "data-active": dataAttr(isActive)
      };
    },
    [disabled, hoveredValue, readOnly]
  );
  const children = Array(resolvedItems).fill(0).map((_, index) => {
    const value2 = index + 1;
    return /* @__PURE__ */ jsx2(
      RatingGroup,
      {
        value: value2,
        color: runIfFunc2(color, value2),
        items: index === 0 ? resolvedFractions + 1 : resolvedFractions
      },
      value2
    );
  });
  return {
    getContainerProps,
    getGroupProps,
    id,
    name,
    value,
    roundedValue,
    hoveredValue,
    resolvedValue,
    isOutside,
    setValue,
    setHoveredValue,
    decimal,
    highlightSelectedOnly,
    formControlProps,
    groupProps,
    itemProps,
    inputProps,
    children,
    emptyIcon,
    filledIcon
  };
};
var useRatingItem = ({
  groupValue,
  fractionValue,
  value
}) => {
  const {
    id,
    name,
    formControlProps,
    isOutside,
    highlightSelectedOnly,
    roundedValue,
    resolvedValue,
    setValue,
    setHoveredValue
  } = useRatingContext();
  const { readOnly, disabled } = formControlProps;
  const [isFocused, setFocused] = useState(false);
  const [isFocusVisible, setIsFocusVisible] = useState(false);
  const isActive = value === resolvedValue;
  const isChecked = value === roundedValue;
  const isFilled = highlightSelectedOnly ? value === resolvedValue : value <= resolvedValue;
  const onBlur = useCallback(() => {
    setFocused(false);
    if (isOutside)
      setHoveredValue(-1);
  }, [isOutside, setHoveredValue]);
  const onInputChange = useCallback(
    (ev) => {
      if (readOnly || disabled)
        return;
      const value2 = parseFloat(ev.target.value);
      setHoveredValue(value2);
    },
    [disabled, readOnly, setHoveredValue]
  );
  const onChange = useCallback(
    (value2) => {
      if (readOnly || disabled)
        return;
      setValue(value2);
    },
    [disabled, readOnly, setValue]
  );
  const onMouseDown = useCallback(() => {
    if (readOnly || disabled)
      return;
    onChange(value);
  }, [disabled, onChange, readOnly, value]);
  const onTouchStart = useCallback(() => {
    if (readOnly || disabled)
      return;
    onChange(value);
  }, [disabled, onChange, readOnly, value]);
  const getItemProps = useCallback(
    (props = {}, ref = null) => {
      const zIndex = isActive ? 1 : -1;
      return {
        ref,
        htmlFor: `${id}-${groupValue}-${value}`,
        ...formControlProps,
        ...props,
        zIndex: fractionValue !== 1 ? zIndex : void 0,
        onMouseDown: handlerAll(onMouseDown, props.onMouseDown),
        onTouchStart: handlerAll(onTouchStart, props.onTouchStart),
        "data-active": dataAttr(isActive),
        "data-filled": dataAttr(isFilled),
        "data-focus": dataAttr(isFocused),
        "data-focus-visible": dataAttr(isFocused && isFocusVisible)
      };
    },
    [
      formControlProps,
      fractionValue,
      groupValue,
      id,
      isActive,
      isFilled,
      isFocusVisible,
      isFocused,
      onMouseDown,
      onTouchStart,
      value
    ]
  );
  const getInputProps = useCallback(
    (props = {}, ref = null) => {
      return {
        ref,
        "aria-label": `${value}`,
        ...formControlProps,
        ...props,
        style: {
          border: "0px",
          clip: "rect(0px, 0px, 0px, 0px)",
          height: "1px",
          width: "1px",
          margin: "-1px",
          padding: "0px",
          overflow: "hidden",
          whiteSpace: "nowrap",
          position: "absolute"
        },
        type: "radio",
        id: `${id}-${groupValue}-${value}`,
        name,
        value,
        checked: isChecked,
        onChange: handlerAll(onInputChange, props.onChange),
        onFocus: handlerAll(() => setFocused(true), props.onFocus),
        onBlur: handlerAll(onBlur, props.onBlur),
        onKeyDown: handlerAll(
          (ev) => ev.key === " " ? onChange(value) : void 0,
          props.onKeyDown
        ),
        "data-active": dataAttr(isActive),
        "data-checked": dataAttr(isChecked)
      };
    },
    [
      value,
      formControlProps,
      id,
      groupValue,
      name,
      isChecked,
      onInputChange,
      onBlur,
      isActive,
      onChange
    ]
  );
  useEffect(() => {
    return trackFocusVisible(setIsFocusVisible);
  }, []);
  return {
    isActive,
    isChecked,
    isFilled,
    getItemProps,
    getInputProps
  };
};

// src/rating-item.tsx
import { Fragment, jsx as jsx3, jsxs } from "react/jsx-runtime";
var RatingItem = forwardRef2(
  ({ className, groupValue, value, fractionValue, color, ...rest }, ref) => {
    const {
      styles,
      inputProps,
      emptyIcon = /* @__PURE__ */ jsx3(StarIcon, {}),
      filledIcon = /* @__PURE__ */ jsx3(StarIcon, {}),
      itemProps
    } = useRatingContext();
    const { isActive, isFilled, getInputProps, getItemProps } = useRatingItem({
      value,
      groupValue,
      fractionValue
    });
    const computedItemProps = runIfFunc3(itemProps, value);
    const computedInputProps = runIfFunc3(inputProps, value);
    const customColor = color ? {
      _filled: {
        color: isString(color) ? [color, color] : color
      }
    } : {};
    const css = {
      display: "block",
      lineHeight: "0",
      ...styles.item,
      ...customColor
    };
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx3(ui.input, { ...getInputProps(computedInputProps, ref) }),
      /* @__PURE__ */ jsx3(
        ui.label,
        {
          className: cx2("ui-rating__item", className),
          __css: css,
          ...getItemProps({ ...computedItemProps, ...rest }),
          children: /* @__PURE__ */ jsx3(
            RatingIcon,
            {
              clipPath: fractionValue !== 1 ? `inset(0 ${isActive ? 100 - fractionValue * 100 : 100}% 0 0)` : void 0,
              children: isFilled ? runIfFunc3(filledIcon, groupValue) : runIfFunc3(emptyIcon, groupValue)
            }
          )
        }
      )
    ] });
  }
);
var RatingIcon = ({ className, children, ...rest }) => {
  const { styles } = useRatingContext();
  const validChildren = getValidChildren(children);
  const cloneChildren = validChildren.map(
    (child) => cloneElement(child, {
      focusable: false,
      "aria-hidden": true,
      style: {
        maxWidth: "1em",
        maxHeight: "1em"
      }
    })
  );
  const css = {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    ...styles.icon
  };
  return /* @__PURE__ */ jsx3(
    ui.div,
    {
      className: cx2("ui-rating__item__icon", className),
      __css: css,
      ...rest,
      children: cloneChildren
    }
  );
};
var StarIcon = ({ ...rest }) => {
  return /* @__PURE__ */ jsx3(
    Icon,
    {
      viewBox: "0 0 24 24",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...rest,
      children: /* @__PURE__ */ jsx3("path", { d: "M12 17.75l-6.172 3.245l1.179 -6.873l-5 -4.867l6.9 -1l3.086 -6.253l3.086 6.253l6.9 1l-5 4.867l1.179 6.873z" })
    }
  );
};

export {
  RatingItem,
  RatingGroup,
  getRoundedValue,
  RatingProvider,
  useRatingContext,
  useRating,
  useRatingItem
};
