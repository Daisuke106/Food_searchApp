import * as react_jsx_runtime from 'react/jsx-runtime';
import * as react from 'react';
import { Dispatch, SetStateAction, ReactNode } from 'react';
import * as _yamada_ui_core from '@yamada-ui/core';
import { HTMLUIProps, UIPropGetter, CSSUIObject, CSSUIProps } from '@yamada-ui/core';
import { FormControlOptions } from '@yamada-ui/form-control';
import { RequiredMotionUIPropGetter } from '@yamada-ui/motion';
import { Dict } from '@yamada-ui/utils';
import { RatingGroupProps } from './rating-group.mjs';

type RatingItemProps = HTMLUIProps<"input"> & UseRatingItemProps;
declare const RatingItem: _yamada_ui_core.Component<"input", RatingItemProps>;

declare const getRoundedValue: (value: number, to: number) => number;
type OmittedGroupProps = Omit<RatingGroupProps, "value" | "items" | "children">;
type OmittedItemProps = Omit<RatingItemProps, "value" | "groupValue" | "fractionValue" | "children">;
type OmittedInputProps = Omit<HTMLUIProps<"input">, "value" | "defaultValue" | "checked">;
type GroupProps = OmittedGroupProps | ((value: number) => OmittedGroupProps);
type ItemProps = OmittedItemProps | ((value: number) => OmittedItemProps);
type InputProps = OmittedInputProps | ((value: number) => OmittedInputProps);
type RatingContext = {
    getGroupProps: RequiredMotionUIPropGetter<"div", {
        value: number;
    }>;
    id: string;
    name: string;
    value: number;
    roundedValue: number;
    hoveredValue: number;
    resolvedValue: number;
    isOutside: boolean;
    setValue: Dispatch<SetStateAction<number>>;
    setHoveredValue: Dispatch<SetStateAction<number>>;
    decimal: number;
    highlightSelectedOnly: boolean;
    formControlProps: Dict;
    groupProps: GroupProps | undefined;
    itemProps: ItemProps | undefined;
    inputProps: InputProps | undefined;
    emptyIcon: ReactNode | ((value: number) => ReactNode) | undefined;
    filledIcon: ReactNode | ((value: number) => ReactNode) | undefined;
    styles: Record<string, CSSUIObject>;
};
declare const RatingProvider: react.Provider<RatingContext>;
declare const useRatingContext: () => RatingContext;
type UseRatingOptions = {
    /**
     * The top-level id string that will be applied to the rating.
     * The index of the rating item will be appended to this top-level id.
     */
    id?: string;
    /**
     * The name of the input element.
     */
    name?: string;
    /**
     * The value of the rating.
     */
    value?: number;
    /**
     * The initial value of the rating.
     *
     * @default 0
     */
    defaultValue?: number;
    /**
     * The callback invoked when value state changes.
     */
    onChange?: (value: number) => void;
    /**
     * The callback invoked when hovering over the rating.
     */
    onHover?: (value: number) => void;
    /**
     * Number of controls that should be rendered.
     *
     * @default 5
     */
    items?: number;
    /**
     * Number of fractions each item can be divided into,
     *
     * @default 1
     */
    fractions?: number;
    /**
     * If `true`, only the selected icons will be filled.
     *
     * @default false
     */
    highlightSelectedOnly?: boolean;
    /**
     * The color of the filled icons.
     */
    color?: CSSUIProps["color"] | ((value: number) => CSSUIProps["color"]);
    /**
     * The empty icon for the rating.
     */
    emptyIcon?: ReactNode | ((value: number) => ReactNode);
    /**
     * The filled icon for the rating.
     */
    filledIcon?: ReactNode | ((value: number) => ReactNode);
    /**
     * Props for the rating group.
     */
    groupProps?: GroupProps;
    /**
     * Props for the rating item.
     */
    itemProps?: ItemProps;
    /**
     * Props for the input element.
     */
    inputProps?: InputProps;
};
type UseRatingProps = Omit<HTMLUIProps<"div">, "color" | "id" | "defaultValue" | "onChange"> & UseRatingOptions & FormControlOptions;
declare const useRating: ({ name, color, value: valueProp, defaultValue, onChange: onChangeProp, items, fractions, highlightSelectedOnly, onHover, groupProps, itemProps, inputProps, emptyIcon, filledIcon, ...props }: UseRatingProps) => {
    getContainerProps: UIPropGetter;
    getGroupProps: RequiredMotionUIPropGetter<"div", {
        value: number;
    }>;
    id: string;
    name: string;
    value: number;
    roundedValue: number;
    hoveredValue: number;
    resolvedValue: number;
    isOutside: boolean;
    setValue: Dispatch<SetStateAction<number>>;
    setHoveredValue: Dispatch<SetStateAction<number>>;
    decimal: number;
    highlightSelectedOnly: boolean;
    formControlProps: {
        [x: string]: any;
    };
    groupProps: GroupProps | undefined;
    itemProps: ItemProps | undefined;
    inputProps: InputProps | undefined;
    children: react_jsx_runtime.JSX.Element[];
    emptyIcon: ReactNode | ((value: number) => ReactNode);
    filledIcon: ReactNode | ((value: number) => ReactNode);
};
type UseRatingReturn = ReturnType<typeof useRating>;
type UseRatingItemProps = {
    groupValue: number;
    fractionValue: number;
    value: number;
};
declare const useRatingItem: ({ groupValue, fractionValue, value, }: UseRatingItemProps) => {
    isActive: boolean;
    isChecked: boolean;
    isFilled: boolean;
    getItemProps: UIPropGetter;
    getInputProps: UIPropGetter;
};
type UseRatingItemReturn = ReturnType<typeof useRatingItem>;

export { type RatingItemProps as R, type UseRatingProps as U, RatingItem as a, RatingProvider as b, useRating as c, type UseRatingReturn as d, type UseRatingItemProps as e, useRatingItem as f, getRoundedValue as g, type UseRatingItemReturn as h, useRatingContext as u };
