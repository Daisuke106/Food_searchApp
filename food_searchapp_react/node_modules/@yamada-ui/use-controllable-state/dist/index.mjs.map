{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import {\n  useCallbackRef,\n  runIfFunc,\n  isUndefined,\n  isNull,\n} from \"@yamada-ui/utils\"\nimport type { Dispatch, SetStateAction } from \"react\"\nimport { useState } from \"react\"\n\nexport type UseControllableStateProps<T> = {\n  value?: T\n  defaultValue?: T | (() => T)\n  onChange?: (value: T) => void\n  onUpdate?: (prev: T, next: T) => boolean\n}\n\nexport const useControllableState = <T>({\n  value,\n  ...rest\n}: UseControllableStateProps<T>) => {\n  rest.onUpdate ??= (prev, next) => prev !== next\n\n  const onChange = useCallbackRef(rest.onChange)\n  const onUpdate = useCallbackRef(rest.onUpdate)\n\n  const [defaultValue, setDefaultValue] = useState(rest.defaultValue as T)\n  const controlled = value !== undefined\n  const resolvedValue = controlled ? value : defaultValue\n\n  const setValue = useCallbackRef(\n    (next: SetStateAction<T>) => {\n      const nextValue = runIfFunc(next, resolvedValue)\n\n      if (!onUpdate(resolvedValue, nextValue)) return\n\n      if (!controlled || isUndefined(nextValue) || isNull(nextValue))\n        setDefaultValue(nextValue)\n\n      onChange(nextValue)\n    },\n    [controlled, resolvedValue, onChange, onUpdate],\n  )\n\n  return [resolvedValue, setValue] as [T, Dispatch<SetStateAction<T>>]\n}\n"],"mappings":";;;AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP,SAAS,gBAAgB;AASlB,IAAM,uBAAuB,CAAI;AAAA,EACtC;AAAA,EACA,GAAG;AACL,MAAoC;AAnBpC;AAoBE,aAAK,aAAL,iBAAK,WAAa,CAAC,MAAM,SAAS,SAAS;AAE3C,QAAM,WAAW,eAAe,KAAK,QAAQ;AAC7C,QAAM,WAAW,eAAe,KAAK,QAAQ;AAE7C,QAAM,CAAC,cAAc,eAAe,IAAI,SAAS,KAAK,YAAiB;AACvE,QAAM,aAAa,UAAU;AAC7B,QAAM,gBAAgB,aAAa,QAAQ;AAE3C,QAAM,WAAW;AAAA,IACf,CAAC,SAA4B;AAC3B,YAAM,YAAY,UAAU,MAAM,aAAa;AAE/C,UAAI,CAAC,SAAS,eAAe,SAAS;AAAG;AAEzC,UAAI,CAAC,cAAc,YAAY,SAAS,KAAK,OAAO,SAAS;AAC3D,wBAAgB,SAAS;AAE3B,eAAS,SAAS;AAAA,IACpB;AAAA,IACA,CAAC,YAAY,eAAe,UAAU,QAAQ;AAAA,EAChD;AAEA,SAAO,CAAC,eAAe,QAAQ;AACjC;","names":[]}