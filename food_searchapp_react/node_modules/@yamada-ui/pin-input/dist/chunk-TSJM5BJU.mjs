"use client"

// src/pin-input.tsx
import {
  ui,
  forwardRef,
  useMultiComponentStyle,
  omitThemeProps
} from "@yamada-ui/core";
import {
  formControlProperties,
  useFormControlProps
} from "@yamada-ui/form-control";
import { useControllableState } from "@yamada-ui/use-controllable-state";
import { createDescendant } from "@yamada-ui/use-descendant";
import {
  createContext,
  cx,
  handlerAll,
  mergeRefs,
  pickObject,
  filterUndefined,
  getValidChildren
} from "@yamada-ui/utils";
import { useCallback, useEffect, useId, useMemo, useState } from "react";
import { jsx } from "react/jsx-runtime";
var toArray = (value) => value == null ? void 0 : value.split("");
var validate = (value, type) => {
  const NUMERIC_REGEX = /^[0-9]+$/;
  const ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i;
  const regex = type === "alphanumeric" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX;
  return regex.test(value);
};
var [PinInputProvider, usePinInputContext] = createContext({
  strict: false,
  name: "PinInputContext"
});
var { DescendantsContextProvider, useDescendants, useDescendant } = createDescendant();
var PinInput = forwardRef(
  ({ focusBorderColor, errorBorderColor, ...props }, ref) => {
    const [styles, mergedProps] = useMultiComponentStyle("PinInput", {
      focusBorderColor,
      errorBorderColor,
      ...props
    });
    let {
      id,
      className,
      type = "number",
      placeholder = "\u25CB",
      value,
      defaultValue,
      autoFocus,
      manageFocus = true,
      otp = false,
      mask,
      readOnly,
      "aria-readonly": ariaReadonly,
      onChange: onChangeProp,
      onComplete,
      items = 4,
      children,
      ...rest
    } = useFormControlProps(omitThemeProps(mergedProps));
    const formControlProps = useMemo(
      () => ({
        ...pickObject(rest, formControlProperties),
        readOnly,
        "aria-readonly": ariaReadonly
      }),
      [ariaReadonly, readOnly, rest]
    );
    id != null ? id : id = useId();
    const descendants = useDescendants();
    const [moveFocus, setMoveFocus] = useState(true);
    const [focusedIndex, setFocusedIndex] = useState(-1);
    useEffect(() => {
      if (!autoFocus)
        return;
      const firstValue = descendants.firstValue();
      if (!firstValue)
        return;
      requestAnimationFrame(() => firstValue.node.focus());
    }, [autoFocus, descendants]);
    const [values, setValues] = useControllableState({
      value: toArray(value),
      defaultValue: toArray(defaultValue) || [],
      onChange: (values2) => onChangeProp == null ? void 0 : onChangeProp(values2.join(""))
    });
    const focusNext = useCallback(
      (index) => {
        if (!moveFocus || !manageFocus)
          return;
        const next = descendants.nextValue(index, void 0, false);
        if (!next)
          return;
        requestAnimationFrame(() => next.node.focus());
      },
      [descendants, moveFocus, manageFocus]
    );
    const setValue = useCallback(
      (value2, index, isFocus = true) => {
        var _a;
        let nextValues = [...values];
        nextValues[index] = value2;
        setValues(nextValues);
        nextValues = nextValues.filter(Boolean);
        const isComplete = value2 !== "" && nextValues.length === descendants.count() && nextValues.every((value3) => value3 != null && value3 !== "");
        if (isComplete) {
          onComplete == null ? void 0 : onComplete(nextValues.join(""));
          (_a = descendants.value(index)) == null ? void 0 : _a.node.blur();
        } else if (isFocus) {
          focusNext(index);
        }
      },
      [values, setValues, descendants, onComplete, focusNext]
    );
    const getNextValue = useCallback(
      (value2, eventValue) => {
        let nextValue = eventValue;
        if (!(value2 == null ? void 0 : value2.length))
          return nextValue;
        if (value2[0] === eventValue.charAt(0)) {
          nextValue = eventValue.charAt(1);
        } else if (value2[0] === eventValue.charAt(1)) {
          nextValue = eventValue.charAt(0);
        }
        return nextValue;
      },
      []
    );
    const onChange = useCallback(
      (index) => ({ target }) => {
        var _a;
        const eventValue = target.value;
        const currentValue = values[index];
        const nextValue = getNextValue(currentValue, eventValue);
        if (nextValue === "") {
          setValue("", index);
          return;
        }
        if (eventValue.length > 2) {
          if (!validate(eventValue, type))
            return;
          const nextValue2 = eventValue.split("").filter((_, index2) => index2 < descendants.count());
          setValues(nextValue2);
          if (nextValue2.length === descendants.count()) {
            onComplete == null ? void 0 : onComplete(nextValue2.join(""));
            (_a = descendants.value(index)) == null ? void 0 : _a.node.blur();
          }
        } else {
          if (validate(nextValue, type))
            setValue(nextValue, index);
          setMoveFocus(true);
        }
      },
      [
        descendants,
        getNextValue,
        onComplete,
        setValue,
        setValues,
        type,
        values
      ]
    );
    const onKeyDown = useCallback(
      (index) => ({ key, target }) => {
        var _a;
        if (key !== "Backspace" || !manageFocus)
          return;
        if (target.value === "") {
          const prevInput = descendants.prevValue(index, void 0, false);
          if (!prevInput)
            return;
          setValue("", index - 1, false);
          (_a = prevInput.node) == null ? void 0 : _a.focus();
          setMoveFocus(true);
        } else {
          setMoveFocus(false);
        }
      },
      [descendants, manageFocus, setValue]
    );
    const onFocus = useCallback(
      (index) => () => setFocusedIndex(index),
      []
    );
    const onBlur = useCallback(() => setFocusedIndex(-1), []);
    const getInputProps = useCallback(
      ({
        index,
        ...props2
      }) => ({
        inputMode: type === "number" ? "numeric" : "text",
        type: mask ? "password" : type === "number" ? "tel" : "text",
        ...formControlProps,
        ...filterUndefined(props2),
        id: `${id}-${index}`,
        value: values[index] || "",
        onChange: handlerAll(props2.onChange, onChange(index)),
        onKeyDown: handlerAll(props2.onKeyDown, onKeyDown(index)),
        onFocus: handlerAll(props2.onFocus, onFocus(index)),
        onBlur: handlerAll(props2.onBlur, onBlur),
        autoComplete: otp ? "one-time-code" : "off",
        placeholder: focusedIndex === index && !readOnly && !props2.readOnly ? "" : placeholder
      }),
      [
        type,
        mask,
        formControlProps,
        id,
        values,
        onChange,
        onKeyDown,
        onFocus,
        onBlur,
        otp,
        focusedIndex,
        readOnly,
        placeholder
      ]
    );
    const css = {
      display: "flex",
      alignItems: "center",
      ...styles.container
    };
    let cloneChildren = getValidChildren(children);
    if (!cloneChildren.length)
      for (let i = 0; i < items; i++) {
        cloneChildren.push(/* @__PURE__ */ jsx(PinInputField, {}, i));
      }
    return /* @__PURE__ */ jsx(DescendantsContextProvider, { value: descendants, children: /* @__PURE__ */ jsx(PinInputProvider, { value: { getInputProps, styles }, children: /* @__PURE__ */ jsx(
      ui.div,
      {
        ref,
        className: cx("ui-pin-input", className),
        __css: css,
        ...rest,
        children: cloneChildren
      }
    ) }) });
  }
);
var PinInputField = forwardRef(
  ({ className, ...rest }, ref) => {
    const { getInputProps, styles } = usePinInputContext();
    const { index, register } = useDescendant();
    rest = useFormControlProps(rest);
    const css = { ...styles.field };
    return /* @__PURE__ */ jsx(
      ui.input,
      {
        className: cx("ui-pin-input__field", className),
        ...getInputProps({ ...rest, ref: mergeRefs(register, ref), index }),
        __css: css
      }
    );
  }
);

export {
  PinInput,
  PinInputField
};
//# sourceMappingURL=chunk-TSJM5BJU.mjs.map