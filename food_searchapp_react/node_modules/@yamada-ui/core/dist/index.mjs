"use client"
import "./chunk-C55TBSZC.mjs";
import "./chunk-E56SJDNI.mjs";

// src/config.ts
import { keyframes as emotionKeyframes } from "@emotion/react";
import { StyleSheet } from "@emotion/sheet";
import {
  isNumber,
  getMemoizedObject as get,
  isArray,
  isObject,
  isString,
  createdDom,
  toKebabCase,
  filterUndefined
} from "@yamada-ui/utils";
var styleSheet = createdDom() ? new StyleSheet({ key: "css", container: document.head }) : void 0;
var directions = {
  "to-t": "to top",
  "to-tr": "to top right",
  "to-r": "to right",
  "to-br": "to bottom right",
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-l": "to left",
  "to-tl": "to top left"
};
var transformValues = [
  "rotate(var(--ui-rotate, 0))",
  "scaleX(var(--ui-scale-x, 1))",
  "scaleY(var(--ui-scale-y, 1))",
  "skewX(var(--ui-skew-x, 0))",
  "skewY(var(--ui-skew-y, 0))"
];
var directionValues = new Set(Object.values(directions));
var globalValues = /* @__PURE__ */ new Set([
  "none",
  "-moz-initial",
  "inherit",
  "initial",
  "revert",
  "unset"
]);
var isCSSFunction = (value) => isString(value) && value.includes("(") && value.includes(")");
var isCSSVar = (value) => /^var\(--.+\)$/.test(value);
var analyzeCSSValue = (value) => {
  let n = parseFloat(value.toString());
  const unit = value.toString().replace(String(n), "");
  return { isUnitless: !unit, value, unit };
};
var tokenToCSSVar = (token, value) => (theme) => {
  const match = isString(value) ? value.match(/fallback\(([^,)]+),?\s*([^]+)?\)/) : null;
  const [, resolvedValue, fallbackValue] = match != null ? match : [];
  if (resolvedValue)
    value = resolvedValue;
  const resolvedToken = `${token}.${value}`;
  if (isObject(theme.__cssMap) && resolvedToken in theme.__cssMap) {
    return theme.__cssMap[resolvedToken].ref;
  } else {
    return fallbackValue != null ? fallbackValue : value;
  }
};
var generateGradient = (value, theme) => {
  var _a;
  if (value == null || globalValues.has(value))
    return value;
  const prevent = isCSSFunction(value);
  if (!prevent)
    return `url('${value}')`;
  const regex = /(^[a-z-A-Z]+)\((.*)\)/g;
  const [, _type, _values] = (_a = regex.exec(value)) != null ? _a : [];
  if (!_type || !_values)
    return value;
  const type = _type.includes("-gradient") ? _type : `${_type}-gradient`;
  const [maybeDirection, ...colors] = _values.split(",").map((value2) => value2.trim()).filter(Boolean);
  if (!colors.length)
    return value;
  const direction = maybeDirection in directions ? directions[maybeDirection] : maybeDirection;
  colors.unshift(direction);
  const values = colors.map((_color) => {
    if (directionValues.has(_color))
      return _color;
    const i = _color.indexOf(" ");
    let [color, _ratio] = i !== -1 ? [_color.slice(0, i), _color.slice(i + 1)] : [_color];
    const ratio = isCSSFunction(_ratio) ? _ratio : _ratio && _ratio.split(" ");
    const token = `colors.${color}`;
    color = token in theme.__cssMap ? theme.__cssMap[token].ref : color;
    if (ratio) {
      return [color, ...isArray(ratio) ? ratio : [ratio]].join(" ");
    } else {
      return color;
    }
  });
  return `${type}(${values.join(", ")})`;
};
var transformAnimationValue = (value) => Object.entries(value).reduce((prev, [key, value2]) => {
  if (key === "duration") {
    prev["animationDuration"] = value2;
  } else if (key === "timingFunction") {
    prev["animationTimingFunction"] = value2;
  } else {
    prev[key] = value2;
  }
  return prev;
}, {});
var generateAnimation = (value, theme, css2) => {
  if (value == null || globalValues.has(value))
    return value;
  if (isObject(value)) {
    const {
      keyframes: keyframes2,
      animationDuration = "0s",
      animationTimingFunction = "ease",
      delay = "0s",
      iterationCount = "1",
      direction = "normal",
      fillMode = "none",
      playState = "running"
    } = css2(transformAnimationValue(value))(theme);
    const { name, styles: styles2 } = emotionKeyframes(keyframes2);
    styleSheet == null ? void 0 : styleSheet.insert(styles2);
    return `${name} ${animationDuration} ${animationTimingFunction} ${delay} ${iterationCount} ${direction} ${fillMode} ${playState}`;
  } else if (value.includes(",")) {
    value = value.split(",").map((value2) => {
      value2 = value2.trim();
      value2 = tokenToCSSVar("animations", value2)(theme);
      return value2;
    }).join(",");
    return value;
  } else {
    value = tokenToCSSVar("animations", value)(theme);
    return value;
  }
};
var generateTransform = (value) => {
  if (value === "auto")
    return [
      "translateX(var(--ui-translate-x, 0))",
      "translateY(var(--ui-translate-y, 0))",
      ...transformValues
    ].join(" ");
  if (value === "auto-3d")
    return [
      "translate3d(var(--ui-translate-x, 0), var(--ui-translate-y, 0), 0)",
      ...transformValues
    ].join(" ");
  return value;
};
var generateFilter = (type = "filter") => (value) => {
  if (value !== "auto")
    return value;
  if (type === "filter") {
    return [
      "var(--ui-blur, /*!*/ /*!*/)",
      "var(--ui-brightness, /*!*/ /*!*/)",
      "var(--ui-contrast, /*!*/ /*!*/)",
      "var(--ui-drop-shadow, /*!*/ /*!*/)",
      "var(--ui-grayscale, /*!*/ /*!*/)",
      "var(--ui-hue-rotate, /*!*/ /*!*/)",
      "var(--ui-invert, /*!*/ /*!*/)",
      "var(--ui-opacity, /*!*/ /*!*/)",
      "var(--ui-saturate, /*!*/ /*!*/)",
      "var(--ui-sepia, /*!*/ /*!*/)"
    ].join(" ");
  } else {
    return [
      "var(--ui-backdrop-blur, /*!*/ /*!*/)",
      "var(--ui-backdrop-brightness, /*!*/ /*!*/)",
      "var(--ui-backdrop-contrast, /*!*/ /*!*/)",
      "var(--ui-backdrop-drop-shadow, /*!*/ /*!*/)",
      "var(--ui-backdrop-grayscale, /*!*/ /*!*/)",
      "var(--ui-backdrop-hue-rotate, /*!*/ /*!*/)",
      "var(--ui-backdrop-invert, /*!*/ /*!*/)",
      "var(--ui-backdrop-opacity, /*!*/ /*!*/)",
      "var(--ui-backdrop-saturate, /*!*/ /*!*/)",
      "var(--ui-backdrop-sepia, /*!*/ /*!*/)"
    ].join(" ");
  }
};
var generateAtRule = (identifier) => (values, theme) => values.reduce(
  (prev, {
    type,
    name,
    query,
    css: css2,
    w,
    width,
    minW,
    minWidth,
    maxW,
    maxWidth,
    h,
    height,
    minH,
    minHeight,
    maxH,
    maxHeight,
    ...rest
  }) => {
    var _a;
    width != null ? width : width = w;
    minWidth != null ? minWidth : minWidth = minW;
    maxWidth != null ? maxWidth : maxWidth = maxW;
    height != null ? height : height = h;
    minHeight != null ? minHeight : minHeight = minH;
    maxHeight != null ? maxHeight : maxHeight = maxH;
    if (!query) {
      const resolvedRest = filterUndefined({
        width,
        minWidth,
        maxWidth,
        height,
        minHeight,
        maxHeight,
        ...rest
      });
      query = Object.entries(resolvedRest).map(([key, value]) => {
        value = tokenToCSSVar("sizes", value)(theme);
        return `(${toKebabCase(key)}: ${value})`;
      }).join(" and ");
    }
    const condition = `@${identifier} ${(_a = type != null ? type : name) != null ? _a : ""} ${query}`;
    prev[condition] = css2;
    return prev;
  },
  {}
);
var mode = (light, dark) => (colorMode = "light") => colorMode === "light" ? light : dark;
var keyframes = (...arg) => emotionKeyframes(...arg);
var transforms = {
  var: (values, theme) => values.reduce((prev, { __prefix, name, token, value }) => {
    var _a, _b;
    const prefix = (_b = __prefix != null ? __prefix : (_a = theme.__config.var) == null ? void 0 : _a.prefix) != null ? _b : "ui";
    name = `--${prefix}-${name}`;
    if (isObject(value)) {
      value = Object.entries(value).reduce((prev2, [key, value2]) => {
        prev2[key] = tokenToCSSVar(token, value2)(theme);
        return prev2;
      }, {});
    } else if (isArray(value)) {
      value = value.map((value2) => tokenToCSSVar(token, value2)(theme));
    } else {
      value = tokenToCSSVar(token, value)(theme);
    }
    prev[name] = value;
    return prev;
  }, {}),
  token: (token, transform, compose) => (value, theme, css2) => {
    var _a;
    value = tokenToCSSVar(token, value)(theme);
    let result = (_a = transform == null ? void 0 : transform(value, theme, css2)) != null ? _a : value;
    if (compose)
      result = compose(result, theme, css2);
    return result;
  },
  styles: (prefix) => (value, theme, _css, prev = {}) => {
    const resolvedCSS = {};
    const style = get(
      theme,
      prefix ? `styles.${prefix}.${value}` : `styles.${value}`,
      {}
    );
    for (const prop in style) {
      const done = prop in prev && prev[prop] != null;
      if (!done)
        resolvedCSS[prop] = style[prop];
    }
    return resolvedCSS;
  },
  px: (value) => {
    if (value == null)
      return value;
    const { isUnitless } = analyzeCSSValue(value);
    return isUnitless || isNumber(value) ? `${value}px` : value;
  },
  deg: (value) => {
    if (isCSSVar(value) || value == null)
      return value;
    const isUnitless = typeof value === "string" && !value.endsWith("deg");
    return isUnitless || isNumber(value) ? `${value}deg` : value;
  },
  fraction: (transform) => (value, ...rest) => {
    if (isNumber(value) && value <= 1) {
      value = `${value * 100}%`;
    }
    if (transform)
      value = transform(value, ...rest);
    return value;
  },
  isTruncated: (value) => {
    if (value === true) {
      return {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      };
    }
  },
  bgClip: (value) => {
    if (value === "text") {
      return { color: "transparent", backgroundClip: "text" };
    } else {
      return { backgroundClip: value };
    }
  },
  function: (func, transform) => (value, ...rest) => {
    if (transform)
      value = transform(value, ...rest);
    return `${func}(${value})`;
  },
  gradient: generateGradient,
  animation: generateAnimation,
  transform: generateTransform,
  filter: generateFilter,
  media: generateAtRule("media"),
  container: generateAtRule("container"),
  supports: generateAtRule("supports")
};

// src/components/forward-ref.ts
import * as React from "react";
var forwardRef2 = (component) => {
  return React.forwardRef(component);
};

// src/components/use-component-style.tsx
import {
  getMemoizedObject as get3,
  runIfFunc as runIfFunc4,
  merge as merge5,
  filterUndefined as filterUndefined2,
  omitObject as omitObject2,
  isArray as isArray4,
  isObject as isObject4,
  keysFormObject as keysFormObject2
} from "@yamada-ui/utils";
import { useRef } from "react";
import isEqual from "react-fast-compare";

// src/css/breakpoint.ts
import { keysFormObject, getPx } from "@yamada-ui/utils";
var createQuery = (min, max) => {
  const query = ["@media screen"];
  if (min)
    query.push("and", `(min-width: ${min}px)`);
  if (max)
    query.push("and", `(max-width: ${max}px)`);
  return query.length > 1 ? query.join(" ") : void 0;
};
var createQueries = (breakpoints, direction) => {
  const isDown = direction === "down";
  return Object.entries(breakpoints).map(([breakpoint, width], i, entry) => {
    var _a;
    const [, relatedWidth] = (_a = entry[i + 1]) != null ? _a : [];
    let minW = isDown ? relatedWidth : width;
    let maxW = isDown ? width : relatedWidth;
    if (breakpoint === "base") {
      if (isDown) {
        maxW = void 0;
      } else {
        minW = void 0;
      }
    }
    if (isDown) {
      if (minW)
        minW += 1;
    } else {
      if (maxW)
        maxW -= 1;
    }
    const maxWQuery = createQuery(void 0, maxW);
    const minWQuery = createQuery(minW);
    const minMaxQuery = createQuery(minW, maxW);
    const query = direction === "down" ? maxWQuery : minWQuery;
    return {
      breakpoint,
      minW,
      maxW,
      query,
      maxWQuery,
      minWQuery,
      minMaxQuery
    };
  });
};
var transformBreakpoints = (breakpoints, direction) => {
  return Object.fromEntries(
    Object.entries(breakpoints).map(([name, value]) => [name, getPx(value)]).sort((a, b) => {
      if (direction === "down") {
        return b[1] - a[1];
      } else {
        return a[1] - b[1];
      }
    })
  );
};
var analyzeBreakpoints = (breakpoints, direction = "down") => {
  if (!breakpoints)
    return;
  breakpoints.base = direction === "down" ? "9999px" : "0px";
  breakpoints = transformBreakpoints(breakpoints, direction);
  const keys = keysFormObject(breakpoints);
  const queries2 = createQueries(breakpoints, direction);
  const isResponsive = (obj) => {
    const providedKeys = Object.keys(obj);
    return providedKeys.length > 0 && providedKeys.every((key) => keys.includes(key));
  };
  return {
    keys,
    isResponsive,
    queries: queries2
  };
};
var getMinMaxQuery = (queries2, direction, pickKey = []) => {
  const omitQueries = queries2.filter(
    ({ breakpoint }) => breakpoint !== "base" && pickKey.includes(breakpoint)
  );
  const minQuery = omitQueries.sort((a, b) => {
    var _a, _b;
    return ((_a = a.minW) != null ? _a : 0) - ((_b = b.minW) != null ? _b : 0);
  })[0];
  const maxQuery = omitQueries.sort((a, b) => {
    var _a, _b;
    return ((_a = b.maxW) != null ? _a : 0) - ((_b = a.maxW) != null ? _b : 0);
  })[0];
  if (direction === "down") {
    return { minQuery, maxQuery };
  } else {
    return { minQuery, maxQuery };
  }
};

// src/css/var.ts
import { escape, merge as merge2, calc, isArray as isArray3, isUndefined } from "@yamada-ui/utils";

// src/pseudos.ts
var pseudos = {
  /**
   * The CSS `:hover` pseudo-class.
   */
  _hover: "&:hover, &[data-hover]",
  /**
   * The CSS `:hover` pseudo-class.
   */
  _nativeHover: "&:hover",
  /**
   * The CSS `:active` pseudo-class.
   */
  _active: "&:active, &[data-active]",
  /**
   * The CSS `:active` pseudo-class.
   */
  _nativeActive: "&:active",
  /**
   * The CSS `:target` pseudo-class.
   */
  _target: "&:target, &[data-target]",
  /**
   * The CSS `:not(:target)` pseudo-class.
   */
  _notTarget: "&:not(:target)",
  /**
   * The CSS `:target` pseudo-class.
   */
  _nativeTarget: "&:target",
  /**
   * The CSS `:focus` pseudo-class.
   */
  _focus: "&:focus, &[data-focus]",
  /**
   * The CSS `:focus` pseudo-class.
   */
  _nativeFocus: "&:focus",
  /**
   * The CSS `:focus-visible` pseudo-class.
   */
  _focusVisible: "&:focus-visible, &[data-focus-visible]",
  /**
   * The CSS `:focus-visible` pseudo-class.
   */
  _nativeFocusVisible: "&:focus-visible",
  /**
   * The CSS `:focus-within` pseudo-class.
   */
  _focusWithin: "&:focus-within, &[data-focus-within]",
  /**
   * The CSS `:focus-within` pseudo-class.
   */
  _nativeFocusWithin: "&:focus-within",
  /**
   * The CSS `:disabled` pseudo-class.
   */
  _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
  /**
   * The CSS `:read-only` pseudo-class.
   */
  _readOnly: "&[readonly], &[aria-readonly=true], &[data-readonly]",
  /**
   * The CSS `:indeterminate` pseudo-class.
   */
  _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
  /**
   * The CSS `::before` pseudo-element.
   */
  _before: "&::before",
  /**
   * The CSS `::after` pseudo-element.
   */
  _after: "&::after",
  /**
   * The CSS `::marker` pseudo-element.
   */
  _marker: "&::marker",
  /**
   * The CSS `::first-letter` pseudo-element.
   */
  _firstLetter: "&::first-letter",
  /**
   * The CSS `::first-line` pseudo-element.
   */
  _firstLine: "&::first-line",
  /**
   * The CSS `:empty` pseudo-class.
   */
  _empty: "&:empty",
  /**
   * Styles to apply when the ARIA attribute `aria-expanded` is `true`.
   */
  _expanded: "&[aria-expanded=true], &[data-expanded]",
  /**
   * The CSS `:checked` pseudo-class.
   */
  _checked: "&:checked, &[data-checked], &[aria-checked=true]",
  /**
   * The CSS `:invalid` pseudo-class.
   */
  _invalid: "&[data-invalid], &[aria-invalid=true]",
  /**
   * The CSS `:valid` pseudo-class.
   */
  _valid: "&:valid, &[data-valid], &[data-state=valid]",
  /**
   * Styles to apply when the ARIA attribute `aria-selected` is `true`.
   */
  _selected: "&[aria-selected=true], &[data-selected]",
  /**
   * The CSS `[hidden=true]` pseudo-class.
   */
  _hidden: "&[hidden], &[data-hidden]",
  /**
   * The CSS `:visited` pseudo-class.
   */
  _visited: "&:visited",
  /**
   * The CSS `::placeholder` pseudo-element.
   */
  _placeholder: "&::placeholder, &[data-placeholder]",
  /**
   * The CSS `:placeholder-shown` pseudo-class.
   */
  _placeholderShown: "&:placeholder-shown",
  /**
   * The CSS `:fullscreen` pseudo-class.
   */
  _fullScreen: "&:fullscreen",
  /**
   * The CSS `::selection` pseudo-element.
   */
  _selection: "&::selection",
  /**
   * The CSS `:nth-of-type(even)` pseudo-class.
   */
  _even: "&:nth-of-type(even)",
  /**
   * The CSS `:nth-of-type(odd)` pseudo-class.
   */
  _odd: "&:nth-of-type(odd)",
  /**
   * The CSS `:first-of-type` pseudo-class.
   */
  _first: "&:first-of-type",
  /**
   * The CSS `:last-of-type` pseudo-class.
   */
  _last: "&:last-of-type",
  /**
   * The CSS `:not(:first-of-type)` pseudo-class.
   */
  _notFirst: "&:not(:first-of-type)",
  /**
   * The CSS `:not(:last-of-type)` pseudo-class.
   */
  _notLast: "&:not(:last-of-type)",
  /**
   * The CSS `:-webkit-autofill` pseudo-class.
   */
  _autofill: "&:-webkit-autofill",
  _filled: "&[data-filled]",
  _start: "&[data-start]",
  _end: "&[data-end]",
  _outside: "&:where([data-outside])",
  _between: "&[data-between]",
  _weekend: "&:where([data-weekend])",
  _holiday: "&[data-holiday]",
  _today: "&[data-today]",
  _accept: "&[data-accept]",
  _reject: "&[data-reject]",
  _idle: "&[data-idle]",
  _loading: "&[data-loading], &[aria-busy=true]",
  _loaded: "&[data-loaded]",
  _ripple: "& .ui-ripple",
  /**
   * The CSS `:vertical` pseudo-class.
   */
  _vertical: "&:vertical, &[data-orientation=vertical]",
  /**
   * The CSS `:horizontal` pseudo-class.
   */
  _horizontal: "&:horizontal, &[data-orientation=horizontal]",
  /**
   * The CSS `::-webkit-scrollbar` pseudo-element.
   */
  _scrollbar: "&::-webkit-scrollbar",
  /**
   * The CSS `::-webkit-scrollbar-track` pseudo-element.
   */
  _scrollbarTrack: "&::-webkit-scrollbar-track",
  /**
   * The CSS `::-webkit-scrollbar-track-piece` pseudo-element.
   */
  _scrollbarTrackPiece: "&::-webkit-scrollbar-track-piece",
  /**
   * The CSS `::-webkit-scrollbar-thumb` pseudo-element.
   */
  _scrollbarThumb: "&::-webkit-scrollbar-thumb",
  /**
   * The CSS `::-webkit-scrollbar-button` pseudo-element.
   */
  _scrollbarButton: "&::-webkit-scrollbar-button",
  /**
   * The CSS `::-webkit-scrollbar-corner` pseudo-element.
   */
  _scrollbarCorner: "&::-webkit-scrollbar-corner",
  /**
   * The CSS `@media (prefers-color-scheme: dark)` media feature.
   */
  _mediaDark: "@media (prefers-color-scheme: dark)",
  /**
   * The CSS `@media (prefers-reduced-motion: reduce)` media feature.
   */
  _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
  /**
   * Styles for when `data-mode` is applied to any parent of
   * this component or element.
   */
  _dark: ".ui-dark &:not([data-mode]), [data-mode=dark] &:not([data-mode]), &[data-mode=dark]",
  /**
   * Styles for when `data-mode` is applied to any parent of
   * this component or element.
   */
  _light: ".ui-light &:not([data-mode]), [data-mode=light] &:not([data-mode]), &[data-mode=light]"
};
var pseudosProperties = Object.keys(
  pseudos
);

// src/css/css.ts
import { isArray as isArray2, isObject as isObject2, merge, runIfFunc } from "@yamada-ui/utils";

// src/styles.ts
var standardStyles = {
  accentColor: {
    properties: "accentColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  alignContent: true,
  alignItems: true,
  alignSelf: true,
  alignTracks: true,
  all: true,
  animation: {
    properties: "animation",
    token: "animations",
    transform: transforms.token("animations", transforms.animation)
  },
  animationComposition: true,
  animationDelay: true,
  animationDirection: true,
  animationDuration: {
    properties: "animationDuration",
    token: "transitions.duration",
    transform: transforms.token("transitions.duration")
  },
  animationFillMode: true,
  animationIterationCount: true,
  animationName: true,
  animationPlayState: true,
  animationRange: true,
  animationRangeEnd: true,
  animationRangeStart: true,
  animationTimeline: true,
  animationTimingFunction: {
    properties: "animationTimingFunction",
    token: "transitions.easing",
    transform: transforms.token("transitions.easing")
  },
  appearance: true,
  aspectRatio: true,
  backfaceVisibility: {
    properties: "backfaceVisibility",
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  background: {
    properties: "background",
    token: "colors",
    transform: transforms.token("colors")
  },
  backgroundAttachment: true,
  backgroundBlendMode: true,
  backgroundClip: {
    properties: "backgroundClip",
    transform: transforms.bgClip
  },
  backgroundColor: {
    properties: "backgroundColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  backgroundImage: {
    properties: "backgroundImage",
    token: "gradients",
    transform: transforms.token("gradients", transforms.gradient)
  },
  backgroundOrigin: true,
  backgroundPosition: true,
  backgroundPositionX: true,
  backgroundPositionY: true,
  backgroundRepeat: true,
  backgroundSize: true,
  blockSize: {
    properties: "blockSize",
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  border: {
    properties: "border",
    token: "borders",
    transform: transforms.token("borders", transforms.px)
  },
  borderBlock: {
    properties: "borderBlock",
    token: "borders",
    transform: transforms.token("borders", transforms.px)
  },
  borderBlockColor: {
    properties: "borderBlockColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  borderBlockEnd: {
    properties: "borderBlockEnd",
    token: "borders",
    transform: transforms.token("borders", transforms.px)
  },
  borderBlockEndColor: {
    properties: "borderBlockEndColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  borderBlockEndStyle: true,
  borderBlockEndWidth: {
    properties: "borderBlockEndWidth",
    transform: transforms.px
  },
  borderBlockStart: {
    properties: "borderBlockStart",
    token: "borders",
    transform: transforms.token("borders", transforms.px)
  },
  borderBlockStartColor: {
    properties: "borderBlockStartColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  borderBlockStartStyle: true,
  borderBlockStartWidth: {
    properties: "borderBlockStartWidth",
    transform: transforms.px
  },
  borderBlockStyle: true,
  borderBlockWidth: {
    properties: "borderBlockWidth",
    transform: transforms.px
  },
  borderBottom: {
    properties: "borderBottom",
    token: "borders",
    transform: transforms.token("borders", transforms.px)
  },
  borderBottomColor: {
    properties: "borderBottomColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  borderBottomLeftRadius: {
    properties: "borderBottomLeftRadius",
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderBottomRightRadius: {
    properties: "borderBottomRightRadius",
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderBottomStyle: true,
  borderBottomWidth: {
    properties: "borderBottomWidth",
    transform: transforms.px
  },
  borderCollapse: true,
  borderColor: {
    properties: "borderColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  borderEndEndRadius: {
    properties: "borderEndEndRadius",
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderEndStartRadius: {
    properties: "borderEndStartRadius",
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderImage: {
    properties: "borderImage",
    token: "borders",
    transform: transforms.token("borders", transforms.px)
  },
  borderImageOutset: true,
  borderImageRepeat: true,
  borderImageSlice: true,
  borderImageSource: true,
  borderImageWidth: {
    properties: "borderImageWidth",
    transform: transforms.px
  },
  borderInline: {
    properties: "borderInline",
    token: "borders",
    transform: transforms.token("borders", transforms.px)
  },
  borderInlineColor: {
    properties: "borderInlineColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  borderInlineEnd: {
    properties: "borderInlineEnd",
    token: "borders",
    transform: transforms.token("borders", transforms.px)
  },
  borderInlineEndColor: {
    properties: "borderInlineEndColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  borderInlineEndStyle: true,
  borderInlineEndWidth: {
    properties: "borderInlineEndWidth",
    transform: transforms.px
  },
  borderInlineStart: {
    properties: "borderInlineStart",
    token: "borders",
    transform: transforms.token("borders", transforms.px)
  },
  borderInlineStartColor: {
    properties: "borderInlineStartColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  borderInlineStartStyle: true,
  borderInlineStartWidth: {
    properties: "borderInlineStartWidth",
    transform: transforms.px
  },
  borderInlineStyle: true,
  borderInlineWidth: {
    properties: "borderInlineWidth",
    transform: transforms.px
  },
  borderLeft: {
    properties: "borderLeft",
    token: "borders",
    transform: transforms.token("borders", transforms.px)
  },
  borderLeftColor: {
    properties: "borderLeftColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  borderLeftStyle: true,
  borderLeftWidth: { properties: "borderLeftWidth", transform: transforms.px },
  borderRadius: {
    properties: "borderRadius",
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderRight: {
    properties: "borderRight",
    token: "borders",
    transform: transforms.token("borders", transforms.px)
  },
  borderRightColor: {
    properties: "borderRightColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  borderRightStyle: true,
  borderRightWidth: {
    properties: "borderRightWidth",
    transform: transforms.px
  },
  borderSpacing: true,
  borderStartEndRadius: {
    properties: "borderStartEndRadius",
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderStartStartRadius: {
    properties: "borderStartStartRadius",
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderStyle: true,
  borderTop: {
    properties: "borderTop",
    token: "borders",
    transform: transforms.token("borders", transforms.px)
  },
  borderTopColor: {
    properties: "borderTopColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  borderTopLeftRadius: {
    properties: "borderTopLeftRadius",
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderTopRightRadius: {
    properties: "borderTopRightRadius",
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderTopStyle: true,
  borderTopWidth: { properties: "borderTopWidth", transform: transforms.px },
  borderWidth: { properties: "borderWidth", transform: transforms.px },
  bottom: {
    properties: "bottom",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  boxAlign: true,
  boxDecorationBreak: true,
  boxDirection: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxLines: true,
  boxOrdinalGroup: true,
  boxOrient: true,
  boxPack: true,
  boxShadow: {
    properties: "boxShadow",
    token: "shadows",
    transform: transforms.token("shadows")
  },
  boxSizing: true,
  breakAfter: true,
  breakBefore: true,
  breakInside: true,
  captionSide: true,
  caretColor: {
    properties: "caretColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  clear: true,
  clip: true,
  clipPath: true,
  color: {
    properties: "color",
    token: "colors",
    transform: transforms.token("colors")
  },
  colorInterpolation: true,
  columnCount: true,
  columnFill: true,
  columnGap: {
    properties: "columnGap",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  columnRule: { properties: "columnRule", transform: transforms.px },
  columnRuleColor: {
    properties: "columnRuleColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  columnRuleStyle: true,
  columnRuleWidth: { properties: "columnRuleWidth", transform: transforms.px },
  columnSpan: true,
  columnWidth: { properties: "columnWidth", transform: transforms.px },
  columns: true,
  contain: true,
  containIntrinsicBlockSize: true,
  containIntrinsicHeight: true,
  containIntrinsicInlineSize: true,
  containIntrinsicSize: true,
  containIntrinsicWidth: {
    properties: "containIntrinsicWidth",
    transform: transforms.px
  },
  container: true,
  containerName: true,
  containerType: true,
  content: true,
  contentVisibility: true,
  counterIncrement: true,
  counterReset: true,
  counterSet: true,
  cursor: true,
  direction: true,
  display: true,
  emptyCells: true,
  flex: true,
  flexBasis: {
    properties: "flexBasis",
    token: "sizes",
    transform: transforms.token("sizes", transforms.px)
  },
  flexDirection: true,
  flexFlow: true,
  flexGrow: true,
  flexShrink: true,
  flexWrap: true,
  float: true,
  font: true,
  fontFamily: {
    properties: "fontFamily",
    token: "fonts",
    transform: transforms.token("fonts")
  },
  fontFeatureSettings: true,
  fontKerning: true,
  fontLanguageOverride: true,
  fontOpticalSizing: true,
  fontPalette: true,
  fontSize: {
    properties: "fontSize",
    token: "fontSizes",
    transform: transforms.token("fontSizes", transforms.px)
  },
  fontSizeAdjust: true,
  fontSmooth: true,
  fontStretch: true,
  fontStyle: true,
  fontSynthesis: true,
  fontSynthesisPosition: true,
  fontSynthesisSmallCaps: true,
  fontSynthesisStyle: true,
  fontSynthesisWeight: true,
  fontVariant: true,
  fontVariantAlternates: true,
  fontVariantCaps: true,
  fontVariantEastAsian: true,
  fontVariantEmoji: true,
  fontVariantLigatures: true,
  fontVariantNumeric: true,
  fontVariantPosition: true,
  fontVariationSettings: true,
  fontWeight: {
    properties: "fontWeight",
    token: "fontWeights",
    transform: transforms.token("fontWeights")
  },
  forcedColorAdjust: true,
  gap: {
    properties: "gap",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  grid: true,
  gridArea: true,
  gridAutoColumns: true,
  gridAutoFlow: true,
  gridAutoRows: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnStart: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowStart: true,
  gridTemplate: true,
  gridTemplateAreas: true,
  gridTemplateColumns: true,
  gridTemplateRows: true,
  hangingPunctuation: true,
  height: {
    properties: "height",
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  hyphenateCharacter: true,
  hyphenateLimitChars: true,
  hyphens: true,
  imageOrientation: true,
  imageRendering: true,
  imageResolution: true,
  initialLetter: true,
  inlineSize: {
    properties: "inlineSize",
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  inset: {
    properties: "inset",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  insetBlock: {
    properties: "insetBlock",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  insetBlockEnd: {
    properties: "insetBlockEnd",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  insetBlockStart: {
    properties: "insetBlockStart",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  insetInline: {
    properties: "insetInline",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  insetInlineEnd: {
    properties: "insetInlineEnd",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  insetInlineStart: {
    properties: "insetInlineStart",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  isolation: true,
  justifyContent: true,
  justifyItems: true,
  justifySelf: true,
  justifyTracks: true,
  left: {
    properties: "left",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  letterSpacing: {
    properties: "letterSpacing",
    token: "letterSpacings",
    transform: transforms.token("letterSpacings")
  },
  lineBreak: true,
  lineHeight: {
    properties: "lineHeight",
    token: "lineHeights",
    transform: transforms.token("lineHeights")
  },
  lineHeightStep: true,
  listStyle: true,
  listStyleImage: true,
  listStylePosition: true,
  listStyleType: true,
  margin: {
    properties: "margin",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  marginBlock: {
    properties: "marginBlock",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  marginBlockEnd: {
    properties: "marginBlockEnd",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  marginBlockStart: {
    properties: "marginBlockStart",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  marginBottom: {
    properties: "marginBottom",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  marginInline: {
    properties: "marginInline",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  marginInlineEnd: {
    properties: "marginInlineEnd",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  marginInlineStart: {
    properties: "marginInlineStart",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  marginLeft: {
    properties: "marginLeft",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  marginRight: {
    properties: "marginRight",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  marginTop: {
    properties: "marginTop",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  marginTrim: true,
  mask: true,
  maskBorder: true,
  maskBorderMode: true,
  maskBorderOutset: true,
  maskBorderRepeat: true,
  maskBorderSlice: true,
  maskBorderSource: true,
  maskBorderWidth: { properties: "maskBorderWidth", transform: transforms.px },
  maskClip: true,
  maskComposite: true,
  maskImage: true,
  maskMode: true,
  maskOrigin: true,
  maskPosition: true,
  maskRepeat: true,
  maskSize: true,
  maskType: true,
  masonryAutoFlow: true,
  mathDepth: true,
  mathShift: true,
  mathStyle: true,
  maxBlockSize: {
    properties: "maxBlockSize",
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  maxHeight: {
    properties: "maxHeight",
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  maxInlineSize: {
    properties: "maxInlineSize",
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  maxWidth: {
    properties: "maxWidth",
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  minBlockSize: {
    properties: "minBlockSize",
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  minHeight: {
    properties: "minHeight",
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  minInlineSize: {
    properties: "minInlineSize",
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  minWidth: {
    properties: "minWidth",
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  mixBlendMode: true,
  objectFit: true,
  objectPosition: true,
  offset: true,
  offsetAnchor: true,
  offsetDistance: true,
  offsetPath: true,
  offsetPosition: true,
  offsetRotate: true,
  opacity: true,
  order: true,
  orphans: true,
  outline: true,
  outlineColor: {
    properties: "outlineColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  outlineOffset: true,
  outlineStyle: true,
  outlineWidth: { properties: "outlineWidth", transform: transforms.px },
  overflow: true,
  overflowAnchor: true,
  overflowBlock: true,
  overflowClipMargin: true,
  overflowInline: true,
  overflowWrap: true,
  overflowX: true,
  overflowY: true,
  overlay: true,
  overscrollBehavior: true,
  overscrollBehaviorBlock: true,
  overscrollBehaviorInline: true,
  overscrollBehaviorX: true,
  overscrollBehaviorY: true,
  padding: {
    properties: "padding",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  paddingBlock: {
    properties: "paddingBlock",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  paddingBlockEnd: {
    properties: "paddingBlockEnd",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  paddingBlockStart: {
    properties: "paddingBlockStart",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  paddingBottom: {
    properties: "paddingBottom",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  paddingInline: {
    properties: "paddingInline",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  paddingInlineEnd: {
    properties: "paddingInlineEnd",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  paddingInlineStart: {
    properties: "paddingInlineStart",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  paddingLeft: {
    properties: "paddingLeft",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  paddingRight: {
    properties: "paddingRight",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  paddingTop: {
    properties: "paddingTop",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  page: true,
  pageBreakAfter: true,
  pageBreakBefore: true,
  pageBreakInside: true,
  paintOrder: true,
  perspective: true,
  perspectiveOrigin: true,
  placeContent: true,
  placeItems: true,
  placeSelf: true,
  pointerEvents: true,
  position: true,
  printColorAdjust: true,
  quotes: true,
  resize: true,
  right: {
    properties: "right",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  rowGap: {
    properties: "rowGap",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  rubyAlign: true,
  rubyPosition: true,
  scrollBehavior: true,
  scrollMargin: {
    properties: "scrollMargin",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollMarginBlock: true,
  scrollMarginBlockEnd: true,
  scrollMarginBlockStart: true,
  scrollMarginBottom: {
    properties: "scrollMarginBottom",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollMarginInline: true,
  scrollMarginInlineEnd: true,
  scrollMarginInlineStart: true,
  scrollMarginLeft: {
    properties: "scrollMarginLeft",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollMarginRight: {
    properties: "scrollMarginRight",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollMarginTop: {
    properties: "scrollMarginTop",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollPadding: {
    properties: "scrollPadding",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollPaddingBlock: true,
  scrollPaddingBlockEnd: true,
  scrollPaddingBlockStart: true,
  scrollPaddingBottom: {
    properties: "scrollPaddingBottom",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollPaddingInline: true,
  scrollPaddingInlineEnd: true,
  scrollPaddingInlineStart: true,
  scrollPaddingLeft: {
    properties: "scrollPaddingLeft",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollPaddingRight: {
    properties: "scrollPaddingRight",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollPaddingTop: {
    properties: "scrollPaddingTop",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollSnapAlign: true,
  scrollSnapStop: true,
  scrollSnapType: true,
  scrollTimeline: true,
  scrollTimelineAxis: true,
  scrollTimelineName: true,
  scrollbarColor: true,
  scrollbarGutter: true,
  scrollbarWidth: { properties: "scrollbarWidth", transform: transforms.px },
  shapeImageThreshold: true,
  shapeMargin: true,
  shapeOutside: true,
  tabSize: true,
  tableLayout: true,
  textAlign: true,
  textAlignLast: true,
  textCombineUpright: true,
  textDecoration: true,
  textDecorationColor: {
    properties: "textDecorationColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  textDecorationLine: true,
  textDecorationSkip: true,
  textDecorationSkipInk: true,
  textDecorationStyle: true,
  textDecorationThickness: true,
  textEmphasis: true,
  textEmphasisColor: {
    properties: "textEmphasisColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  textEmphasisPosition: true,
  textEmphasisStyle: true,
  textIndent: true,
  textJustify: true,
  textOrientation: true,
  textOverflow: true,
  textRendering: true,
  textShadow: {
    properties: "textShadow",
    token: "shadows",
    transform: transforms.token("shadows")
  },
  textSizeAdjust: true,
  textTransform: true,
  textUnderlineOffset: true,
  textUnderlinePosition: true,
  textWrap: true,
  timelineScope: true,
  top: {
    properties: "top",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  touchAction: true,
  transform: { properties: "transform", transform: transforms.transform },
  transformBox: true,
  transformOrigin: true,
  transformStyle: true,
  transitionBehavior: true,
  transitionDelay: true,
  transitionDuration: {
    properties: "transitionDuration",
    token: "transitions.duration",
    transform: transforms.token("transitions.duration")
  },
  transitionProperty: {
    properties: "transitionProperty",
    token: "transitions.property",
    transform: transforms.token("transitions.property")
  },
  transitionTimingFunction: {
    properties: "transitionTimingFunction",
    token: "transitions.easing",
    transform: transforms.token("transitions.easing")
  },
  translate: true,
  unicodeBidi: true,
  userSelect: true,
  verticalAlign: true,
  viewTimeline: true,
  viewTimelineAxis: true,
  viewTimelineInset: true,
  viewTimelineName: true,
  viewTransitionName: true,
  visibility: true,
  whiteSpace: true,
  whiteSpaceCollapse: true,
  widows: true,
  width: {
    properties: "width",
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  willChange: true,
  wordBreak: true,
  wordSpacing: true,
  writingMode: true,
  zIndex: {
    properties: "zIndex",
    token: "zIndices",
    transform: transforms.token("zIndices")
  },
  zoom: true,
  alignmentBaseline: true,
  azimuth: true,
  baselineShift: true,
  clipRule: true,
  dominantBaseline: true,
  fill: {
    properties: "fill",
    token: "colors",
    transform: transforms.token("colors")
  },
  fillOpacity: true,
  fillRule: true,
  floodColor: {
    properties: "floodColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  floodOpacity: true,
  glyphOrientationVertical: true,
  lightingColor: {
    properties: "lightingColor",
    token: "colors",
    transform: transforms.token("colors")
  },
  markerEnd: true,
  markerMid: true,
  markerStart: true,
  shapeRendering: true,
  stopColor: true,
  stopOpacity: true,
  stroke: {
    properties: "stroke",
    token: "colors",
    transform: transforms.token("colors")
  },
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeLinecap: true,
  strokeLinejoin: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: { properties: "strokeWidth", transform: transforms.px },
  textAnchor: true,
  vectorEffect: true,
  marginX: {
    properties: ["marginInlineStart", "marginInlineEnd"],
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  marginY: {
    properties: ["marginTop", "marginBottom"],
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  paddingX: {
    properties: ["paddingInlineStart", "paddingInlineEnd"],
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  paddingY: {
    properties: ["paddingTop", "paddingBottom"],
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollMarginX: {
    properties: ["scrollMarginLeft", "scrollMarginRight"],
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollMarginY: {
    properties: ["scrollMarginTop", "scrollMarginBottom"],
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollPaddingX: {
    properties: ["scrollPaddingLeft", "scrollPaddingRight"],
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scrollPaddingY: {
    properties: ["scrollPaddingTop", "scrollPaddingBottom"],
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  insetX: {
    properties: ["left", "right"],
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  insetY: {
    properties: ["top", "bottom"],
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  borderY: {
    properties: ["borderTop", "borderBottom"],
    token: "borders",
    transform: transforms.token("borders")
  },
  borderX: {
    properties: ["borderLeft", "borderRight"],
    token: "borders",
    transform: transforms.token("borders")
  },
  borderTopRadius: {
    properties: ["borderTopLeftRadius", "borderTopRightRadius"],
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderBottomRadius: {
    properties: ["borderBottomLeftRadius", "borderBottomRightRadius"],
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderRightRadius: {
    properties: ["borderTopRightRadius", "borderBottomRightRadius"],
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderLeftRadius: {
    properties: ["borderTopLeftRadius", "borderBottomLeftRadius"],
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderInlineStartRadius: {
    properties: ["borderStartStartRadius", "borderStartEndRadius"],
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  borderInlineEndRadius: {
    properties: ["borderEndStartRadius", "borderEndEndRadius"],
    token: "radii",
    transform: transforms.token("radii", transforms.px)
  },
  boxSize: {
    properties: ["width", "height"],
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  minBoxSize: {
    properties: ["minWidth", "minHeight"],
    token: "sizes",
    transform: transforms.token("sizes", transforms.fraction(transforms.px))
  },
  maxBoxSize: {
    properties: ["maxWidth", "maxHeight"],
    transform: transforms.fraction(transforms.px)
  },
  translateX: {
    properties: "--ui-translate-x",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  translateY: {
    properties: "--ui-translate-y",
    token: "spaces",
    transform: transforms.token("spaces", transforms.px)
  },
  scale: { properties: ["--ui-scale-x", "--ui-scale-y"] },
  scaleX: { properties: "--ui-scale-x" },
  scaleY: { properties: "--ui-scale-y" },
  rotate: { properties: "--ui-rotate", transform: transforms.deg },
  skewX: { properties: "--ui-skew-x", transform: transforms.deg },
  skewY: { properties: "--ui-skew-y", transform: transforms.deg },
  filter: { transform: transforms.filter() },
  blur: {
    properties: "--ui-blur",
    token: "blurs",
    transform: transforms.token("blurs", transforms.function("blur"))
  },
  brightness: {
    properties: "--ui-brightness",
    transform: transforms.function("brightness")
  },
  contrast: {
    properties: "--ui-contrast",
    transform: transforms.function("contrast")
  },
  dropShadow: {
    properties: "--ui-drop-shadow",
    token: "shadows",
    transform: transforms.token("shadows", transforms.function("drop-shadow"))
  },
  grayscale: {
    properties: "--ui-grayscale",
    transform: transforms.function("grayscale")
  },
  hueRotate: {
    properties: "--ui-hue-rotate",
    transform: transforms.function("hue-rotate", transforms.deg)
  },
  invert: {
    properties: "--ui-invert",
    transform: transforms.function("invert")
  },
  saturate: {
    properties: "--ui-saturate",
    transform: transforms.function("saturate")
  },
  sepia: { properties: "--ui-sepia", transform: transforms.function("sepia") },
  backdropFilter: { transform: transforms.filter("backdrop") },
  backdropBlur: {
    properties: "--ui-backdrop-blur",
    token: "blurs",
    transform: transforms.token("blurs", transforms.function("blur"))
  },
  backdropBrightness: {
    properties: "--ui-backdrop-brightness",
    transform: transforms.function("brightness")
  },
  backdropContrast: {
    properties: "--ui-backdrop-contrast",
    transform: transforms.function("contrast")
  },
  backdropDropShadow: {
    properties: "--ui-backdrop-drop-shadow",
    token: "shadows",
    transform: transforms.token("shadows", transforms.function("drop-shadow"))
  },
  backdropGrayscale: {
    properties: "--ui-backdrop-grayscale",
    transform: transforms.function("grayscale")
  },
  backdropHueRotate: {
    properties: "--ui-backdrop-hue-rotate",
    transform: transforms.function("hue-rotate", transforms.deg)
  },
  backdropInvert: {
    properties: "--ui-backdrop-invert",
    transform: transforms.function("invert")
  },
  backdropSaturate: {
    properties: "--ui-backdrop-saturate",
    transform: transforms.function("saturate")
  },
  backdropSepia: {
    properties: "--ui-backdrop-sepia",
    transform: transforms.function("sepia")
  },
  colorMode: { properties: "colorScheme" },
  lineClamp: {
    properties: "--ui-line-clamp",
    isSkip: true,
    static: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitBoxOrient: "vertical",
      WebkitLineClamp: "var(--ui-line-clamp)"
    }
  },
  isTruncated: { isSkip: true, transform: transforms.isTruncated },
  layerStyle: {
    isProcessResult: true,
    isSkip: true,
    transform: transforms.styles("layerStyles")
  },
  textStyle: {
    isProcessResult: true,
    isSkip: true,
    transform: transforms.styles("textStyles")
  },
  apply: {
    isProcessResult: true,
    isSkip: true,
    transform: transforms.styles()
  },
  var: { isProcessSkip: true, isSkip: true, transform: transforms.var }
};
var shorthandStyles = {
  accent: standardStyles.accentColor,
  bg: standardStyles.background,
  bgAttachment: { properties: "backgroundAttachment" },
  bgBlendMode: { properties: "backgroundBlendMode" },
  bgClip: standardStyles.backgroundClip,
  bgColor: standardStyles.backgroundColor,
  bgImage: standardStyles.backgroundImage,
  bgImg: standardStyles.backgroundImage,
  bgGradient: standardStyles.backgroundImage,
  bgOrigin: { properties: "backgroundOrigin" },
  bgPosition: { properties: "backgroundPosition" },
  bgPositionX: { properties: "backgroundPositionX" },
  bgPosX: { properties: "backgroundPositionX" },
  bgPositionY: { properties: "backgroundPositionY" },
  bgPosY: { properties: "backgroundPositionY" },
  bgRepeat: { properties: "backgroundRepeat" },
  bgSize: { properties: "backgroundSize" },
  roundedBottomLeft: standardStyles.borderBottomLeftRadius,
  roundedBottomRight: standardStyles.borderBottomRightRadius,
  borderBottomEndRadius: standardStyles.borderEndEndRadius,
  roundedBottomEnd: standardStyles.borderEndEndRadius,
  borderBottomStartRadius: standardStyles.borderEndStartRadius,
  roundedBottomStart: standardStyles.borderEndStartRadius,
  borderEnd: standardStyles.borderInlineEnd,
  borderEndColor: standardStyles.borderInlineEndColor,
  borderEndStyle: { properties: "borderInlineEndStyle" },
  borderEndWidth: standardStyles.borderInlineEndWidth,
  borderStart: standardStyles.borderInlineStart,
  borderStartColor: standardStyles.borderInlineStartColor,
  borderStartStyle: { properties: "borderInlineStartStyle" },
  borderStartWidth: standardStyles.borderInlineStartWidth,
  rounded: standardStyles.borderRadius,
  borderTopEndRadius: standardStyles.borderStartEndRadius,
  roundedTopEnd: standardStyles.borderStartEndRadius,
  borderTopStartRadius: standardStyles.borderStartStartRadius,
  roundedTopStart: standardStyles.borderStartStartRadius,
  roundedTopLeft: standardStyles.borderTopLeftRadius,
  roundedTopRight: standardStyles.borderTopRightRadius,
  shadow: standardStyles.boxShadow,
  caret: standardStyles.caretColor,
  textColor: standardStyles.color,
  gx: standardStyles.columnGap,
  gapX: standardStyles.columnGap,
  flexDir: { properties: "flexDirection" },
  text: standardStyles.fontSize,
  g: standardStyles.gap,
  h: standardStyles.height,
  insetEnd: standardStyles.insetInlineEnd,
  insetStart: standardStyles.insetInlineStart,
  tracking: standardStyles.letterSpacing,
  leading: standardStyles.lineHeight,
  listStyleImg: { properties: "listStyleImage" },
  listStylePos: { properties: "listStylePosition" },
  m: standardStyles.margin,
  mb: standardStyles.marginBottom,
  me: standardStyles.marginInlineEnd,
  marginEnd: standardStyles.marginInlineEnd,
  ms: standardStyles.marginInlineStart,
  marginStart: standardStyles.marginInlineStart,
  ml: standardStyles.marginLeft,
  mr: standardStyles.marginRight,
  mt: standardStyles.marginTop,
  maxH: standardStyles.maxHeight,
  maxW: standardStyles.maxWidth,
  minH: standardStyles.minHeight,
  minW: standardStyles.minWidth,
  blendMode: { properties: "mixBlendMode" },
  overscroll: { properties: "overscrollBehavior" },
  overscrollX: { properties: "overscrollBehaviorX" },
  overscrollY: { properties: "overscrollBehaviorY" },
  p: standardStyles.padding,
  pb: standardStyles.paddingBottom,
  pe: standardStyles.paddingInlineEnd,
  paddingEnd: standardStyles.paddingInlineEnd,
  ps: standardStyles.paddingInlineStart,
  paddingStart: standardStyles.paddingInlineStart,
  pl: standardStyles.paddingLeft,
  pr: standardStyles.paddingRight,
  pt: standardStyles.paddingTop,
  pos: { properties: "position" },
  gy: standardStyles.rowGap,
  gapY: standardStyles.rowGap,
  textDecor: { properties: "textDecoration" },
  w: standardStyles.width,
  z: standardStyles.zIndex,
  mx: standardStyles.marginX,
  my: standardStyles.marginY,
  px: standardStyles.paddingX,
  py: standardStyles.paddingY,
  roundedTop: standardStyles.borderTopRadius,
  roundedBottom: standardStyles.borderBottomRadius,
  roundedRight: standardStyles.borderRightRadius,
  roundedLeft: standardStyles.borderLeftRadius,
  borderStartRadius: standardStyles.borderInlineStartRadius,
  roundedStart: standardStyles.borderInlineStartRadius,
  borderEndRadius: standardStyles.borderInlineEndRadius,
  roundedEnd: standardStyles.borderInlineEndRadius
};
var atRuleStyles = {
  _media: { isProcessSkip: true, isSkip: true, transform: transforms.media },
  _container: {
    isProcessSkip: true,
    isSkip: true,
    transform: transforms.container
  },
  _supports: {
    isProcessSkip: true,
    isSkip: true,
    transform: transforms.supports
  }
};
var styles = {
  ...standardStyles,
  ...shorthandStyles,
  ...atRuleStyles
};
var processSkipProperties = [
  "var",
  "_media",
  "_container",
  "_supports"
];
var styleProperties = Object.keys(styles);
var layoutStyleProperties = [
  "width",
  "inlineSize",
  "height",
  "backfaceVisibility",
  "blockSize",
  "boxSize",
  "minWidth",
  "minInlineSize",
  "minHeight",
  "minBlockSize",
  "maxWidth",
  "maxInlineSize",
  "maxHeight",
  "maxBlockSize",
  "overflow",
  "overflowX",
  "overflowY",
  "overscrollBehavior",
  "overscroll",
  "overscrollX",
  "textDecor",
  "overscrollBehaviorY",
  "overscrollY",
  "display",
  "aspectRatio",
  "verticalAlign",
  "boxSizing",
  "boxDecorationBreak",
  "float",
  "objectFit",
  "objectPosition",
  "visibility",
  "isolation",
  "w",
  "h",
  "minW",
  "maxW",
  "minH",
  "maxH",
  "position",
  "pos",
  "zIndex",
  "inset",
  "insetX",
  "insetInline",
  "insetY",
  "insetBlock",
  "top",
  "insetBlockStart",
  "bottom",
  "insetBlockEnd",
  "left",
  "insetInlineStart",
  "right",
  "insetInlineEnd",
  "insetStart",
  "insetEnd",
  "margin",
  "marginTop",
  "marginBlockStart",
  "marginRight",
  "marginInlineEnd",
  "marginBottom",
  "marginBlockEnd",
  "marginLeft",
  "marginInlineStart",
  "marginX",
  "marginInline",
  "marginY",
  "marginBlock",
  "padding",
  "paddingTop",
  "paddingBlockStart",
  "paddingRight",
  "paddingBottom",
  "paddingBlockEnd",
  "paddingLeft",
  "paddingInlineStart",
  "paddingInlineEnd",
  "paddingX",
  "paddingInline",
  "paddingY",
  "paddingBlock",
  "m",
  "mt",
  "mr",
  "me",
  "marginEnd",
  "mb",
  "ml",
  "ms",
  "marginStart",
  "mx",
  "my",
  "p",
  "pt",
  "py",
  "px",
  "pb",
  "pl",
  "ps",
  "paddingStart",
  "pr",
  "pe",
  "paddingEnd",
  "alignItems",
  "alignContent",
  "justifyItems",
  "justifyContent",
  "flexWrap",
  "flexDirection",
  "flexDir",
  "flex",
  "flexFlow",
  "flexGrow",
  "flexShrink",
  "flexBasis",
  "justifySelf",
  "alignSelf",
  "order",
  "placeItems",
  "placeContent",
  "placeSelf",
  "gap",
  "rowGap",
  "columnGap",
  "grid",
  "gridColumn",
  "gridRow",
  "gridAutoFlow",
  "gridAutoColumns",
  "gridColumnStart",
  "gridColumnEnd",
  "gridRowStart",
  "gridRowEnd",
  "gridAutoRows",
  "gridTemplate",
  "gridTemplateColumns",
  "gridTemplateRows",
  "gridTemplateAreas",
  "gridArea"
];

// src/css/css.ts
var isProcessSkip = (key) => processSkipProperties.includes(key);
var expandColorMode = (key, value) => ({
  [key]: value[0],
  [pseudos._dark]: {
    [key]: value[1]
  }
});
var expandResponsive = (key, value, queries2) => queries2.reduce((prev, { breakpoint, query }) => {
  const breakpointValue = value[breakpoint];
  if (query) {
    if (breakpointValue)
      prev[query] = { [key]: breakpointValue };
  } else {
    prev[key] = value[breakpoint];
  }
  return prev;
}, {});
var expandCSS = (css2, isNested) => (theme) => {
  if (!theme.__breakpoints)
    return css2;
  const { isResponsive, queries: queries2 } = theme.__breakpoints;
  let computedCSS = {};
  for (let [key, value] of Object.entries(css2)) {
    value = runIfFunc(value, theme);
    if (value == null)
      continue;
    if (isArray2(value) && !(isProcessSkip(key) && !isNested)) {
      computedCSS = merge(computedCSS, expandColorMode(key, value));
      continue;
    }
    if (isObject2(value) && isResponsive(value) && !(isProcessSkip(key) && !isNested)) {
      computedCSS = merge(computedCSS, expandResponsive(key, value, queries2));
      continue;
    }
    computedCSS[key] = value;
  }
  return computedCSS;
};
var getCSS = ({
  theme,
  styles: styles2 = {},
  pseudos: pseudos2 = {},
  disableStyleProp
}) => {
  const createCSS = (cssOrFunc, isNested = false) => {
    var _a, _b, _c;
    const cssObject = runIfFunc(cssOrFunc, theme);
    const computedCSS = expandCSS(cssObject, isNested)(theme);
    let resolvedCSS = {};
    for (let [prop, value] of Object.entries(computedCSS)) {
      if (disableStyleProp == null ? void 0 : disableStyleProp(prop))
        continue;
      value = runIfFunc(value, theme);
      if (value == null)
        continue;
      if (prop in pseudos2)
        prop = pseudos2[prop];
      let style = styles2[prop];
      if (style === true)
        style = { properties: prop };
      if (isObject2(value) && !(style == null ? void 0 : style.isProcessSkip)) {
        resolvedCSS[prop] = (_a = resolvedCSS[prop]) != null ? _a : {};
        resolvedCSS[prop] = merge(resolvedCSS[prop], createCSS(value, true));
        continue;
      }
      value = (_c = (_b = style == null ? void 0 : style.transform) == null ? void 0 : _b.call(style, value, theme, css, resolvedCSS)) != null ? _c : value;
      if ((style == null ? void 0 : style.isProcessResult) || (style == null ? void 0 : style.isProcessSkip))
        value = createCSS(value, true);
      if (!isNested && (style == null ? void 0 : style.static)) {
        const staticStyles = runIfFunc(style.static, theme);
        resolvedCSS = merge(resolvedCSS, staticStyles);
      }
      const properties = runIfFunc(style == null ? void 0 : style.properties, theme);
      if (properties) {
        if (isArray2(properties)) {
          for (const property of properties) {
            resolvedCSS[property] = value;
          }
          continue;
        } else if (isObject2(value)) {
          resolvedCSS = merge(resolvedCSS, value);
          continue;
        } else {
          resolvedCSS[properties] = value;
          continue;
        }
      }
      if (isObject2(value)) {
        resolvedCSS = merge(resolvedCSS, value);
        continue;
      }
      resolvedCSS[prop] = value;
    }
    return resolvedCSS;
  };
  return createCSS;
};
var css = (cssOrFunc) => (theme, disableStyleProp) => getCSS({
  theme,
  styles,
  pseudos,
  disableStyleProp
})(cssOrFunc);

// src/css/var.ts
var createVar = (token, prefix) => {
  const variable = `--${[prefix, escape(token, "-")].filter(Boolean).join("-")}`;
  const reference = `var(${variable})`;
  return { variable, reference };
};
var tokenToVar = (token, prefix) => {
  token = token.replace(/\./g, "-");
  return createVar(token, prefix);
};
var createVars = (tokens, prefix = "ui") => ({
  baseTokens,
  cssMap = {},
  cssVars = {}
} = {}) => {
  for (let [token, { isSemantic, value }] of Object.entries(tokens)) {
    const fetchParent = (value2 = "") => {
      var _a;
      const [parent] = token.split(".");
      const relatedToken = [parent, value2].join(".");
      const tokenValue = (_a = tokens[relatedToken]) != null ? _a : baseTokens == null ? void 0 : baseTokens[relatedToken];
      if (!tokenValue)
        return [, value2];
      const { variable: variable2, reference: reference2 } = tokenToVar(relatedToken, prefix);
      return [variable2, reference2];
    };
    const { variable, reference } = tokenToVar(token, prefix);
    let resolvedLightValue;
    let resolvedDarkValue;
    const theme = { __cssMap: cssMap };
    if (token.startsWith("animations.")) {
      if (isArray3(value)) {
        resolvedLightValue = value.map((value2) => generateAnimation(value2, theme, css)).join(",");
      } else {
        resolvedLightValue = generateAnimation(value, theme, css);
      }
    } else {
      let [lightValue, darkValue] = isArray3(value) ? [...value] : [value];
      if (token.startsWith("gradients.")) {
        const [lightParentVar, lightParentRef] = fetchParent(lightValue);
        const [darkParentVar, darkParentRef] = fetchParent(darkValue);
        if (lightParentVar) {
          resolvedLightValue = lightParentRef;
        } else {
          resolvedLightValue = generateGradient(
            fetchParent(lightValue)[1],
            theme,
            css
          );
        }
        if (darkParentVar) {
          resolvedDarkValue = darkParentRef;
        } else {
          resolvedDarkValue = generateGradient(darkValue, theme, css);
        }
      } else {
        resolvedLightValue = lightValue;
        resolvedDarkValue = darkValue;
      }
    }
    if (!isSemantic) {
      if (token.startsWith("spaces") && !isUndefined(resolvedLightValue)) {
        const keys = token.split(".");
        const [firstKey, ...restKeys] = keys;
        const negativeToken = `${firstKey}.-${restKeys.join(".")}`;
        const negativeValue = calc.negate(resolvedLightValue);
        const negativeReference = calc.negate(reference);
        cssMap[negativeToken] = {
          value: negativeValue,
          var: variable,
          ref: negativeReference
        };
      }
      cssVars[variable] = resolvedLightValue;
      if (resolvedDarkValue)
        cssVars = merge2(cssVars, {
          [pseudos._dark]: { [variable]: resolvedDarkValue }
        });
      cssMap[token] = {
        value: resolvedLightValue,
        var: variable,
        ref: reference
      };
      continue;
    }
    const [parentVar, parentRef] = fetchParent(resolvedLightValue);
    cssVars = merge2(cssVars, { [variable]: parentRef });
    if (resolvedDarkValue) {
      const [, parentRef2] = fetchParent(resolvedDarkValue);
      cssVars = merge2(cssVars, { [pseudos._dark]: { [variable]: parentRef2 } });
    }
    cssMap[token] = {
      value: parentVar != null ? parentVar : resolvedLightValue,
      var: variable,
      ref: reference
    };
  }
  return { cssMap, cssVars };
};

// src/css/use-css.ts
import { css as emotionCSS } from "@emotion/css";
import { ThemeContext } from "@emotion/react";
import { useContext, useMemo } from "react";
var useCSS = (cssObject = {}) => {
  const theme = useContext(ThemeContext);
  return useMemo(() => getCSS2(cssObject)(theme), [cssObject, theme]);
};
var getCSS2 = (cssObject = {}) => (theme) => emotionCSS(css(cssObject)(theme));

// src/providers/theme-provider.tsx
import {
  Global,
  ThemeContext as ThemeContext2,
  ThemeProvider as EmotionThemeProvider
} from "@emotion/react";
import {
  runIfFunc as runIfFunc3,
  getMemoizedObject as get2,
  isUndefined as isUndefined2,
  merge as merge4
} from "@yamada-ui/utils";
import { useMemo as useMemo3, useContext as useContext3, useState as useState2, useCallback as useCallback2, useEffect as useEffect2 } from "react";

// src/theme.ts
import {
  flattenObject,
  objectFromEntries,
  pickObject,
  omitObject,
  tones,
  isObject as isObject3,
  runIfFunc as runIfFunc2,
  isFunction,
  merge as merge3
} from "@yamada-ui/utils";
var primaryTokens = [
  "blurs",
  "borders",
  "colors",
  "fonts",
  "fontSizes",
  "fontWeights",
  "letterSpacings",
  "lineHeights",
  "radii",
  "shadows",
  "sizes",
  "spaces",
  "zIndices"
];
var secondaryTokens = ["gradients"];
var transformTheme = (theme, config) => {
  var _a;
  theme = omitTheme(theme);
  const { breakpoints, themeSchemes } = theme != null ? theme : {};
  const prefix = (_a = config == null ? void 0 : config.var) == null ? void 0 : _a.prefix;
  const primaryTokens2 = createTokens(theme);
  const secondaryTokens2 = createTokens(theme, "secondary");
  const animationTokens = createTokens(theme, "animation");
  let { cssMap, cssVars } = mergeVars(
    createVars(primaryTokens2, prefix),
    createVars(secondaryTokens2, prefix),
    createVars(animationTokens, prefix)
  )();
  if (themeSchemes) {
    for (const [themeScheme, nestedTheme] of Object.entries(
      themeSchemes
    )) {
      const nestedPrimaryTokens = createTokens(nestedTheme);
      const nestedSecondaryTokens = createTokens(nestedTheme, "secondary");
      const nestedAnimationTokens = createTokens(nestedTheme, "animation");
      let { cssVars: nestedCSSVars } = mergeVars(
        createVars(nestedPrimaryTokens, prefix),
        createVars(nestedSecondaryTokens, prefix),
        createVars(nestedAnimationTokens, prefix)
      )({ ...primaryTokens2, ...secondaryTokens2, ...animationTokens });
      cssVars = {
        ...cssVars,
        [`[data-theme=${themeScheme}] &:not([data-theme]), &[data-theme=${themeScheme}]`]: nestedCSSVars
      };
    }
  }
  const defaultCSSVars = {};
  Object.assign(theme, {
    __config: config,
    __cssVars: { ...defaultCSSVars, ...cssVars },
    __cssMap: cssMap,
    __breakpoints: analyzeBreakpoints(breakpoints, config == null ? void 0 : config.breakpoint)
  });
  return theme;
};
var createTokens = (theme, target = "primary") => {
  var _a;
  let defaultTokens = [];
  let semanticTokens = [];
  let omitKeys = [];
  switch (target) {
    case "primary":
      defaultTokens = [...primaryTokens, "transitions"];
      semanticTokens = [...primaryTokens, "transitions", "colorSchemes"];
      break;
    case "secondary":
      defaultTokens = [...secondaryTokens];
      semanticTokens = [...secondaryTokens];
      break;
    case "animation":
      defaultTokens = ["animations"];
      semanticTokens = ["animations"];
      omitKeys = ["keyframes"];
      break;
    default:
      break;
  }
  const defaultTokenMap = pickObject(theme, defaultTokens);
  const semanticTokenMap = pickObject((_a = theme.semantics) != null ? _a : {}, semanticTokens);
  const defaultTokenEntries = Object.entries(
    flattenObject(defaultTokenMap, Infinity, omitKeys)
  ).map(([token, value]) => {
    const enhancedToken = { isSemantic: false, value };
    return [token, enhancedToken];
  });
  const semanticTokenEntries = Object.entries(
    flattenObject(semanticTokenMap, Infinity, omitKeys)
  ).reduce(
    (prev, [token, value]) => {
      if (token.startsWith("colorSchemes.")) {
        const [, semanticToken] = token.split(".");
        tones.forEach((tone) => {
          const enhancedToken = { isSemantic: true, value: `${value}.${tone}` };
          prev.push([`colors.${semanticToken}.${tone}`, enhancedToken]);
        });
      } else {
        const enhancedToken = { isSemantic: true, value };
        prev.push([token, enhancedToken]);
      }
      return prev;
    },
    []
  );
  return objectFromEntries([
    ...defaultTokenEntries,
    ...semanticTokenEntries
  ]);
};
var mergeVars = (...funcs) => (baseTokens) => {
  let resolvedCSSMap = {};
  let resolvedCSSVars = {};
  for (const func of funcs) {
    const { cssMap, cssVars } = func({
      baseTokens,
      cssMap: resolvedCSSMap,
      cssVars: resolvedCSSVars
    });
    resolvedCSSMap = { ...resolvedCSSMap, ...cssMap };
    resolvedCSSVars = { ...resolvedCSSVars, ...cssVars };
  }
  return { cssMap: resolvedCSSMap, cssVars: resolvedCSSVars };
};
var omitTheme = (theme) => omitObject(theme, ["__cssMap", "__cssVar", "__breakpoints"]);
var omitThemeProps = (props, keys = []) => omitObject(props, ["size", "variant", "colorScheme", ...keys]);
var mergeStyle = (target, ...sources) => ({ omit = [], pick = [] } = {}) => sources.reduce(
  (prev, source) => recursiveMergeStyle(filterStyle(prev)({ omit, pick }), source),
  target
);
var mergeMultiStyle = (target, ...sources) => ({ omit = [], pick = [] } = {}) => sources.reduce(
  (prev, source) => recursiveMergeStyle(
    filterStyle(prev)({ omit, pick, isMulti: true }),
    source
  ),
  target
);
var recursiveMergeStyle = (target, source) => {
  let result = Object.assign({}, target);
  if (isObject3(source) && isObject3(target)) {
    for (const [sourceKey, sourceValue] of Object.entries(source)) {
      const targetValue = target[sourceKey];
      if (target.hasOwnProperty(sourceKey)) {
        if (!isFunction(targetValue) && !isFunction(sourceValue)) {
          result[sourceKey] = recursiveMergeStyle(
            targetValue,
            sourceValue
          );
        } else {
          result[sourceKey] = (props) => recursiveMergeStyle(
            runIfFunc2(targetValue, props),
            runIfFunc2(sourceValue, props)
          );
        }
      } else {
        Object.assign(result, { [sourceKey]: sourceValue });
      }
    }
  } else {
    result = source;
  }
  return result;
};
var filterStyle = (target) => ({ omit, pick, isMulti = false }) => {
  if (!isObject3(target))
    return target;
  if (omit.length)
    target = internalFilterStyle(target, omit, isMulti)(omitObject);
  if (pick.length)
    target = internalFilterStyle(target, pick, isMulti)(pickObject);
  return target;
};
var internalFilterStyle = (target, keys, isMulti, refs = []) => (func) => {
  if (!isObject3(target))
    return target;
  target = func(target, keys);
  Object.entries(target != null ? target : {}).forEach(([nestedKey, value]) => {
    const newKeys = keys.filter((key) => key !== nestedKey);
    const newRefs = [...refs, nestedKey];
    if (!onValidFilterStyleKey(newRefs, isMulti))
      return;
    if (isFunction(value)) {
      target[nestedKey] = (props) => internalFilterStyle(value(props), newKeys, isMulti, newRefs)(func);
    } else {
      if (func === omitObject || Object.keys(value).some((key) => newKeys.includes(key))) {
        target[nestedKey] = internalFilterStyle(
          value,
          newKeys,
          isMulti,
          newRefs
        )(func);
      } else {
        target[nestedKey] = merge3(
          target[nestedKey],
          internalFilterStyle(value, newKeys, isMulti, newRefs)(func)
        );
      }
    }
  });
  return target;
};
var onValidFilterStyleKey = (keys, isMulti) => {
  const rootKey = keys[0];
  switch (rootKey) {
    case "baseStyle":
      return keys.length < (isMulti ? 2 : 1);
    case "variants":
    case "sizes":
      return keys.length < (isMulti ? 3 : 2);
    default:
      return false;
  }
};
var pickStyle = (target, targetKey, withProps = true) => {
  const result = {};
  Object.entries(target).forEach(([key, value]) => {
    switch (key) {
      case "baseStyle":
        if (isFunction(value)) {
          result[key] = (props) => value(props)[targetKey];
        } else {
          result[key] = value[targetKey];
        }
        break;
      case "variants":
      case "sizes":
        result[key] = Object.entries(
          value
        ).reduce((prev, [key2, value2]) => {
          if (isFunction(value2)) {
            prev[key2] = (props) => value2(props)[targetKey];
          } else {
            prev[key2] = value2[targetKey];
          }
          return prev;
        }, {});
        break;
      case "defaultProps":
        if (withProps)
          result[key] = value;
        break;
      default:
        break;
    }
  });
  return result;
};

// src/providers/color-mode-provider.tsx
import { noop, useSafeLayoutEffect } from "@yamada-ui/utils";
import {
  createContext,
  useCallback,
  useEffect,
  useMemo as useMemo2,
  useState,
  useContext as useContext2
} from "react";

// src/providers/color-mode-script.tsx
import { jsx } from "react/jsx-runtime";
var COLOR_MODE_STORAGE_KEY = "ui-color-mode";
var COLOR_MODE_MAP = /* @__PURE__ */ new Set(["dark", "light", "system"]);
var normalizeColorMode = (initialColorMode) => {
  let value = initialColorMode;
  if (!COLOR_MODE_MAP.has(value))
    value = "light";
  return value;
};
var getColorModeScript = ({
  initialColorMode = "light",
  type = "localStorage",
  storageKey = COLOR_MODE_STORAGE_KEY
} = {}) => {
  const init = normalizeColorMode(initialColorMode);
  const isCookie = type === "cookie";
  const cookieScript = `(function(){try{var a=function(o){var l="(prefers-color-scheme: dark)",v=window.matchMedia(l).matches?"dark":"light",e=o==="system"?v:o,d=document.documentElement,m=document.body,i="ui-light",n="ui-dark",s=e==="dark";return m.classList.add(s?n:i),m.classList.remove(s?i:n),d.style.colorScheme=e,d.dataset.mode=e,e},h="${init}",r="${storageKey}",t=document.cookie.match(new RegExp("(^| )".concat(r,"=([^;]+)"))),c=t?t[2]:null;c?a(c):document.cookie="".concat(r,"=").concat(a(h),"; max-age=31536000; path=/")}catch(a){}})();
  `;
  const localStorageScript = `(function(){try{var a=function(c){var v="(prefers-color-scheme: dark)",h=window.matchMedia(v).matches?"dark":"light",r=c==="system"?h:c,o=document.documentElement,s=document.body,l="ui-light",d="ui-dark",i=r==="dark";return s.classList.add(i?d:l),s.classList.remove(i?l:d),o.style.colorScheme=r,o.dataset.mode=r,r},m="${init}",e="${storageKey}",t=localStorage.getItem(e);t?a(t):localStorage.setItem(e,a(m))}catch(a){}})();
  `;
  const fn = isCookie ? cookieScript : localStorageScript;
  return `!${fn}`.trim();
};
var ColorModeScript = ({ nonce, ...rest }) => {
  const html = getColorModeScript(rest);
  return /* @__PURE__ */ jsx(
    "script",
    {
      id: "ui-color-mode-script",
      nonce,
      dangerouslySetInnerHTML: { __html: html }
    }
  );
};

// src/providers/color-mode-manager.ts
var hasSupport = !!(globalThis == null ? void 0 : globalThis.document);
var createLocalStorage = (defaultStorageKey) => ({
  ssr: false,
  type: "localStorage",
  get: (initColorMode = "light") => (storageKey = defaultStorageKey) => {
    if (!hasSupport)
      return initColorMode;
    try {
      const colorMode = localStorage.getItem(storageKey);
      return colorMode || initColorMode;
    } catch (e) {
      return initColorMode;
    }
  },
  set: (colorMode) => (storageKey = defaultStorageKey) => {
    try {
      localStorage.setItem(storageKey, colorMode);
    } catch (e) {
    }
  }
});
var parseCookie = (cookie, key) => {
  const match = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
  return match == null ? void 0 : match[2];
};
var createCookieStorage = (defaultStorageKey, cookie) => ({
  ssr: !!cookie,
  type: "cookie",
  get: (initColorMode = "light") => (storageKey = defaultStorageKey) => {
    if (cookie)
      return parseCookie(cookie, storageKey) || initColorMode;
    if (!hasSupport)
      return initColorMode;
    return parseCookie(document.cookie, storageKey) || initColorMode;
  },
  set: (colorMode) => (storageKey = defaultStorageKey) => {
    document.cookie = `${storageKey}=${colorMode}; max-age=31536000; path=/`;
  }
});
var createColorModeManager = (type = "local", cookie) => {
  switch (type) {
    case "cookie":
    case "ssr":
      return createCookieStorage(
        COLOR_MODE_STORAGE_KEY,
        typeof cookie === "string" ? cookie : void 0
      );
    default:
      return createLocalStorage(COLOR_MODE_STORAGE_KEY);
  }
};
var colorModeManager = {
  localStorage: createLocalStorage(COLOR_MODE_STORAGE_KEY),
  cookieStorage: createCookieStorage(COLOR_MODE_STORAGE_KEY),
  ssr: (cookie) => createCookieStorage(COLOR_MODE_STORAGE_KEY, cookie),
  createLocalStorage,
  createCookieStorage
};

// src/providers/color-mode-utils.ts
var classNames = {
  light: "ui-light",
  dark: "ui-dark"
};
var queries = {
  light: "(prefers-color-scheme: light)",
  dark: "(prefers-color-scheme: dark)"
};
var getColorModeUtils = ({
  isPreventTransition = true
}) => {
  const setDataset = (colorMode) => {
    const cleanup = isPreventTransition ? preventTransition2() : void 0;
    document.documentElement.dataset.mode = colorMode;
    document.documentElement.style.colorScheme = colorMode;
    cleanup == null ? void 0 : cleanup();
  };
  const setClassName = (isDark) => {
    document.body.classList.add(isDark ? classNames.dark : classNames.light);
    document.body.classList.remove(isDark ? classNames.light : classNames.dark);
  };
  const query = () => window.matchMedia(queries.dark);
  const getSystemColorMode = (fallback) => {
    var _a;
    const dark = (_a = query().matches) != null ? _a : fallback === "dark";
    return dark ? "dark" : "light";
  };
  const addListener = (func) => {
    const mql = query();
    const listener = (e) => {
      func(e.matches ? "dark" : "light");
    };
    if (typeof mql.addListener === "function") {
      mql.addListener(listener);
    } else {
      mql.addEventListener("change", listener);
    }
    return () => {
      if (typeof mql.removeListener === "function") {
        mql.removeListener(listener);
      } else {
        mql.removeEventListener("change", listener);
      }
    };
  };
  const preventTransition2 = () => {
    const css2 = document.createElement("style");
    const node = document.createTextNode(
      `*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`
    );
    css2.appendChild(node);
    document.head.appendChild(css2);
    return () => {
      ;
      (() => window.getComputedStyle(document.body))();
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          document.head.removeChild(css2);
        });
      });
    };
  };
  return {
    setDataset,
    setClassName,
    query,
    getSystemColorMode,
    addListener,
    preventTransition: preventTransition2
  };
};

// src/providers/color-mode-provider.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
var { localStorage: localStorage2 } = colorModeManager;
var getColorMode = (manager, fallback) => (storageKey) => manager.type === "cookie" && manager.ssr ? manager.get(fallback)(storageKey) : fallback;
var ColorModeContext = createContext({});
var ColorModeProvider = ({
  colorMode: defaultColorMode,
  colorModeManager: colorModeManager2 = localStorage2,
  storageKey,
  config: { initialColorMode = "light", disableTransitionOnChange = true } = {},
  children
}) => {
  const [colorMode, setColorMode] = useState(
    () => getColorMode(colorModeManager2, initialColorMode)(storageKey)
  );
  const [systemColorMode, setSystemColorMode] = useState(
    void 0
  );
  const defaultResolvedColorMode = initialColorMode === "dark" ? "dark" : "light";
  const resolvedColorMode = colorMode === "system" ? systemColorMode ? systemColorMode : defaultResolvedColorMode : colorMode;
  const { getSystemColorMode, setClassName, setDataset, addListener } = useMemo2(
    () => getColorModeUtils({ isPreventTransition: disableTransitionOnChange }),
    [disableTransitionOnChange]
  );
  const changeColorMode = useCallback(
    (colorMode2) => {
      const resolved = colorMode2 === "system" ? getSystemColorMode() : colorMode2;
      setColorMode(colorMode2);
      setClassName(resolved === "dark");
      setDataset(resolved);
      colorModeManager2.set(colorMode2)(storageKey);
    },
    [
      colorModeManager2,
      getSystemColorMode,
      setClassName,
      setDataset,
      storageKey
    ]
  );
  const changeSystemColorMode = useCallback(
    (systemColorMode2) => {
      setSystemColorMode(systemColorMode2);
      if (colorMode !== "system")
        return;
      setClassName(systemColorMode2 === "dark");
      setDataset(systemColorMode2);
    },
    [colorMode, setClassName, setDataset]
  );
  const toggleColorMode = useCallback(() => {
    changeColorMode(resolvedColorMode === "dark" ? "light" : "dark");
  }, [changeColorMode, resolvedColorMode]);
  useSafeLayoutEffect(() => {
    setSystemColorMode(getSystemColorMode());
  }, [initialColorMode, addListener, changeColorMode]);
  useEffect(() => {
    const managerValue = colorModeManager2.get()(storageKey);
    if (managerValue)
      changeColorMode(managerValue);
  }, [changeColorMode, colorModeManager2, storageKey]);
  useEffect(() => {
    return addListener(changeSystemColorMode);
  }, [addListener, changeSystemColorMode]);
  const context = useMemo2(
    () => ({
      colorMode: defaultColorMode != null ? defaultColorMode : resolvedColorMode,
      internalColorMode: colorMode,
      changeColorMode: defaultColorMode ? noop : changeColorMode,
      toggleColorMode: defaultColorMode ? noop : toggleColorMode,
      forced: defaultColorMode !== void 0
    }),
    [
      defaultColorMode,
      resolvedColorMode,
      colorMode,
      changeColorMode,
      toggleColorMode
    ]
  );
  return /* @__PURE__ */ jsx2(ColorModeContext.Provider, { value: context, children });
};
var useColorMode = () => {
  const context = useContext2(ColorModeContext);
  return context != null ? context : { colorMode: "light", internalColorMode: "light", forced: false };
};
var useColorModeValue = (light, dark) => {
  const { colorMode } = useColorMode();
  return getColorModeValue(light, dark)(colorMode);
};
var getColorModeValue = (light, dark) => (colorMode) => {
  return colorMode === "light" ? light : dark;
};

// src/providers/theme-script.tsx
import { jsx as jsx3 } from "react/jsx-runtime";
var THEME_SCHEME_STORAGE_KEY = "ui-theme-scheme";
var getThemeSchemeScript = ({
  initialThemeScheme: init = "base",
  type = "localStorage",
  storageKey = THEME_SCHEME_STORAGE_KEY
} = {}) => {
  const isCookie = type === "cookie";
  const cookieScript = `(function(){try{var a=function(c){var o=document.documentElement;return o.dataset.theme=c,c},h='${init}',r='${storageKey}',t=document.cookie.match(new RegExp('(^| )'.concat(r,'=([^;]+)'))),c=t?t[2]:null;c?a(c):(document.cookie=''.concat(r,'=').concat(a(h),'; max-age=31536000; path=/'))}catch(a){}})();`;
  const localStorageScript = `(function(){try{var a=function(c){var o=document.documentElement;return o.dataset.theme=c,c},m='${init}',e='${storageKey}',t=localStorage.getItem(e);t?a(t):localStorage.setItem(e, a(m))}catch(a){}})();`;
  const fn = isCookie ? cookieScript : localStorageScript;
  return `!${fn}`.trim();
};
var ThemeSchemeScript = ({
  nonce,
  ...rest
}) => {
  const html = getThemeSchemeScript(rest);
  return /* @__PURE__ */ jsx3(
    "script",
    {
      id: "ui-theme-script",
      nonce,
      dangerouslySetInnerHTML: { __html: html }
    }
  );
};

// src/providers/theme-manager.ts
var hasSupport2 = !!(globalThis == null ? void 0 : globalThis.document);
var createLocalStorage2 = (defaultStorageKey) => ({
  ssr: false,
  type: "localStorage",
  get: (initThemeScheme = "base") => (storageKey = defaultStorageKey) => {
    if (!hasSupport2)
      return initThemeScheme;
    try {
      const themeScheme = localStorage.getItem(storageKey);
      return themeScheme || initThemeScheme;
    } catch (e) {
      return initThemeScheme;
    }
  },
  set: (themeScheme) => (storageKey = defaultStorageKey) => {
    try {
      localStorage.setItem(storageKey, String(themeScheme));
    } catch (e) {
    }
  }
});
var parseCookie2 = (cookie, key) => {
  const match = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
  return match == null ? void 0 : match[2];
};
var createCookieStorage2 = (defaultStorageKey, cookie) => ({
  ssr: !!cookie,
  type: "cookie",
  get: (initThemeScheme = "base") => (storageKey = defaultStorageKey) => {
    if (cookie)
      return parseCookie2(cookie, storageKey) || initThemeScheme;
    if (!hasSupport2)
      return initThemeScheme;
    return parseCookie2(document.cookie, storageKey) || initThemeScheme;
  },
  set: (themeScheme) => (storageKey = defaultStorageKey) => {
    document.cookie = `${storageKey}=${themeScheme}; max-age=31536000; path=/`;
  }
});
var createThemeSchemeManager = (type = "local", cookie) => {
  switch (type) {
    case "cookie":
    case "ssr":
      return createCookieStorage2(
        THEME_SCHEME_STORAGE_KEY,
        typeof cookie === "string" ? cookie : void 0
      );
    default:
      return createLocalStorage2(THEME_SCHEME_STORAGE_KEY);
  }
};
var themeSchemeManager = {
  localStorage: createLocalStorage2(THEME_SCHEME_STORAGE_KEY),
  cookieStorage: createCookieStorage2(THEME_SCHEME_STORAGE_KEY),
  ssr: (cookie) => createCookieStorage2(THEME_SCHEME_STORAGE_KEY, cookie),
  createLocalStorage: createLocalStorage2,
  createCookieStorage: createCookieStorage2
};

// src/providers/theme-provider.tsx
import { jsx as jsx4, jsxs } from "react/jsx-runtime";
var { localStorage: localStorage3 } = themeSchemeManager;
var ThemeProvider = ({
  theme: initialTheme = {},
  config,
  themeSchemeManager: themeSchemeManager2 = localStorage3,
  storageKey,
  children
}) => {
  const [themeScheme, setThemeScheme] = useState2(
    themeSchemeManager2.get(config == null ? void 0 : config.initialThemeScheme)(storageKey)
  );
  const changeThemeScheme = useCallback2(
    (themeScheme2) => {
      const cleanup = (config == null ? void 0 : config.disableTransitionOnChange) ? preventTransition() : void 0;
      document.documentElement.dataset.theme = themeScheme2;
      cleanup == null ? void 0 : cleanup();
      setThemeScheme(themeScheme2);
      themeSchemeManager2.set(themeScheme2)(storageKey);
    },
    [config, themeSchemeManager2, storageKey]
  );
  const theme = useMemo3(
    () => transformTheme(initialTheme, config),
    [initialTheme, config]
  );
  useEffect2(() => {
    const managerValue = themeSchemeManager2.get()(storageKey);
    if (managerValue)
      changeThemeScheme(managerValue);
  }, [changeThemeScheme, themeSchemeManager2, storageKey]);
  return /* @__PURE__ */ jsxs(EmotionThemeProvider, { theme: { themeScheme, changeThemeScheme, ...theme }, children: [
    /* @__PURE__ */ jsx4(CSSVars, {}),
    children
  ] });
};
var CSSVars = () => {
  return /* @__PURE__ */ jsx4(
    Global,
    {
      styles: ({ __cssVars }) => {
        return { ":host, :root, [data-mode]": __cssVars };
      }
    }
  );
};
var ResetStyle = () => {
  const { colorMode } = useColorMode();
  return /* @__PURE__ */ jsx4(
    Global,
    {
      styles: (theme) => {
        const { themeScheme } = theme;
        let style = get2(theme, "styles.resetStyle", {});
        const computedStyle = runIfFunc3(style, {
          theme,
          colorMode,
          themeScheme
        });
        if (!computedStyle)
          return void 0;
        return css(computedStyle)(theme);
      }
    }
  );
};
var GlobalStyle = () => {
  const { colorMode } = useColorMode();
  return /* @__PURE__ */ jsx4(
    Global,
    {
      styles: (theme) => {
        const { themeScheme } = theme;
        let style = get2(theme, "styles.globalStyle", {});
        const computedStyle = runIfFunc3(style, {
          theme,
          colorMode,
          themeScheme
        });
        if (!computedStyle)
          return void 0;
        return css(computedStyle)(theme);
      }
    }
  );
};
var useTheme = () => {
  const { themeScheme, changeThemeScheme, ...internalTheme } = useContext3(
    ThemeContext2
  );
  const theme = useMemo3(() => {
    var _a;
    if (isUndefined2(themeScheme) || themeScheme === "base")
      return internalTheme;
    const nestedTheme = (_a = internalTheme.themeSchemes) == null ? void 0 : _a[themeScheme];
    if (!nestedTheme)
      return internalTheme;
    return merge4(internalTheme, nestedTheme);
  }, [themeScheme, internalTheme]);
  const value = useMemo3(
    () => ({ themeScheme, changeThemeScheme, theme, internalTheme }),
    [themeScheme, changeThemeScheme, theme, internalTheme]
  );
  return value;
};
var preventTransition = () => {
  const css2 = document.createElement("style");
  const node = document.createTextNode(
    `*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`
  );
  css2.appendChild(node);
  document.head.appendChild(css2);
  return () => {
    ;
    (() => window.getComputedStyle(document.body))();
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        document.head.removeChild(css2);
      });
    });
  };
};

// src/components/use-component-style.tsx
var getColorModeStyles = (value, modifierStyles, props) => ({ isMulti }) => {
  const [lightValue, darkValue] = value;
  const lightStyles = getStyles(
    modifierStyles[lightValue],
    props
  )({ isMulti, query: pseudos._light });
  const darkStyles = getStyles(
    modifierStyles[darkValue],
    props
  )({ isMulti, query: pseudos._dark });
  return [lightStyles, darkStyles];
};
var getResponsiveStyles = (value, modifierStyles, props) => ({ isMulti }) => {
  var _a, _b;
  const providedKeys = keysFormObject2(value);
  if (providedKeys.length === 1 && "base" in value) {
    return getStyles(
      modifierStyles[value.base],
      props
    )({ isMulti });
  } else {
    const { queries: queries2 = [] } = (_a = props.theme.__breakpoints) != null ? _a : {};
    const { breakpoint } = (_b = props.theme.__config) != null ? _b : {};
    const isDown = breakpoint === "down";
    const finalQuery = queries2.filter(
      ({ breakpoint: breakpoint2 }) => breakpoint2 !== "base" && providedKeys.includes(breakpoint2)
    ).sort(
      (a, b) => {
        var _a2, _b2, _c, _d;
        return isDown ? ((_a2 = a.maxW) != null ? _a2 : 0) - ((_b2 = b.maxW) != null ? _b2 : 0) : ((_c = b.minW) != null ? _c : 0) - ((_d = a.minW) != null ? _d : 0);
      }
    )[0];
    let hasBaseStyles = false;
    return queries2.reduce(
      (prev, { breakpoint: breakpoint2, minW, maxW, maxWQuery, minWQuery }, index) => {
        var _a2;
        const modifier = value[breakpoint2];
        const isFinal = breakpoint2 === finalQuery.breakpoint;
        if (breakpoint2 === "base")
          return prev;
        if (!modifier)
          return prev;
        if (!hasBaseStyles) {
          const baseModifier = value.base;
          const prevQuery = queries2[index - 1];
          const query2 = prevQuery == null ? void 0 : prevQuery[isDown ? "minWQuery" : "maxWQuery"];
          const baseStyles = getStyles(
            baseModifier ? modifierStyles[baseModifier] : {},
            props
          )({ isMulti, query: query2 });
          prev = merge5(prev, baseStyles);
          hasBaseStyles = true;
        }
        let query = isDown ? maxWQuery : minWQuery;
        if (!isFinal) {
          let nextIndex = index + 1;
          let nextQuery;
          while (nextIndex < queries2.length) {
            const query2 = (_a2 = queries2[nextIndex]) != null ? _a2 : {};
            if (value[query2.breakpoint]) {
              const targetIndex = nextIndex - 1;
              nextQuery = queries2[targetIndex];
              break;
            }
            nextIndex += 1;
          }
          minW = isDown ? nextQuery == null ? void 0 : nextQuery.minW : minW;
          maxW = isDown ? maxW : nextQuery == null ? void 0 : nextQuery.maxW;
          query = createQuery(minW, maxW);
        }
        const queryStyles = getStyles(
          modifierStyles[modifier],
          props
        )({ isMulti, query });
        prev = merge5(prev, queryStyles);
        return prev;
      },
      {}
    );
  }
};
var getModifierStyles = (value, modifierStyles, props) => ({ isMulti }) => {
  let styles2 = {};
  if (isArray4(value)) {
    const [lightStyles, darkStyles] = getColorModeStyles(
      value,
      modifierStyles,
      props
    )({ isMulti });
    styles2 = merge5(lightStyles, darkStyles);
  } else if (isObject4(value)) {
    styles2 = getResponsiveStyles(
      value,
      modifierStyles,
      props
    )({ isMulti });
  } else {
    styles2 = getStyles(modifierStyles[value], props)({ isMulti });
  }
  return styles2;
};
var getStyles = (stylesOrFunc, props) => ({ isMulti, query }) => {
  let styles2 = runIfFunc4(stylesOrFunc, props);
  if (isMulti) {
    for (const [key, styleOrFunc] of Object.entries(
      styles2 != null ? styles2 : {}
    )) {
      const style = runIfFunc4(styleOrFunc, props);
      if (query) {
        styles2 = merge5(styles2, { [key]: { [query]: style } });
      } else {
        styles2 = merge5(styles2, { [key]: style });
      }
    }
  } else if (query) {
    return { [query]: styles2 };
  }
  return styles2;
};
var setStyles = (name, props, isMulti = false) => {
  var _a, _b, _c, _d;
  const { theme, themeScheme } = useTheme();
  const { colorMode } = useColorMode();
  const componentStyle = get3(
    theme,
    `components.${name}`
  );
  const propsRef = useRef({});
  const stylesRef = useRef({});
  props = merge5((_a = componentStyle == null ? void 0 : componentStyle.defaultProps) != null ? _a : {}, filterUndefined2(props));
  if (componentStyle) {
    const args = omitObject2(props, ["children"]);
    let styles2 = getStyles((_b = componentStyle.baseStyle) != null ? _b : {}, {
      theme,
      colorMode,
      themeScheme,
      ...args
    })({ isMulti });
    const variantStyles = getModifierStyles(
      props.variant,
      (_c = componentStyle.variants) != null ? _c : {},
      { theme, colorMode, themeScheme, ...args }
    )({ isMulti });
    const sizeStyles = getModifierStyles(
      props.size,
      (_d = componentStyle.sizes) != null ? _d : {},
      { theme, colorMode, themeScheme, ...args }
    )({ isMulti });
    styles2 = merge5(styles2, sizeStyles);
    styles2 = merge5(styles2, variantStyles);
    const isStylesEqual = isEqual(stylesRef.current, styles2);
    if (!isStylesEqual)
      stylesRef.current = styles2;
  }
  const isPropsEqual = isEqual(propsRef.current, props);
  if (!isPropsEqual)
    propsRef.current = props;
  return [stylesRef.current, propsRef.current];
};
var useComponentStyle = (name, props) => setStyles(name, props);
var useMultiComponentStyle = (name, props) => {
  return setStyles(name, props, true);
};

// src/components/should-forward-prop.ts
var UIProps = /* @__PURE__ */ new Set([
  ...styleProperties,
  ...pseudosProperties,
  "textStyle",
  "layerStyle",
  "apply",
  "lineClamp",
  "focusBorderColor",
  "errorBorderColor",
  "as",
  "__css",
  "css",
  "sx"
]);
var HTMLProps = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
var shouldForwardProp = (disableStyleProp) => (prop) => {
  var _a;
  return HTMLProps.has(prop) || ((_a = disableStyleProp == null ? void 0 : disableStyleProp(prop)) != null ? _a : false) || !UIProps.has(prop);
};

// src/styled.ts
import createStyled from "@emotion/styled";
import {
  filterObject,
  runIfFunc as runIfFunc5,
  assignAfter,
  filterUndefined as filterUndefined3,
  interopDefault
} from "@yamada-ui/utils";
import { createElement, forwardRef as forwardRef3 } from "react";
var emotionStyled = interopDefault(createStyled);
var styleProps = { ...styles, ...pseudos };
var toCSSObject = ({ baseStyle, disableStyleProp }) => (props) => {
  const { theme, css: customCSS, __css, sx, ...rest } = props;
  const propsCSS = filterObject(
    rest,
    (prop) => prop in styleProps
  );
  const baseCSS = runIfFunc5(baseStyle, props);
  const computedCSS = css(
    assignAfter({}, __css, baseCSS, filterUndefined3(propsCSS), sx)
  )(theme, disableStyleProp);
  return customCSS ? [computedCSS, customCSS] : computedCSS;
};
var styled = (element, { baseStyle, disableStyleProp, ...styledOptions } = {}) => {
  if (!styledOptions.shouldForwardProp)
    styledOptions.shouldForwardProp = shouldForwardProp(disableStyleProp);
  const CSSObject = toCSSObject({ baseStyle, disableStyleProp });
  const Component = emotionStyled(
    element,
    styledOptions
  )(CSSObject);
  const UIComponent = forwardRef3((props, ref) => {
    const { colorMode, forced } = useColorMode();
    return createElement(Component, {
      ref,
      "data-mode": forced ? colorMode : void 0,
      ...props
    });
  });
  UIComponent.displayName = "UIComponent";
  return UIComponent;
};

// src/factory.ts
var factory = () => {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(styled, {
    apply: (_target, _thisArg, [el, options]) => {
      return styled(el, options);
    },
    get: (_target, el) => {
      if (!cache.has(el))
        cache.set(el, styled(el));
      return cache.get(el);
    }
  });
};
var ui = factory();
export {
  COLOR_MODE_STORAGE_KEY,
  CSSVars,
  ColorModeContext,
  ColorModeProvider,
  ColorModeScript,
  GlobalStyle,
  ResetStyle,
  THEME_SCHEME_STORAGE_KEY,
  ThemeProvider,
  ThemeSchemeScript,
  analyzeBreakpoints,
  atRuleStyles,
  colorModeManager,
  createColorModeManager,
  createQuery,
  createThemeSchemeManager,
  createVars,
  css,
  forwardRef2 as forwardRef,
  generateAnimation,
  generateGradient,
  getCSS2 as getCSS,
  getColorModeScript,
  getColorModeValue,
  getMinMaxQuery,
  getThemeSchemeScript,
  keyframes,
  layoutStyleProperties,
  mergeMultiStyle,
  mergeStyle,
  mode,
  omitThemeProps,
  pickStyle,
  processSkipProperties,
  shorthandStyles,
  shouldForwardProp,
  standardStyles,
  styleProperties,
  styled,
  styles,
  themeSchemeManager,
  toCSSObject,
  transformTheme,
  transforms,
  ui,
  useCSS,
  useColorMode,
  useColorModeValue,
  useComponentStyle,
  useMultiComponentStyle,
  useTheme
};
//# sourceMappingURL=index.mjs.map