{"version":3,"sources":["../src/select-list.tsx","../src/use-select.ts"],"sourcesContent":["import type { CSSUIObject, CSSUIProps } from \"@yamada-ui/core\"\nimport { forwardRef } from \"@yamada-ui/core\"\nimport type { MotionProps } from \"@yamada-ui/motion\"\nimport { PopoverContent } from \"@yamada-ui/popover\"\nimport { cx } from \"@yamada-ui/utils\"\nimport { useSelectContext, useSelectList } from \"./use-select\"\n\nexport type SelectListProps = MotionProps<\"ul\">\n\nexport const SelectList = forwardRef<SelectListProps, \"ul\">(\n  ({ className, w, width, minW, minWidth, ...rest }, ref) => {\n    const { styles } = useSelectContext()\n\n    const { getListProps } = useSelectList()\n\n    w =\n      w ?? width ?? ((styles.list?.w ?? styles.list?.width) as CSSUIProps[\"w\"])\n    minW =\n      minW ??\n      minWidth ??\n      ((styles.list?.minW ?? styles.list?.minWidth) as CSSUIProps[\"minW\"])\n\n    const css: CSSUIObject = { ...styles.list }\n\n    return (\n      <PopoverContent\n        className={cx(\"ui-select__list\", className)}\n        w={w}\n        minW={minW}\n        __css={css}\n        {...getListProps(rest, ref)}\n      />\n    )\n  },\n)\n","import type { CSSUIObject, HTMLUIProps, UIPropGetter } from \"@yamada-ui/core\"\nimport { layoutStyleProperties } from \"@yamada-ui/core\"\nimport type { FormControlOptions } from \"@yamada-ui/form-control\"\nimport {\n  formControlProperties,\n  useFormControlProps,\n} from \"@yamada-ui/form-control\"\nimport type { MotionUIPropGetter } from \"@yamada-ui/motion\"\nimport type { PopoverProps } from \"@yamada-ui/popover\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { createDescendant } from \"@yamada-ui/use-descendant\"\nimport { useDisclosure } from \"@yamada-ui/use-disclosure\"\nimport { useOutsideClick } from \"@yamada-ui/use-outside-click\"\nimport {\n  createContext,\n  dataAttr,\n  funcAll,\n  handlerAll,\n  omitObject,\n  pickObject,\n  splitObject,\n  useUnmountEffect,\n  useUpdateEffect,\n  mergeRefs,\n  isHTMLElement,\n  ariaAttr,\n  isArray,\n  isUndefined,\n  getEventRelatedTarget,\n  isContains,\n} from \"@yamada-ui/utils\"\nimport type {\n  Dispatch,\n  ForwardedRef,\n  KeyboardEvent,\n  RefObject,\n  SetStateAction,\n  FocusEvent,\n  MouseEvent,\n  CSSProperties,\n} from \"react\"\nimport { useCallback, useRef, useState, useEffect } from \"react\"\nimport type { OptionProps } from \"./\"\n\nconst isTargetOption = (target: EventTarget | null): boolean =>\n  isHTMLElement(target) &&\n  !!target?.getAttribute(\"role\")?.startsWith(\"select-item\")\n\nexport const {\n  DescendantsContextProvider: SelectDescendantsContextProvider,\n  useDescendantsContext: useSelectDescendantsContext,\n  useDescendants: useSelectDescendants,\n  useDescendant: useSelectDescendant,\n} = createDescendant<HTMLElement>()\n\nexport type MaybeValue = string | string[]\n\ntype SelectContext = Omit<\n  UseSelectProps,\n  \"value\" | \"defaultValue\" | \"onChange\" | \"isEmpty\"\n> & {\n  value: MaybeValue\n  label: MaybeValue | undefined\n  onChange: (newValue: string) => void\n  onChangeLabel: (newValue: string, runOmit?: boolean) => void\n  isOpen: boolean\n  onOpen: () => void\n  onClose: () => void\n  onFocusFirst: () => void\n  onFocusLast: () => void\n  onFocusNext: () => void\n  onFocusPrev: () => void\n  focusedIndex: number\n  setFocusedIndex: Dispatch<SetStateAction<number>>\n  containerRef: RefObject<HTMLDivElement>\n  fieldRef: RefObject<HTMLDivElement>\n  listRef: RefObject<HTMLUListElement>\n  styles: Record<string, CSSUIObject>\n}\n\nexport const [SelectProvider, useSelectContext] = createContext<SelectContext>({\n  strict: false,\n  name: \"SelectContext\",\n})\n\nexport type UseSelectProps<T extends MaybeValue = string> = Omit<\n  HTMLUIProps<\"div\">,\n  \"defaultValue\" | \"onChange\" | \"offset\"\n> &\n  Omit<\n    PopoverProps,\n    | \"initialFocusRef\"\n    | \"closeOnButton\"\n    | \"trigger\"\n    | \"autoFocus\"\n    | \"restoreFocus\"\n    | \"openDelay\"\n    | \"closeDelay\"\n  > &\n  FormControlOptions & {\n    /**\n     * The HTML `name` attribute used for forms.\n     */\n    name?: string\n    /**\n     * The placeholder of the select.\n     */\n    placeholder?: string\n    /**\n     * The value of the select.\n     */\n    value?: T\n    /**\n     * The initial value of the select.\n     */\n    defaultValue?: T\n    /**\n     * The callback invoked when value state changes.\n     */\n    onChange?: (value: T) => void\n    /**\n     * If `true`, the list element will be closed when value is selected.\n     *\n     * @default true\n     */\n    closeOnSelect?: boolean\n    /**\n     * If `true`, include placeholders in options.\n     *\n     * @default true\n     */\n    placeholderInOptions?: boolean\n    isEmpty: boolean\n    /**\n     * If `true`, the selected item(s) will be excluded from the list.\n     *\n     * @default false\n     */\n    omitSelectedValues?: boolean\n    /**\n     * The maximum selectable value.\n     */\n    maxSelectValues?: number\n    /**\n     * Props for select option element.\n     */\n    optionProps?: Omit<OptionProps, \"value\" | \"children\">\n  }\n\nexport const useSelect = <T extends MaybeValue = string>({\n  placeholder,\n  closeOnBlur = true,\n  closeOnEsc = true,\n  closeOnSelect = true,\n  placeholderInOptions = true,\n  omitSelectedValues = false,\n  maxSelectValues,\n  isEmpty,\n  placement = \"bottom-start\",\n  duration = 0.2,\n  isOpen: isOpenProp,\n  defaultIsOpen,\n  onOpen: onOpenProp,\n  onClose: onCloseProp,\n  optionProps,\n  ...rest\n}: UseSelectProps<T>) => {\n  rest = useFormControlProps(rest)\n\n  const { \"aria-readonly\": _ariaReadonly, ...formControlProps } = pickObject(\n    rest,\n    formControlProperties,\n  )\n  const [containerProps, fieldProps] = splitObject(\n    omitObject(rest, [\"value\", \"defaultValue\", \"onChange\", \"aria-readonly\"]),\n    layoutStyleProperties,\n  )\n\n  const descendants = useSelectDescendants()\n\n  const [focusedIndex, setFocusedIndex] = useState<number>(-1)\n  const [isAllSelected, setIsAllSelected] = useState<boolean>(false)\n\n  const containerRef = useRef<HTMLDivElement>(null)\n  const fieldRef = useRef<HTMLDivElement>(null)\n  const listRef = useRef<HTMLUListElement>(null)\n  const timeoutIds = useRef<Set<any>>(new Set([]))\n\n  const [value, setValue] = useControllableState({\n    value: rest.value,\n    defaultValue: rest.defaultValue,\n    onChange: rest.onChange,\n  })\n  const [label, setLabel] = useState<T | undefined>(undefined)\n\n  const isFocused = focusedIndex > -1\n  const isMulti = isArray(value)\n  const isEmptyValue =\n    (!isMulti ? !value : !value.length) &&\n    !(placeholder && placeholderInOptions)\n\n  const selectedValues = descendants.values(\n    ({ node }) => isMulti && value.includes(node.dataset.value ?? \"\"),\n  )\n\n  const selectedIndexes = selectedValues.map(({ index }) => index)\n  const enabledValues = descendants.enabledValues(\n    ({ index }) => !selectedIndexes.includes(index),\n  )\n\n  const onFocusFirst = useCallback(() => {\n    const id = setTimeout(() => {\n      const first = descendants.enabledFirstValue()\n\n      if (!first) return\n\n      if (!isMulti || !omitSelectedValues) {\n        setFocusedIndex(first.index)\n      } else {\n        if (selectedIndexes.includes(first.index)) {\n          const enabledFirst = enabledValues[0]\n\n          setFocusedIndex(enabledFirst.index)\n        } else {\n          setFocusedIndex(first.index)\n        }\n      }\n    })\n\n    timeoutIds.current.add(id)\n  }, [descendants, enabledValues, isMulti, omitSelectedValues, selectedIndexes])\n\n  const onFocusLast = useCallback(() => {\n    const id = setTimeout(() => {\n      const last = descendants.enabledLastValue()\n\n      if (!last) return\n\n      if (!isMulti || !omitSelectedValues) {\n        setFocusedIndex(last.index)\n      } else {\n        if (selectedIndexes.includes(last.index)) {\n          const enabledLast = enabledValues.reverse()[0]\n\n          setFocusedIndex(enabledLast.index)\n        } else {\n          setFocusedIndex(last.index)\n        }\n      }\n    })\n\n    timeoutIds.current.add(id)\n  }, [descendants, enabledValues, isMulti, omitSelectedValues, selectedIndexes])\n\n  const onFocusSelected = useCallback(() => {\n    const id = setTimeout(() => {\n      const values = descendants.enabledValues()\n\n      const selected = values.find(({ node }) =>\n        !isMulti\n          ? node.dataset.value === value\n          : value.includes(node.dataset.value ?? \"\"),\n      )\n\n      if (selected) setFocusedIndex(selected.index)\n    })\n\n    timeoutIds.current.add(id)\n  }, [descendants, isMulti, value])\n\n  const onFocusNext = useCallback(() => {\n    const id = setTimeout(() => {\n      const next = descendants.enabledNextValue(focusedIndex)\n\n      if (!next) return\n\n      if (!isMulti || !omitSelectedValues) {\n        setFocusedIndex(next.index)\n      } else {\n        if (selectedIndexes.includes(next.index)) {\n          const enabledNext =\n            enabledValues.find(({ index }) => next.index < index) ??\n            enabledValues[0]\n\n          setFocusedIndex(enabledNext.index)\n        } else {\n          setFocusedIndex(next.index)\n        }\n      }\n    })\n\n    timeoutIds.current.add(id)\n  }, [\n    descendants,\n    enabledValues,\n    focusedIndex,\n    isMulti,\n    omitSelectedValues,\n    selectedIndexes,\n    setFocusedIndex,\n  ])\n\n  const onFocusPrev = useCallback(() => {\n    const id = setTimeout(() => {\n      const prev = descendants.enabledPrevValue(focusedIndex)\n\n      if (!prev) return\n\n      if (!isMulti || !omitSelectedValues) {\n        setFocusedIndex(prev.index)\n      } else {\n        if (selectedIndexes.includes(prev.index)) {\n          const enabledPrev =\n            enabledValues.reverse().find(({ index }) => index < prev.index) ??\n            enabledValues[0]\n\n          setFocusedIndex(enabledPrev.index)\n        } else {\n          setFocusedIndex(prev.index)\n        }\n      }\n    })\n\n    timeoutIds.current.add(id)\n  }, [\n    descendants,\n    enabledValues,\n    focusedIndex,\n    isMulti,\n    omitSelectedValues,\n    selectedIndexes,\n    setFocusedIndex,\n  ])\n\n  const onFocusFirstOrSelected =\n    isEmptyValue || omitSelectedValues ? onFocusFirst : onFocusSelected\n  const onFocusLastOrSelected =\n    isEmptyValue || omitSelectedValues ? onFocusLast : onFocusSelected\n\n  const onChangeLabel = useCallback(\n    (newValue: string, runOmit: boolean = true) => {\n      const values = descendants.values()\n      const selectedValues = values\n        .filter(({ node }) => node.dataset.value === newValue)\n        .map(({ node, index }) => {\n          if (!(!!placeholder && placeholderInOptions) || index !== 0) {\n            const el = Array.from(node.children).find(\n              (child) => child.getAttribute(\"data-label\") !== null,\n            )\n\n            return el?.innerHTML ?? \"\"\n          } else {\n            return undefined\n          }\n        })\n\n      setLabel((prev) => {\n        if (!isMulti) {\n          return selectedValues[0] as T\n        } else {\n          selectedValues.forEach((selectedValue) => {\n            const isSelected =\n              isArray(prev) && prev.includes(selectedValue ?? \"\")\n\n            if (!isSelected) {\n              prev = [...(isArray(prev) ? prev : []), selectedValue] as T\n            } else if (runOmit) {\n              prev = (\n                isArray(prev)\n                  ? prev.filter((value) => value !== selectedValue)\n                  : undefined\n              ) as T\n            }\n          })\n\n          return prev\n        }\n      })\n    },\n    [descendants, isMulti, placeholder, placeholderInOptions],\n  )\n\n  const onChange = useCallback(\n    (newValue: string) => {\n      setValue((prev) => {\n        if (!isArray(prev)) {\n          return newValue as T\n        } else {\n          const isSelected = prev.includes(newValue)\n\n          if (!isSelected) {\n            return [...prev, newValue] as T\n          } else {\n            return prev.filter((value) => value !== newValue) as T\n          }\n        }\n      })\n\n      onChangeLabel(newValue)\n    },\n    [onChangeLabel, setValue],\n  )\n\n  const onClear = useCallback(\n    (ev: MouseEvent<HTMLDivElement>) => {\n      ev.stopPropagation()\n\n      setValue([] as unknown as T)\n      setLabel(undefined)\n    },\n    [setLabel, setValue],\n  )\n\n  const {\n    isOpen,\n    onOpen: onInternalOpen,\n    onClose,\n  } = useDisclosure({\n    isOpen: isOpenProp,\n    defaultIsOpen,\n    onOpen: onOpenProp,\n    onClose: onCloseProp,\n  })\n\n  const onOpen = useCallback(() => {\n    if (formControlProps.disabled || formControlProps.readOnly) return\n\n    if (isEmpty || isAllSelected) return\n\n    onInternalOpen()\n  }, [formControlProps, isEmpty, isAllSelected, onInternalOpen])\n\n  const onSelect = useCallback(() => {\n    let enabledValue = descendants.value(focusedIndex)\n\n    if (\"disabled\" in (enabledValue?.node.dataset ?? {}))\n      enabledValue = undefined\n\n    if (!enabledValue) return\n\n    const value = enabledValue.node.dataset.value ?? \"\"\n\n    onChange(value)\n\n    if (closeOnSelect) onClose()\n\n    if (omitSelectedValues) onFocusNext()\n  }, [\n    closeOnSelect,\n    descendants,\n    focusedIndex,\n    omitSelectedValues,\n    onChange,\n    onClose,\n    onFocusNext,\n  ])\n\n  const onClick = useCallback(() => {\n    if (isOpen) return\n\n    onOpen()\n\n    onFocusFirstOrSelected()\n  }, [isOpen, onFocusFirstOrSelected, onOpen])\n\n  const onFocus = useCallback(() => {\n    if (isOpen) return\n\n    onOpen()\n\n    onFocusFirstOrSelected()\n  }, [isOpen, onFocusFirstOrSelected, onOpen])\n\n  const onBlur = useCallback(\n    (ev: FocusEvent<HTMLDivElement>) => {\n      const relatedTarget = getEventRelatedTarget(ev)\n\n      if (isContains(containerRef.current, relatedTarget)) return\n\n      if (!closeOnBlur) return\n\n      if (isOpen) onClose()\n    },\n    [closeOnBlur, isOpen, onClose],\n  )\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLDivElement>) => {\n      if (ev.key === \" \") ev.key = ev.code\n\n      if (formControlProps.disabled || formControlProps.readOnly) return\n\n      const actions: Record<string, Function | undefined> = {\n        ArrowDown: isFocused\n          ? () => onFocusNext()\n          : !isOpen\n            ? funcAll(onOpen, onFocusFirstOrSelected)\n            : undefined,\n        ArrowUp: isFocused\n          ? () => onFocusPrev()\n          : !isOpen\n            ? funcAll(onOpen, onFocusLastOrSelected)\n            : undefined,\n        Space: isFocused\n          ? onSelect\n          : !isOpen\n            ? funcAll(onOpen, onFocusFirstOrSelected)\n            : undefined,\n        Enter: isFocused\n          ? onSelect\n          : !isOpen\n            ? funcAll(onOpen, onFocusFirstOrSelected)\n            : undefined,\n        Home: isOpen ? onFocusFirst : undefined,\n        End: isOpen ? onFocusLast : undefined,\n        Escape: closeOnEsc ? onClose : undefined,\n      }\n\n      const action = actions[ev.key]\n\n      if (!action) return\n\n      ev.preventDefault()\n      ev.stopPropagation()\n      action()\n    },\n    [\n      formControlProps.disabled,\n      formControlProps.readOnly,\n      isFocused,\n      isOpen,\n      onOpen,\n      onFocusFirstOrSelected,\n      onFocusLastOrSelected,\n      onSelect,\n      onFocusFirst,\n      onFocusLast,\n      closeOnEsc,\n      onClose,\n      onFocusNext,\n      onFocusPrev,\n    ],\n  )\n\n  useOutsideClick({\n    ref: containerRef,\n    handler: onClose,\n    enabled: isOpen && closeOnBlur,\n  })\n\n  useEffect(() => {\n    if (!isMulti) return\n\n    if (!omitSelectedValues && isUndefined(maxSelectValues)) return\n\n    const isAll = value.length > 0 && value.length === descendants.count()\n    const isMax = value.length === maxSelectValues\n\n    if (isAll || isMax) {\n      onClose()\n      setIsAllSelected(true)\n    } else {\n      setIsAllSelected(false)\n    }\n  }, [\n    omitSelectedValues,\n    value,\n    descendants,\n    isMulti,\n    onClose,\n    maxSelectValues,\n  ])\n\n  useUpdateEffect(() => {\n    if (!isOpen) setFocusedIndex(-1)\n  }, [isOpen])\n\n  useUnmountEffect(() => {\n    timeoutIds.current.forEach((id) => clearTimeout(id))\n    timeoutIds.current.clear()\n  })\n\n  const getPopoverProps = useCallback(\n    (props?: PopoverProps): PopoverProps => ({\n      matchWidth: true,\n      ...rest,\n      ...props,\n      isOpen,\n      onOpen,\n      onClose,\n      placement,\n      duration,\n      trigger: \"never\",\n      closeOnButton: false,\n      closeOnBlur,\n    }),\n    [duration, closeOnBlur, onClose, onOpen, placement, rest, isOpen],\n  )\n\n  const getContainerProps: UIPropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ref: mergeRefs(containerRef, ref),\n      ...containerProps,\n      ...props,\n      ...formControlProps,\n      onClick: handlerAll(props.onClick, rest.onClick, onClick),\n\n      onBlur: handlerAll(props.onBlur, rest.onBlur, onBlur),\n    }),\n    [containerProps, formControlProps, onBlur, onClick, rest],\n  )\n\n  const getFieldProps: UIPropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ref: mergeRefs(fieldRef, ref),\n      tabIndex: 0,\n      ...fieldProps,\n      ...props,\n      \"data-active\": dataAttr(isOpen),\n      \"data-placeholder\": dataAttr(\n        !isMulti ? label === undefined : !label?.length,\n      ),\n      \"aria-expanded\": dataAttr(isOpen),\n      onFocus: handlerAll(props.onFocus, rest.onFocus, onFocus),\n      onKeyDown: handlerAll(props.onKeyDown, rest.onKeyDown, onKeyDown),\n    }),\n    [fieldProps, isOpen, isMulti, label, rest, onFocus, onKeyDown],\n  )\n\n  return {\n    descendants,\n    value,\n    label,\n    focusedIndex,\n    placeholder,\n    placeholderInOptions,\n    omitSelectedValues,\n    closeOnSelect,\n    isOpen,\n    containerRef,\n    fieldRef,\n    listRef,\n    optionProps,\n    formControlProps,\n    onChangeLabel,\n    onChange,\n    onClear,\n    onOpen,\n    onClose,\n    onFocusFirst,\n    onFocusLast,\n    onFocusSelected,\n    onFocusNext,\n    onFocusPrev,\n    setFocusedIndex,\n    getPopoverProps,\n    getContainerProps,\n    getFieldProps,\n  }\n}\n\nexport type UseSelectReturn = ReturnType<typeof useSelect>\n\nexport const useSelectList = () => {\n  const { listRef, focusedIndex } = useSelectContext()\n\n  const descendants = useSelectDescendantsContext()\n\n  const beforeFocusedIndex = useRef<number>(-1)\n  const selectedValue = descendants.value(focusedIndex)\n\n  useEffect(() => {\n    if (!listRef.current || !selectedValue) return\n\n    if (beforeFocusedIndex.current === selectedValue.index) return\n\n    const parent = listRef.current\n    const child = selectedValue.node\n\n    const parentHeight = parent.clientHeight\n    const viewTop = parent.scrollTop\n    const viewBottom = viewTop + parentHeight\n\n    const childHeight = child.clientHeight\n    const childTop = child.offsetTop\n    const childBottom = childTop + childHeight\n\n    const isInView = viewTop <= childTop && childBottom <= viewBottom\n\n    const isScrollBottom = beforeFocusedIndex.current < selectedValue.index\n\n    if (!isInView) {\n      if (childBottom <= parentHeight) {\n        listRef.current.scrollTo({ top: 0 })\n      } else {\n        if (!isScrollBottom) {\n          listRef.current.scrollTo({ top: childTop + 1 })\n        } else {\n          listRef.current.scrollTo({ top: childBottom - parentHeight })\n        }\n      }\n    }\n\n    beforeFocusedIndex.current = selectedValue.index\n  }, [listRef, selectedValue])\n\n  const getListProps: MotionUIPropGetter<\"ul\"> = useCallback(\n    (props = {}, ref = null) => ({\n      as: \"ul\",\n      ref: mergeRefs(listRef, ref),\n      role: \"select\",\n      tabIndex: -1,\n      ...props,\n    }),\n    [listRef],\n  )\n\n  return {\n    getListProps,\n  }\n}\n\nexport type UseSelectListReturn = ReturnType<typeof useSelectList>\n\nexport type UseSelectOptionGroupProps = HTMLUIProps<\"ul\"> & {\n  /**\n   * The label of the option group.\n   */\n  label: string\n}\n\nexport const useSelectOptionGroup = ({\n  label,\n  ...rest\n}: UseSelectOptionGroupProps) => {\n  const { value, omitSelectedValues } = useSelectContext()\n\n  const isMulti = isArray(value)\n\n  const descendants = useSelectDescendantsContext()\n\n  const values = descendants.values()\n  const selectedValues =\n    isMulti && omitSelectedValues\n      ? descendants.values(({ node }) =>\n          value.includes(node.dataset.value ?? \"\"),\n        )\n      : []\n  const selectedIndexes = selectedValues.map(({ index }) => index)\n  const childValues = values.filter(\n    ({ node, index }) =>\n      node.parentElement?.dataset.label === label &&\n      !selectedIndexes.includes(index),\n  )\n\n  const isEmpty = !childValues.length\n\n  const computedRest = splitObject(rest, layoutStyleProperties)\n\n  const getContainerProps: UIPropGetter = useCallback(\n    (props = {}, ref = null) => {\n      const style: CSSProperties = {\n        border: \"0px\",\n        clip: \"rect(0px, 0px, 0px, 0px)\",\n        height: \"1px\",\n        width: \"1px\",\n        margin: \"-1px\",\n        padding: \"0px\",\n        overflow: \"hidden\",\n        whiteSpace: \"nowrap\",\n        position: \"absolute\",\n      }\n\n      return {\n        ref,\n        ...props,\n        ...computedRest[0],\n        style: isEmpty ? style : undefined,\n      }\n    },\n    [computedRest, isEmpty],\n  )\n\n  const getGroupProps: UIPropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ref,\n      ...props,\n      ...computedRest[1],\n      \"data-label\": label,\n    }),\n    [computedRest, label],\n  )\n\n  return {\n    label,\n    getContainerProps,\n    getGroupProps,\n  }\n}\n\nexport type UseSelectOptionGroupReturn = ReturnType<typeof useSelectOptionGroup>\n\nexport type UseSelectOptionProps = Omit<HTMLUIProps<\"li\">, \"value\"> & {\n  /**\n   * The value of the select option.\n   */\n  value?: string\n  /**\n   * If `true`, the select option will be disabled.\n   *\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the select option will be focusable.\n   *\n   * @default false\n   */\n  isFocusable?: boolean\n  /**\n   * If `true`, the list element will be closed when selected.\n   *\n   * @default false\n   */\n  closeOnSelect?: boolean\n}\n\nexport const useSelectOption = (\n  ref: ForwardedRef<any> | undefined,\n  props: UseSelectOptionProps,\n) => {\n  const {\n    fieldRef,\n    value,\n    placeholder,\n    placeholderInOptions,\n    omitSelectedValues,\n    closeOnSelect: generalCloseOnSelect,\n    focusedIndex,\n    optionProps,\n    onChange,\n    onChangeLabel,\n    onFocusNext,\n    onClose,\n    setFocusedIndex,\n  } = useSelectContext()\n\n  let {\n    icon: customIcon,\n    isDisabled,\n    isFocusable,\n    closeOnSelect: customCloseOnSelect,\n    children,\n    ...computedProps\n  } = { ...optionProps, ...props }\n\n  const trulyDisabled = !!isDisabled && !isFocusable\n\n  const itemRef = useRef<HTMLLIElement>(null)\n\n  const { index, register, descendants } = useSelectDescendant({\n    disabled: trulyDisabled,\n  })\n\n  const values = descendants.values()\n  const frontValues = values.slice(0, index)\n\n  const isMulti = isArray(value)\n  const isDuplicated = !isMulti\n    ? frontValues.some(\n        ({ node }) => node.dataset.value === (computedProps.value ?? \"\"),\n      )\n    : false\n\n  const isSelected =\n    !isDuplicated &&\n    (!isMulti\n      ? (computedProps.value ?? \"\") === value\n      : value.includes(computedProps.value ?? \"\"))\n  const isFocused = index === focusedIndex\n\n  if (\n    !!placeholder &&\n    index > 0 &&\n    placeholderInOptions &&\n    !computedProps.value\n  ) {\n    console.warn(\n      `${\n        !isMulti ? \"Select\" : \"MultiSelect\"\n      }: If placeholders are present, All options must be set value. If want to set an empty value, either don't set the placeholder or set 'placeholderInOptions' to false.`,\n    )\n  }\n  const onClick = useCallback(\n    (ev: MouseEvent<HTMLLIElement>) => {\n      ev.preventDefault()\n      ev.stopPropagation()\n\n      if (isDisabled) {\n        if (fieldRef.current) fieldRef.current.focus()\n\n        return\n      }\n\n      if (!isTargetOption(ev.currentTarget)) {\n        if (fieldRef.current) fieldRef.current.focus()\n\n        return\n      }\n\n      setFocusedIndex(index)\n\n      onChange(computedProps.value ?? \"\")\n\n      if (fieldRef.current) fieldRef.current.focus()\n\n      if (customCloseOnSelect ?? generalCloseOnSelect) onClose()\n\n      if (omitSelectedValues) onFocusNext()\n    },\n    [\n      isDisabled,\n      setFocusedIndex,\n      index,\n      onChange,\n      computedProps.value,\n      fieldRef,\n      customCloseOnSelect,\n      generalCloseOnSelect,\n      onClose,\n      omitSelectedValues,\n      onFocusNext,\n    ],\n  )\n\n  useEffect(() => {\n    if (isSelected) onChangeLabel(computedProps.value ?? \"\", false)\n  }, [computedProps, isSelected, onChangeLabel])\n\n  const getOptionProps: UIPropGetter<\"li\"> = useCallback(\n    (props = {}) => {\n      const style: CSSProperties = {\n        border: \"0px\",\n        clip: \"rect(0px, 0px, 0px, 0px)\",\n        height: \"1px\",\n        width: \"1px\",\n        margin: \"-1px\",\n        padding: \"0px\",\n        overflow: \"hidden\",\n        whiteSpace: \"nowrap\",\n        position: \"absolute\",\n      }\n\n      return {\n        ref: mergeRefs(itemRef, ref, register),\n        ...omitObject(computedProps, [\"value\"]),\n        ...props,\n        role: \"select-item\",\n        tabIndex: -1,\n        style: omitSelectedValues && isSelected ? style : undefined,\n        \"data-value\": computedProps.value ?? \"\",\n        \"data-focus\": dataAttr(isFocused),\n        \"data-disabled\": dataAttr(isDisabled),\n        \"aria-checked\": ariaAttr(isSelected),\n        \"aria-disabled\": ariaAttr(isDisabled),\n        onClick: handlerAll(computedProps.onClick, props.onClick, onClick),\n      }\n    },\n    [\n      computedProps,\n      isDisabled,\n      isFocused,\n      isSelected,\n      omitSelectedValues,\n      onClick,\n      ref,\n      register,\n    ],\n  )\n\n  return {\n    isSelected,\n    isFocused,\n    customIcon,\n    children,\n    getOptionProps,\n  }\n}\n\nexport type UseSelectOptionReturn = ReturnType<typeof useSelectOption>\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,IAAAA,eAA2B;AAE3B,qBAA+B;AAC/B,IAAAC,gBAAmB;;;ACHnB,kBAAsC;AAEtC,0BAGO;AAGP,oCAAqC;AACrC,4BAAiC;AACjC,4BAA8B;AAC9B,+BAAgC;AAChC,mBAiBO;AAWP,mBAAyD;AAOlD,IAAM;AAAA,EACX,4BAA4B;AAAA,EAC5B,uBAAuB;AAAA,EACvB,gBAAgB;AAAA,EAChB,eAAe;AACjB,QAAI,wCAA8B;AA2B3B,IAAM,CAAC,gBAAgB,gBAAgB,QAAI,4BAA6B;AAAA,EAC7E,QAAQ;AAAA,EACR,MAAM;AACR,CAAC;AAokBM,IAAM,gBAAgB,MAAM;AACjC,QAAM,EAAE,SAAS,aAAa,IAAI,iBAAiB;AAEnD,QAAM,cAAc,4BAA4B;AAEhD,QAAM,yBAAqB,qBAAe,EAAE;AAC5C,QAAM,gBAAgB,YAAY,MAAM,YAAY;AAEpD,8BAAU,MAAM;AACd,QAAI,CAAC,QAAQ,WAAW,CAAC;AAAe;AAExC,QAAI,mBAAmB,YAAY,cAAc;AAAO;AAExD,UAAM,SAAS,QAAQ;AACvB,UAAM,QAAQ,cAAc;AAE5B,UAAM,eAAe,OAAO;AAC5B,UAAM,UAAU,OAAO;AACvB,UAAM,aAAa,UAAU;AAE7B,UAAM,cAAc,MAAM;AAC1B,UAAM,WAAW,MAAM;AACvB,UAAM,cAAc,WAAW;AAE/B,UAAM,WAAW,WAAW,YAAY,eAAe;AAEvD,UAAM,iBAAiB,mBAAmB,UAAU,cAAc;AAElE,QAAI,CAAC,UAAU;AACb,UAAI,eAAe,cAAc;AAC/B,gBAAQ,QAAQ,SAAS,EAAE,KAAK,EAAE,CAAC;AAAA,MACrC,OAAO;AACL,YAAI,CAAC,gBAAgB;AACnB,kBAAQ,QAAQ,SAAS,EAAE,KAAK,WAAW,EAAE,CAAC;AAAA,QAChD,OAAO;AACL,kBAAQ,QAAQ,SAAS,EAAE,KAAK,cAAc,aAAa,CAAC;AAAA,QAC9D;AAAA,MACF;AAAA,IACF;AAEA,uBAAmB,UAAU,cAAc;AAAA,EAC7C,GAAG,CAAC,SAAS,aAAa,CAAC;AAE3B,QAAM,mBAAyC;AAAA,IAC7C,CAAC,QAAQ,CAAC,GAAG,MAAM,UAAU;AAAA,MAC3B,IAAI;AAAA,MACJ,SAAK,wBAAU,SAAS,GAAG;AAAA,MAC3B,MAAM;AAAA,MACN,UAAU;AAAA,MACV,GAAG;AAAA,IACL;AAAA,IACA,CAAC,OAAO;AAAA,EACV;AAEA,SAAO;AAAA,IACL;AAAA,EACF;AACF;;;ADvrBM;AAhBC,IAAM,iBAAa;AAAA,EACxB,CAAC,EAAE,WAAW,GAAG,OAAO,MAAM,UAAU,GAAG,KAAK,GAAG,QAAQ;AAV7D;AAWI,UAAM,EAAE,OAAO,IAAI,iBAAiB;AAEpC,UAAM,EAAE,aAAa,IAAI,cAAc;AAEvC,SACE,qBAAK,UAAL,aAAgB,kBAAO,SAAP,mBAAa,MAAb,aAAkB,YAAO,SAAP,mBAAa;AACjD,YACE,2BACA,aADA,aAEE,kBAAO,SAAP,mBAAa,SAAb,aAAqB,YAAO,SAAP,mBAAa;AAEtC,UAAM,MAAmB,EAAE,GAAG,OAAO,KAAK;AAE1C,WACE;AAAA,MAAC;AAAA;AAAA,QACC,eAAW,kBAAG,mBAAmB,SAAS;AAAA,QAC1C;AAAA,QACA;AAAA,QACA,OAAO;AAAA,QACN,GAAG,aAAa,MAAM,GAAG;AAAA;AAAA,IAC5B;AAAA,EAEJ;AACF;","names":["import_core","import_utils"]}