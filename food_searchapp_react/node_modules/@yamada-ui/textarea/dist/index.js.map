{"version":3,"sources":["../src/index.ts","../src/textarea.tsx","../src/use-autosize.ts"],"sourcesContent":["export { Textarea } from \"./textarea\"\nexport type { TextareaProps } from \"./textarea\"\n","import type {\n  CSSUIObject,\n  HTMLUIProps,\n  ThemeProps,\n  ColorModeToken,\n  CSS,\n} from \"@yamada-ui/core\"\nimport {\n  ui,\n  forwardRef,\n  omitThemeProps,\n  useComponentStyle,\n} from \"@yamada-ui/core\"\nimport type { FormControlOptions } from \"@yamada-ui/form-control\"\nimport { useFormControlProps } from \"@yamada-ui/form-control\"\nimport {\n  addDomEvent,\n  assignRef,\n  createdDom,\n  cx,\n  handlerAll,\n  mergeRefs,\n  noop,\n  useSafeLayoutEffect,\n  useUpdateEffect,\n} from \"@yamada-ui/utils\"\nimport type { ForwardedRef } from \"react\"\nimport { useRef } from \"react\"\nimport useAutosize from \"./use-autosize\"\n\ntype TextareaOptions = {\n  /**\n   * The border color when the input is focused.\n   */\n  focusBorderColor?: ColorModeToken<CSS.Property.BorderColor, \"colors\">\n  /**\n   * The border color when the input is invalid.\n   */\n  errorBorderColor?: ColorModeToken<CSS.Property.BorderColor, \"colors\">\n  /**\n   * If `true`, the Textarea height auto-adjusts to text height.\n   */\n  autosize?: boolean\n  /**\n   * Autosize up to maxRows rows.\n   *\n   * @default Infinity\n   */\n  maxRows?: number\n  /**\n   * Autosize up to minRows rows.\n   *\n   * @default 1\n   */\n  minRows?: number\n  /**\n   * Ref to a resize function.\n   */\n  resizeRef?: ForwardedRef<() => void>\n}\n\nexport type TextareaProps = Omit<\n  HTMLUIProps<\"textarea\">,\n  \"disabled\" | \"required\" | \"readOnly\"\n> &\n  ThemeProps<\"Textarea\"> &\n  TextareaOptions &\n  FormControlOptions\n\n/**\n * `Textarea` is a component used to obtain multi-line text input.\n *\n * @see Docs https://yamada-ui.com/components/forms/textarea\n */\nexport const Textarea = forwardRef<TextareaProps, \"textarea\">((props, ref) => {\n  const [\n    { h, height, minH, minHeight, maxH, maxHeight, ...styles },\n    mergedProps,\n  ] = useComponentStyle(\"Textarea\", props)\n  let {\n    className,\n    rows,\n    resize = \"none\",\n    autosize,\n    maxRows = Infinity,\n    minRows = 1,\n    resizeRef,\n    onChange,\n    ...rest\n  } = omitThemeProps(mergedProps)\n  rest = useFormControlProps(rest)\n\n  const isBrowser = createdDom()\n  const textareaRef = useRef<HTMLTextAreaElement>(null)\n  const value = textareaRef.current?.value ?? \"\"\n  const resizeTextarea = useAutosize(textareaRef, maxRows, minRows)\n\n  let css: CSSUIObject\n\n  if (rows || autosize) {\n    css = styles\n  } else {\n    css = { h, height, minH, minHeight, maxH, maxHeight, ...styles }\n  }\n\n  useSafeLayoutEffect(() => {\n    if (!isBrowser || !autosize) return\n\n    resizeTextarea()\n\n    const unsubscribeResize = addDomEvent(window, \"resize\", resizeTextarea)\n    const unsubscribeLoadingdone = addDomEvent(\n      document.fonts,\n      \"loadingdone\",\n      resizeTextarea,\n    )\n\n    return () => {\n      unsubscribeResize()\n      unsubscribeLoadingdone()\n    }\n  }, [])\n\n  useUpdateEffect(() => {\n    if (!autosize) return\n    resizeTextarea()\n  }, [value])\n\n  assignRef(resizeRef, resizeTextarea)\n\n  return (\n    <ui.textarea\n      ref={mergeRefs(ref, textareaRef)}\n      className={cx(\"ui-textarea\", className)}\n      __css={css}\n      resize={resize}\n      rows={rows}\n      onChange={handlerAll(autosize ? resizeTextarea : noop, onChange)}\n      {...rest}\n    />\n  )\n})\n","import { pickObject } from \"@yamada-ui/utils\"\nimport type { RefObject } from \"react\"\nimport { useRef } from \"react\"\n\nconst useAutosize = (\n  ref: RefObject<HTMLTextAreaElement>,\n  maxRows: number,\n  minRows: number,\n) => {\n  const valueRef = useRef<string>()\n\n  const resizeTextarea = () => {\n    const el = ref.current\n    if (!el) return\n\n    let { value, placeholder } = el\n    if (value === valueRef.current) return\n    else valueRef.current = value\n\n    value ??= placeholder ?? \"x\"\n\n    const nodeSizeData = getSizingData(el)\n\n    if (!nodeSizeData) return\n\n    const rows = calcRows(el, nodeSizeData, value, maxRows, minRows)\n\n    el.rows = rows\n  }\n\n  return resizeTextarea\n}\n\nconst SIZING_STYLE = [\n  \"borderBottomWidth\",\n  \"borderLeftWidth\",\n  \"borderRightWidth\",\n  \"borderTopWidth\",\n  \"boxSizing\",\n  \"fontFamily\",\n  \"fontSize\",\n  \"fontStyle\",\n  \"fontWeight\",\n  \"letterSpacing\",\n  \"lineHeight\",\n  \"paddingBottom\",\n  \"paddingLeft\",\n  \"paddingRight\",\n  \"paddingTop\",\n  // non-standard\n  \"tabSize\",\n  \"textIndent\",\n  // non-standard\n  \"textRendering\",\n  \"textTransform\",\n  \"width\",\n  \"wordBreak\",\n] as const\n\ntype SizingProps = Extract<\n  (typeof SIZING_STYLE)[number],\n  keyof CSSStyleDeclaration\n>\n\ntype SizingStyle = Pick<CSSStyleDeclaration, SizingProps>\n\ntype SizingData = {\n  sizingStyle: SizingStyle\n  paddingSize: number\n  borderSize: number\n  singleRowHeight: number\n}\n\nconst getSizingData = (el: HTMLElement): SizingData | null => {\n  const style = window?.getComputedStyle(el)\n\n  if (style == null) return null\n\n  const sizingStyle = pickObject(\n    style,\n    SIZING_STYLE as unknown as SizingProps[],\n  )\n  const { boxSizing } = sizingStyle\n\n  if (boxSizing === \"\") return null\n\n  const paddingSize =\n    parseFloat(sizingStyle.paddingBottom!) + parseFloat(sizingStyle.paddingTop!)\n\n  const borderSize =\n    parseFloat(sizingStyle.borderBottomWidth!) +\n    parseFloat(sizingStyle.borderTopWidth!)\n\n  const singleRowHeight = parseFloat(sizingStyle.lineHeight!)\n\n  return {\n    sizingStyle,\n    paddingSize,\n    borderSize,\n    singleRowHeight,\n  }\n}\n\nconst calcRows = (\n  el: HTMLTextAreaElement,\n  sizingData: SizingData,\n  value: string,\n  maxRows: number,\n  minRows: number,\n) => {\n  const clone = el.cloneNode() as HTMLTextAreaElement\n  Object.assign(clone.style, sizingData.sizingStyle)\n  forceHiddenStyles(clone)\n\n  clone.value = value\n  document.body.appendChild(clone)\n\n  let rows\n  if (clone.scrollHeight) {\n    const rowHeight = sizingData.singleRowHeight\n    rows = Math.min(\n      maxRows,\n      Math.max(minRows, Math.floor(clone.scrollHeight / rowHeight)),\n    )\n  } else {\n    const lineBreaks = (value.match(/\\n/g) || []).length\n    rows = Math.min(maxRows, Math.max(minRows, lineBreaks + 1))\n  }\n\n  document.body.removeChild(clone)\n\n  return rows\n}\n\nconst HIDDEN_TEXTAREA_STYLE = {\n  \"min-height\": \"0\",\n  \"max-height\": \"none\",\n  height: \"0\",\n  visibility: \"hidden\",\n  overflow: \"hidden\",\n  position: \"absolute\",\n  \"z-index\": \"-1000\",\n  top: \"0\",\n  right: \"0\",\n} as const\n\nconst forceHiddenStyles = (el: HTMLElement) => {\n  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach((key) => {\n    el.style.setProperty(\n      key,\n      HIDDEN_TEXTAREA_STYLE[key as keyof typeof HIDDEN_TEXTAREA_STYLE],\n      \"important\",\n    )\n  })\n}\n\nexport default useAutosize\n"],"mappings":"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","names":["import_utils","import_react"]}