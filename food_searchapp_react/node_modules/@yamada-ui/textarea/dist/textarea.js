"use client"
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/textarea.tsx
var textarea_exports = {};
__export(textarea_exports, {
  Textarea: () => Textarea
});
module.exports = __toCommonJS(textarea_exports);
var import_core = require("@yamada-ui/core");
var import_form_control = require("@yamada-ui/form-control");
var import_utils2 = require("@yamada-ui/utils");
var import_react2 = require("react");

// src/use-autosize.ts
var import_utils = require("@yamada-ui/utils");
var import_react = require("react");
var useAutosize = (ref, maxRows, minRows) => {
  const valueRef = (0, import_react.useRef)();
  const resizeTextarea = () => {
    const el = ref.current;
    if (!el)
      return;
    let { value, placeholder } = el;
    if (value === valueRef.current)
      return;
    else
      valueRef.current = value;
    value != null ? value : value = placeholder != null ? placeholder : "x";
    const nodeSizeData = getSizingData(el);
    if (!nodeSizeData)
      return;
    const rows = calcRows(el, nodeSizeData, value, maxRows, minRows);
    el.rows = rows;
  };
  return resizeTextarea;
};
var SIZING_STYLE = [
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRightWidth",
  "borderTopWidth",
  "boxSizing",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "paddingBottom",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  // non-standard
  "tabSize",
  "textIndent",
  // non-standard
  "textRendering",
  "textTransform",
  "width",
  "wordBreak"
];
var getSizingData = (el) => {
  const style = window == null ? void 0 : window.getComputedStyle(el);
  if (style == null)
    return null;
  const sizingStyle = (0, import_utils.pickObject)(
    style,
    SIZING_STYLE
  );
  const { boxSizing } = sizingStyle;
  if (boxSizing === "")
    return null;
  const paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop);
  const borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);
  const singleRowHeight = parseFloat(sizingStyle.lineHeight);
  return {
    sizingStyle,
    paddingSize,
    borderSize,
    singleRowHeight
  };
};
var calcRows = (el, sizingData, value, maxRows, minRows) => {
  const clone = el.cloneNode();
  Object.assign(clone.style, sizingData.sizingStyle);
  forceHiddenStyles(clone);
  clone.value = value;
  document.body.appendChild(clone);
  let rows;
  if (clone.scrollHeight) {
    const rowHeight = sizingData.singleRowHeight;
    rows = Math.min(
      maxRows,
      Math.max(minRows, Math.floor(clone.scrollHeight / rowHeight))
    );
  } else {
    const lineBreaks = (value.match(/\n/g) || []).length;
    rows = Math.min(maxRows, Math.max(minRows, lineBreaks + 1));
  }
  document.body.removeChild(clone);
  return rows;
};
var HIDDEN_TEXTAREA_STYLE = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0"
};
var forceHiddenStyles = (el) => {
  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach((key) => {
    el.style.setProperty(
      key,
      HIDDEN_TEXTAREA_STYLE[key],
      "important"
    );
  });
};
var use_autosize_default = useAutosize;

// src/textarea.tsx
var import_jsx_runtime = require("react/jsx-runtime");
var Textarea = (0, import_core.forwardRef)((props, ref) => {
  var _a, _b;
  const [
    { h, height, minH, minHeight, maxH, maxHeight, ...styles },
    mergedProps
  ] = (0, import_core.useComponentStyle)("Textarea", props);
  let {
    className,
    rows,
    resize = "none",
    autosize,
    maxRows = Infinity,
    minRows = 1,
    resizeRef,
    onChange,
    ...rest
  } = (0, import_core.omitThemeProps)(mergedProps);
  rest = (0, import_form_control.useFormControlProps)(rest);
  const isBrowser = (0, import_utils2.createdDom)();
  const textareaRef = (0, import_react2.useRef)(null);
  const value = (_b = (_a = textareaRef.current) == null ? void 0 : _a.value) != null ? _b : "";
  const resizeTextarea = use_autosize_default(textareaRef, maxRows, minRows);
  let css;
  if (rows || autosize) {
    css = styles;
  } else {
    css = { h, height, minH, minHeight, maxH, maxHeight, ...styles };
  }
  (0, import_utils2.useSafeLayoutEffect)(() => {
    if (!isBrowser || !autosize)
      return;
    resizeTextarea();
    const unsubscribeResize = (0, import_utils2.addDomEvent)(window, "resize", resizeTextarea);
    const unsubscribeLoadingdone = (0, import_utils2.addDomEvent)(
      document.fonts,
      "loadingdone",
      resizeTextarea
    );
    return () => {
      unsubscribeResize();
      unsubscribeLoadingdone();
    };
  }, []);
  (0, import_utils2.useUpdateEffect)(() => {
    if (!autosize)
      return;
    resizeTextarea();
  }, [value]);
  (0, import_utils2.assignRef)(resizeRef, resizeTextarea);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_core.ui.textarea,
    {
      ref: (0, import_utils2.mergeRefs)(ref, textareaRef),
      className: (0, import_utils2.cx)("ui-textarea", className),
      __css: css,
      resize,
      rows,
      onChange: (0, import_utils2.handlerAll)(autosize ? resizeTextarea : import_utils2.noop, onChange),
      ...rest
    }
  );
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Textarea
});
//# sourceMappingURL=textarea.js.map