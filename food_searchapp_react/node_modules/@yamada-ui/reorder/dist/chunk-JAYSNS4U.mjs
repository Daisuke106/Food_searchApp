"use client"

// src/reorder.tsx
import { ui, useMultiComponentStyle, omitThemeProps } from "@yamada-ui/core";
import { MotionReorder } from "@yamada-ui/motion";
import {
  createContext,
  cx,
  getValidChildren,
  handlerAll,
  useUpdateEffect
} from "@yamada-ui/utils";
import { forwardRef, useCallback, useMemo, useRef, useState } from "react";
import { jsx } from "react/jsx-runtime";
var [ReorderProvider, useReorderContext] = createContext({
  name: "ReorderContext",
  errorMessage: `useReorderContext returned is 'undefined'. Seems you forgot to wrap the components in "<Reorder />"`
});
var omitDuplicated = (values) => Array.from(new Set(values));
var pickDuplicated = (values) => values.filter(
  (value, index, self) => self.indexOf(value) === index && index !== self.lastIndexOf(value)
);
var Reorder = forwardRef(
  (props, ref) => {
    const [styles, mergedProps] = useMultiComponentStyle("Reorder", props);
    const {
      className,
      orientation = "vertical",
      gap = "fallback(4, 1rem)",
      onChange,
      onCompleteChange,
      children,
      ...rest
    } = omitThemeProps(mergedProps);
    const axis = orientation === "vertical" ? "y" : "x";
    const validChildren = getValidChildren(children);
    const defaultValues = useMemo(() => {
      const values2 = validChildren.map(({ props: props2 }) => props2.label);
      const duplicatedValues = pickDuplicated(values2);
      if (duplicatedValues.length)
        console.warn(
          `Reorder: 'label' of 'ReorderItem' must not be duplicated. duplicate 'label' is '${duplicatedValues.join(
            `', '`
          )}' `
        );
      return omitDuplicated(values2);
    }, [validChildren]);
    const prevDefaultValues = useRef(defaultValues);
    const [values, setValues] = useState(defaultValues);
    const prevValues = useRef(defaultValues);
    const onReorder = useCallback(
      (newValues) => {
        setValues(newValues);
        onChange == null ? void 0 : onChange(newValues);
      },
      [onChange]
    );
    const onCompleteReorder = useCallback(() => {
      const isEqual = JSON.stringify(prevValues.current) === JSON.stringify(values);
      if (isEqual)
        return;
      prevValues.current = values;
      onCompleteChange == null ? void 0 : onCompleteChange(values);
    }, [onCompleteChange, values]);
    useUpdateEffect(() => {
      const isEqual = JSON.stringify(defaultValues) === JSON.stringify(prevDefaultValues.current);
      if (isEqual)
        return;
      prevValues.current = defaultValues;
      prevDefaultValues.current = defaultValues;
      setValues(defaultValues);
    }, [defaultValues]);
    const cloneChildren = useMemo(
      () => values.map(
        (value) => validChildren.find(({ props: props2 }) => props2.label === value)
      ),
      [values, validChildren]
    );
    const css = {
      display: "flex",
      flexDirection: orientation === "vertical" ? "column" : "row",
      gap,
      ...styles.container
    };
    return /* @__PURE__ */ jsx(ReorderProvider, { value: { orientation, styles }, children: /* @__PURE__ */ jsx(
      ui.ul,
      {
        ref,
        as: MotionReorder.Group,
        className: cx("ui-reorder", className),
        axis,
        values,
        onReorder,
        __css: css,
        ...rest,
        onMouseUp: handlerAll(rest.onMouseUp, onCompleteReorder),
        onTouchEnd: handlerAll(rest.onTouchEnd, onCompleteReorder),
        children: cloneChildren
      }
    ) });
  }
);
Reorder.displayName = "Reorder";

export {
  ReorderProvider,
  useReorderContext,
  Reorder
};
//# sourceMappingURL=chunk-JAYSNS4U.mjs.map