"use client"
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/segmented-control.tsx
var segmented_control_exports = {};
__export(segmented_control_exports, {
  SegmentedControl: () => SegmentedControl,
  SegmentedControlButton: () => SegmentedControlButton
});
module.exports = __toCommonJS(segmented_control_exports);
var import_core = require("@yamada-ui/core");
var import_motion = require("@yamada-ui/motion");
var import_use_controllable_state = require("@yamada-ui/use-controllable-state");
var import_use_descendant = require("@yamada-ui/use-descendant");
var import_use_focus_visible = require("@yamada-ui/use-focus-visible");
var import_utils = require("@yamada-ui/utils");
var import_react = require("react");
var import_jsx_runtime = require("react/jsx-runtime");
var { DescendantsContextProvider, useDescendants, useDescendant } = (0, import_use_descendant.createDescendant)();
var [SegmentedControlProvider, useSegmentedControl] = (0, import_utils.createContext)({
  strict: false,
  name: "SegmentedControlContext"
});
var SegmentedControl = (0, import_core.forwardRef)(
  (props, ref) => {
    const [styles, mergedProps] = (0, import_core.useMultiComponentStyle)(
      "SegmentedControl",
      props
    );
    let {
      className,
      id,
      name,
      isReadOnly,
      isDisabled,
      children,
      items = [],
      value,
      defaultValue,
      onChange: onChangeProp,
      ...rest
    } = (0, import_core.omitThemeProps)(mergedProps);
    id != null ? id : id = (0, import_react.useId)();
    name != null ? name : name = `segmented-control-${(0, import_react.useId)()}`;
    const onChangeRef = (0, import_utils.useCallbackRef)(onChangeProp);
    const descendants = useDescendants();
    const [focusedIndex, setFocusedIndex] = (0, import_react.useState)(-1);
    const [isFocusVisible, setIsFocusVisible] = (0, import_react.useState)(false);
    const containerRef = (0, import_react.useRef)(null);
    const [selectedValue, setSelectedValue] = (0, import_use_controllable_state.useControllableState)({
      value,
      defaultValue,
      onChange: onChangeRef
    });
    const onChange = (0, import_react.useCallback)(
      (ev) => {
        if (isDisabled || isReadOnly) {
          ev.preventDefault();
          return;
        }
        setSelectedValue(ev.target.value);
      },
      [isDisabled, isReadOnly, setSelectedValue]
    );
    const onFocus = (0, import_react.useCallback)(
      (index, skip) => {
        if (isDisabled)
          return;
        if (skip) {
          const next = descendants.enabledNextValue(index);
          if (next)
            setFocusedIndex(next.index);
        } else {
          setFocusedIndex(index);
        }
      },
      [descendants, isDisabled]
    );
    const onBlur = (0, import_react.useCallback)(() => setFocusedIndex(-1), []);
    const getContainerProps = (0, import_react.useCallback)(
      (props2 = {}, ref2 = null) => ({
        ...rest,
        ...props2,
        ref: (0, import_utils.mergeRefs)(containerRef, ref2),
        id,
        "aria-disabled": (0, import_utils.ariaAttr)(isDisabled),
        "data-readonly": (0, import_utils.dataAttr)(isReadOnly),
        onBlur: (0, import_utils.handlerAll)(props2.onBlur, onBlur)
      }),
      [id, isDisabled, isReadOnly, onBlur, rest]
    );
    const getInputProps = (0, import_react.useCallback)(
      ({
        index,
        isDisabled: isDisabledProp,
        isReadOnly: isReadOnlyProp,
        ...props2
      }, ref2 = null) => {
        var _a, _b, _c, _d;
        const disabled = (_b = (_a = props2.disabled) != null ? _a : isDisabledProp) != null ? _b : isDisabled;
        const readOnly = (_d = (_c = props2.readOnly) != null ? _c : isReadOnlyProp) != null ? _d : isReadOnly;
        const checked = props2.value === selectedValue;
        return {
          ...props2,
          ref: ref2,
          id: `${id}-${index}`,
          type: "radio",
          name,
          disabled: disabled || readOnly,
          readOnly,
          checked,
          "aria-disabled": (0, import_utils.ariaAttr)(disabled),
          "data-readonly": (0, import_utils.dataAttr)(readOnly),
          "data-checked": (0, import_utils.dataAttr)(checked),
          "data-focus": (0, import_utils.dataAttr)(index === focusedIndex),
          style: {
            border: "0px",
            clip: "rect(0px, 0px, 0px, 0px)",
            height: "1px",
            width: "1px",
            margin: "-1px",
            padding: "0px",
            overflow: "hidden",
            whiteSpace: "nowrap",
            position: "absolute"
          },
          onChange: (0, import_utils.handlerAll)(
            props2.onChange,
            (ev) => !disabled && !readOnly ? onChange(ev) : {}
          )
        };
      },
      [isDisabled, isReadOnly, selectedValue, id, name, focusedIndex, onChange]
    );
    const getLabelProps = (0, import_react.useCallback)(
      ({
        index,
        isDisabled: isDisabledProp,
        isReadOnly: isReadOnlyProp,
        ...props2
      }, ref2 = null) => {
        var _a, _b, _c, _d;
        const disabled = (_b = (_a = props2.disabled) != null ? _a : isDisabledProp) != null ? _b : isDisabled;
        const readOnly = (_d = (_c = props2.readOnly) != null ? _c : isReadOnlyProp) != null ? _d : isReadOnly;
        const checked = props2.value === selectedValue;
        const focused = index === focusedIndex;
        return {
          ...props2,
          ref: ref2,
          "aria-disabled": (0, import_utils.ariaAttr)(disabled),
          "data-readonly": (0, import_utils.dataAttr)(readOnly),
          "data-checked": (0, import_utils.dataAttr)(checked),
          "data-focus": (0, import_utils.dataAttr)(focused),
          "data-focus-visible": (0, import_utils.dataAttr)(focused && isFocusVisible),
          onFocus: (0, import_utils.handlerAll)(
            props2.onFocus,
            () => onFocus(index, disabled || readOnly || false)
          ),
          ...disabled || readOnly ? {
            _hover: {},
            _active: {},
            _focus: {},
            _invalid: {},
            _focusVisible: {}
          } : {}
        };
      },
      [
        focusedIndex,
        isDisabled,
        isFocusVisible,
        isReadOnly,
        onFocus,
        selectedValue
      ]
    );
    (0, import_react.useEffect)(() => {
      return (0, import_use_focus_visible.trackFocusVisible)(setIsFocusVisible);
    }, []);
    const css = {
      display: "inline-flex",
      alignItems: "center",
      ...styles.container
    };
    const validChildren = (0, import_utils.getValidChildren)(children);
    let computedChildren = [];
    if (!validChildren.length && items.length) {
      computedChildren = items.map(({ label, value: value2, ...props2 }, i) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SegmentedControlButton, { value: value2, ...props2, children: label }, i));
    } else {
      computedChildren = validChildren;
    }
    if (selectedValue == null && defaultValue == null) {
      for (const child of computedChildren) {
        if (child.type !== SegmentedControlButton) {
          if (child.type.displayName !== SegmentedControlButton.displayName)
            continue;
        }
        const value2 = child.props.value;
        setSelectedValue(value2);
        break;
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DescendantsContextProvider, { value: descendants, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      SegmentedControlProvider,
      {
        value: { getInputProps, getLabelProps, styles, selectedValue },
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_motion.LayoutGroup, { id, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          import_core.ui.div,
          {
            ...getContainerProps({}, ref),
            className: (0, import_utils.cx)("ui-segmented-control", className),
            __css: css,
            children: computedChildren
          }
        ) })
      }
    ) });
  }
);
var SegmentedControlButton = (0, import_core.forwardRef)(
  ({
    className,
    disabled,
    readOnly,
    isDisabled,
    isReadOnly,
    value,
    onChange,
    children,
    motionProps,
    ...rest
  }, ref) => {
    const [, isMounted] = (0, import_utils.useIsMounted)({ rerender: true });
    const { selectedValue, getInputProps, getLabelProps, styles } = useSegmentedControl();
    const { index, register } = useDescendant({
      disabled: isDisabled || isReadOnly
    });
    const props = {
      index,
      value,
      disabled,
      readOnly,
      isDisabled,
      isReadOnly
    };
    const css = {
      position: "relative",
      cursor: "pointer",
      flex: "1 1 0%",
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      ...styles.button
    };
    const isSelected = selectedValue === value;
    return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
      import_core.ui.label,
      {
        ...getLabelProps(props),
        className: (0, import_utils.cx)("ui-segmented-control__button", className),
        __css: css,
        ...rest,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            import_core.ui.input,
            {
              ...getInputProps({ onChange, ...props }, (0, import_utils.mergeRefs)(register, ref))
            }
          ),
          isSelected && isMounted ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SegmentedControlCursor, { ...motionProps }) : null,
          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_core.ui.span, { zIndex: "1", children })
        ]
      }
    );
  }
);
SegmentedControlButton.displayName = "SegmentedControlButton";
var SegmentedControlCursor = ({
  className,
  transition,
  ...rest
}) => {
  const { styles } = useSegmentedControl();
  const css = {
    position: "absolute",
    w: "100%",
    h: "100%",
    ...styles.cursor
  };
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_motion.Motion,
    {
      className: (0, import_utils.cx)("ui-segmented-control__cursor", className),
      layoutDependency: false,
      layoutId: "cursor",
      transition: {
        type: "spring",
        bounce: 0.15,
        duration: 0.4,
        ...transition
      },
      __css: css,
      ...rest
    }
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SegmentedControl,
  SegmentedControlButton
});
//# sourceMappingURL=segmented-control.js.map