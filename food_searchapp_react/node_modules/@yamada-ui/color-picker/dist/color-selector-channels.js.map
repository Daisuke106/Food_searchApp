{"version":3,"sources":["../src/color-selector-channels.tsx","../src/use-color-selector.ts"],"sourcesContent":["import { forwardRef, ui } from \"@yamada-ui/core\"\nimport type { CSSUIObject, HTMLUIProps } from \"@yamada-ui/core\"\nimport { Input } from \"@yamada-ui/input\"\nimport type { InputProps } from \"@yamada-ui/input\"\nimport { cx } from \"@yamada-ui/utils\"\nimport { useId, type ReactNode } from \"react\"\nimport { useColorSelectorContext } from \"./use-color-selector\"\n\ntype ColorSelectorChannelsOptions = {\n  /**\n   * Props for the chancel component.\n   */\n  channelProps?: Omit<ColorSelectorChannelProps, \"channelLabel\">\n}\n\nexport type ColorSelectorChannelsProps = Omit<HTMLUIProps<\"div\">, \"children\"> &\n  ColorSelectorChannelsOptions\n\nexport const ColorSelectorChannels = forwardRef<\n  ColorSelectorChannelsProps,\n  \"div\"\n>(({ className, channelProps, ...rest }, ref) => {\n  const { withAlpha, channels, getChannelProps, styles } =\n    useColorSelectorContext()\n\n  const css: CSSUIObject = {\n    display: \"grid\",\n    gridTemplateColumns: `repeat(${withAlpha ? \"4\" : \"3\"}, 1fr)`,\n    ...styles.channels,\n  }\n\n  return (\n    <ui.div\n      ref={ref}\n      className={cx(\"ui-color-selector__channels\", className)}\n      __css={css}\n      {...rest}\n    >\n      {channels.map(({ label, space, value, min, max }) => (\n        <ColorSelectorChannel\n          key={label}\n          channelLabel={label}\n          {...getChannelProps({ ...channelProps, space, value, min, max })}\n        />\n      ))}\n    </ui.div>\n  )\n})\n\ntype ColorSelectorChannelOptions = {\n  channelLabel?: ReactNode\n}\n\nexport type ColorSelectorChannelProps = Omit<\n  InputProps,\n  \"type\" | \"pattern\" | \"min\" | \"max\" | \"value\" | \"defaultValue\"\n> &\n  ColorSelectorChannelOptions\n\nexport const ColorSelectorChannel = forwardRef<\n  ColorSelectorChannelProps,\n  \"input\"\n>(({ className, channelLabel, ...rest }, ref) => {\n  const id = useId()\n  let { size, disabled, readOnly, styles } = useColorSelectorContext()\n\n  if (size === \"full\") size = \"lg\"\n\n  const css: CSSUIObject = { ...styles.channel }\n\n  return (\n    <ui.div className={cx(\"ui-color-selector__channel\", className)}>\n      {channelLabel ? (\n        <ui.label\n          htmlFor={id}\n          style={{ cursor: disabled ? \"not-allowed\" : undefined }}\n          __css={{\n            display: \"block\",\n            pointerEvents: readOnly ? \"none\" : undefined,\n            ...styles.channelLabel,\n          }}\n        >\n          {channelLabel}\n        </ui.label>\n      ) : null}\n\n      <Input ref={ref} id={id} size={size} __css={css} {...rest} />\n    </ui.div>\n  )\n})\n","import type {\n  CSSUIObject,\n  HTMLUIProps,\n  UIPropGetter,\n  ThemeProps,\n  RequiredUIPropGetter,\n} from \"@yamada-ui/core\"\nimport {\n  useFormControlProps,\n  type FormControlOptions,\n  formControlProperties,\n} from \"@yamada-ui/form-control\"\nimport type { InputProps } from \"@yamada-ui/input\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { useEyeDropper } from \"@yamada-ui/use-eye-dropper\"\nimport type { ColorFormat, Dict, Merge } from \"@yamada-ui/utils\"\nimport {\n  calcFormat,\n  convertColor,\n  createContext,\n  handlerAll,\n  hsvTo,\n  isString,\n  parseToHsv,\n  useCallbackRef,\n  useUpdateEffect,\n  omitObject,\n  parseToRgba,\n  parseToHsla,\n  rgbaTo,\n  hslaTo,\n  pickObject,\n} from \"@yamada-ui/utils\"\nimport type { ChangeEvent } from \"react\"\nimport { useCallback, useMemo, useRef, useState } from \"react\"\nimport type { AlphaSliderProps } from \"./alpha-slider\"\nimport type { ColorSwatchProps } from \"./color-swatch\"\nimport type { HueSliderProps } from \"./hue-slider\"\nimport type { SaturationSliderProps } from \"./saturation-slider\"\n\ntype Space = keyof Hsla | keyof Rgba\ntype Hsla = { h: number; s: number; l: number; a: number }\ntype Rgba = { r: number; g: number; b: number; a: number }\ntype Hsva = { h: number; s: number; v: number; a: number }\ntype Channel = {\n  label: string\n  space: Space\n  value: number\n  min: number\n  max: number\n}\n\nconst convertHsla = (value: string, fallback?: string): Hsla => {\n  let [h, s, l, a] = parseToHsla(value, fallback) ?? [0, 0, 1, 1]\n\n  if (a > 1) a = 1\n\n  return { h, s, l, a }\n}\n\nconst convertRgba = (value: string, fallback?: string): Rgba => {\n  let [r, g, b, a] = parseToRgba(value, fallback) ?? [255, 255, 255, 1]\n\n  if (r > 255) r = 255\n  if (g > 255) g = 255\n  if (b > 255) b = 255\n  if (a > 1) a = 1\n\n  return { r, g, b, a }\n}\n\nconst convertHsva = (value: string, fallback?: string): Hsva => {\n  const [h, s, v, a] = parseToHsv(value, fallback)\n\n  return { h, s, v, a }\n}\n\ntype ColorSelectorContext = {\n  value: string\n  onChange: (value: string | Partial<Hsva>) => void\n  eyeDropperSupported: boolean\n  withAlpha: boolean\n  isInteractive: boolean\n  disabled?: boolean\n  readOnly?: boolean\n  channels: Channel[]\n  size?: ThemeProps<\"ColorSelector\">[\"size\"]\n  getHueSliderProps: UIPropGetter<\"input\", HueSliderProps, HueSliderProps>\n  getAlphaSliderProps: UIPropGetter<\"input\", AlphaSliderProps, AlphaSliderProps>\n  getEyeDropperProps: UIPropGetter<\"button\">\n  getChannelProps: RequiredUIPropGetter<\n    \"input\",\n    Merge<InputProps, { space: Space }>,\n    InputProps\n  >\n  getSwatchProps: UIPropGetter<\"div\", ColorSwatchProps, ColorSwatchProps>\n  styles: Record<string, CSSUIObject>\n}\n\nexport const [ColorSelectorProvider, useColorSelectorContext] =\n  createContext<ColorSelectorContext>({\n    name: \"ColorSelectorContext\",\n    errorMessage: `useColorSelectorContext returned is 'undefined'. Seems you forgot to wrap the components in \"<ColorSelector />\"`,\n  })\n\ntype UseColorSelectorOptions = {\n  /**\n   * The base `id` to use for the color selector.\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms.\n   */\n  name?: string\n  /**\n   * The value of the color selector.\n   */\n  value?: string\n  /**\n   * The initial value of the color selector.\n   */\n  defaultValue?: string\n  /**\n   * The fallback value returned when color determination fails.\n   */\n  fallbackValue?: string\n  /**\n   * Function called whenever the color selector value changes.\n   */\n  onChange?: (value: string) => void\n  /**\n   * Function called when the user starts selecting a new value.\n   */\n  onChangeStart?: (value: string) => void\n  /**\n   * Function called when the user is done selecting a new value.\n   */\n  onChangeEnd?: (value: string) => void\n  /**\n   * Color format. For example, `hex`, `rgba`, etc.\n   *\n   * @default \"hexa\"\n   */\n  format?: ColorFormat\n  /**\n   * Function called whenever the color swatch click.\n   */\n  onSwatchClick?: (value: string) => void\n}\n\nexport type UseColorSelectorBaseProps = UseColorSelectorOptions &\n  FormControlOptions\n\nexport type UseColorSelectorProps = Omit<\n  HTMLUIProps<\"div\">,\n  \"defaultValue\" | \"onChange\" | \"children\"\n> &\n  UseColorSelectorBaseProps\n\nexport const useColorSelector = ({\n  isInvalid,\n  ...props\n}: UseColorSelectorProps) => {\n  let {\n    id,\n    name,\n    value: valueProp,\n    defaultValue,\n    fallbackValue,\n    onChange: onChangeProp,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    format,\n    required,\n    disabled,\n    readOnly,\n    onSwatchClick,\n    ...rest\n  } = useFormControlProps({ isInvalid, ...props })\n\n  const onChangeStartRef = useCallbackRef(onChangeStartProp)\n  const onChangeEndRef = useCallbackRef(onChangeEndProp)\n  const { supported: eyeDropperSupported, onOpen } = useEyeDropper()\n  const [value, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? fallbackValue,\n    onChange: onChangeProp,\n  })\n  const resolvedValue = value ?? \"#ffffff\"\n  const timeoutId = useRef<any>(undefined)\n  const formatRef = useRef<ColorFormat>(format ?? calcFormat(resolvedValue))\n  const isDraggingRef = useRef<boolean>(false)\n  const [parsedValue, setParsedValue] = useState<Hsva>(\n    convertHsva(resolvedValue, fallbackValue),\n  )\n  const { h, s, v, a } = parsedValue\n  const withAlpha = formatRef.current.endsWith(\"a\")\n  const isInteractive = !(disabled || readOnly)\n\n  const channels: Channel[] = useMemo(() => {\n    if (resolvedValue.startsWith(\"hsl\")) {\n      const { h, s, l, a } = convertHsla(resolvedValue, fallbackValue)\n\n      let channels: Channel[] = [\n        { label: \"H\", space: \"h\", value: Math.round(h), min: 0, max: 360 },\n        {\n          label: \"S(%)\",\n          space: \"s\",\n          value: Math.round(s * 100),\n          min: 0,\n          max: 100,\n        },\n        {\n          label: \"L(%)\",\n          space: \"l\",\n          value: Math.round(l * 100),\n          min: 0,\n          max: 100,\n        },\n      ]\n\n      if (withAlpha) {\n        channels = [\n          ...channels,\n          {\n            label: \"A(%)\",\n            space: \"a\",\n            value: Math.round(a * 100),\n            min: 0,\n            max: 100,\n          },\n        ]\n      }\n\n      return channels\n    } else {\n      const { r, g, b, a } = convertRgba(resolvedValue, fallbackValue)\n\n      let channels: Channel[] = [\n        { label: \"R\", space: \"r\", value: Math.round(r), min: 0, max: 255 },\n        { label: \"G\", space: \"g\", value: Math.round(g), min: 0, max: 255 },\n        { label: \"B\", space: \"b\", value: Math.round(b), min: 0, max: 255 },\n      ]\n\n      if (withAlpha) {\n        channels = [\n          ...channels,\n          {\n            label: \"A(%)\",\n            space: \"a\",\n            value: Math.round(a * 100),\n            min: 0,\n            max: 100,\n          },\n        ]\n      }\n\n      return channels\n    }\n  }, [resolvedValue, withAlpha, fallbackValue])\n\n  const onChange = useCallback(\n    (value: string | Partial<Hsva>) => {\n      if (isString(value)) {\n        setParsedValue(convertHsva(value, fallbackValue))\n      } else {\n        setParsedValue((prev) => ({ ...prev, ...value }))\n      }\n    },\n    [fallbackValue],\n  )\n\n  const onChangeStart = useCallback(\n    (value: Partial<Hsva>) => {\n      window.clearTimeout(timeoutId.current)\n\n      isDraggingRef.current = true\n\n      const { h, s, v, a } = { ...parsedValue, ...value }\n\n      const nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n\n      if (nextValue) onChangeStartRef(nextValue)\n    },\n    [formatRef, onChangeStartRef, fallbackValue, parsedValue],\n  )\n\n  const onChangeEnd = useCallback(\n    (value: string | Partial<Hsva>) => {\n      window.clearTimeout(timeoutId.current)\n\n      timeoutId.current = window.setTimeout(() => {\n        isDraggingRef.current = false\n      }, 200)\n\n      let nextValue: string | undefined\n\n      if (isString(value)) {\n        nextValue = convertColor(value, fallbackValue)(formatRef.current)\n      } else {\n        const { h, s, v, a } = { ...parsedValue, ...value }\n\n        nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n      }\n\n      if (nextValue) onChangeEndRef(nextValue)\n    },\n    [formatRef, onChangeEndRef, fallbackValue, parsedValue],\n  )\n\n  const onChannelChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>, space: Space) => {\n      let n = Math.floor(parseFloat(ev.target.value))\n\n      if (isNaN(n)) n = 0\n\n      if ([\"s\", \"l\", \"a\"].includes(space)) n = n / 100\n\n      let nextValue: string | undefined\n\n      if (resolvedValue.startsWith(\"hsl\")) {\n        const { h, s, l, a } = Object.assign(\n          convertHsla(resolvedValue, fallbackValue),\n          { [space]: n },\n        )\n\n        nextValue = hslaTo([h, s, l, a], fallbackValue)(formatRef.current)\n      } else {\n        const { r, g, b, a } = Object.assign(\n          convertRgba(resolvedValue, fallbackValue),\n          { [space]: n },\n        )\n\n        nextValue = rgbaTo([r, g, b, a], fallbackValue)(formatRef.current)\n      }\n\n      if (!nextValue) return\n\n      onChange(nextValue)\n      onChangeEnd(nextValue)\n    },\n    [resolvedValue, onChange, onChangeEnd, formatRef, fallbackValue],\n  )\n\n  const onEyeDropperClick = useCallback(async () => {\n    try {\n      const { sRGBHex } = (await onOpen()) ?? {}\n\n      if (!sRGBHex) return\n\n      onChange(sRGBHex)\n      onChangeEnd(sRGBHex)\n    } catch {}\n  }, [onOpen, onChange, onChangeEnd])\n\n  useUpdateEffect(() => {\n    const nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n\n    if (nextValue) setValue(nextValue)\n  }, [h, s, v, a])\n\n  useUpdateEffect(() => {\n    if (isDraggingRef.current) return\n\n    if (valueProp) setParsedValue(convertHsva(valueProp, fallbackValue))\n  }, [valueProp])\n\n  useUpdateEffect(() => {\n    if (!format || !value) return\n\n    formatRef.current = format\n\n    const nextValue = convertColor(value, fallbackValue)(format)\n\n    if (nextValue) setValue(nextValue)\n  }, [format])\n\n  const getContainerProps: UIPropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ref,\n    ...omitObject(rest, [\"aria-readonly\"]),\n  })\n\n  const getInputProps: UIPropGetter<\"input\"> = useCallback(\n    (props = {}, ref = null) => ({\n      ...pickObject(rest, formControlProperties),\n      ...props,\n      id,\n      ref,\n      type: \"hidden\",\n      name,\n      value: resolvedValue,\n      required,\n      disabled,\n      readOnly,\n    }),\n    [disabled, id, name, readOnly, required, rest, resolvedValue],\n  )\n\n  const getSaturationSliderProps: UIPropGetter<\n    \"input\",\n    SaturationSliderProps,\n    SaturationSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: [h, s, v],\n      onChange: handlerAll(props.onChange, ([, s, v]) => onChange({ s, v })),\n      onChangeStart: handlerAll(props.onChangeStart, ([, s, v]) =>\n        onChangeStart({ s, v }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, ([, s, v]) =>\n        onChangeEnd({ s, v }),\n      ),\n    }),\n    [\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      h,\n      s,\n      v,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getHueSliderProps: UIPropGetter<\n    \"input\",\n    HueSliderProps,\n    HueSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: h,\n      onChange: handlerAll(props.onChange, (h) => onChange({ h })),\n      onChangeStart: handlerAll(props.onChangeStart, (h) =>\n        onChangeStart({ h }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, (h) => onChangeEnd({ h })),\n    }),\n    [\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      h,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getAlphaSliderProps: UIPropGetter<\n    \"input\",\n    AlphaSliderProps,\n    AlphaSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: a,\n      color: hsvTo([h, s, v, a], fallbackValue)(formatRef.current),\n      onChange: handlerAll(props.onChange, (a) => onChange({ a })),\n      onChangeStart: handlerAll(props.onChangeStart, (a) =>\n        onChangeStart({ a }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, (a) => onChangeEnd({ a })),\n    }),\n    [\n      fallbackValue,\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      formatRef,\n      h,\n      s,\n      v,\n      a,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getChannelProps: RequiredUIPropGetter<\n    \"input\",\n    Merge<InputProps, { space: Space }>,\n    InputProps\n  > = useCallback(\n    ({ space, ...props }, ref = null) => {\n      return {\n        required,\n        disabled,\n        readOnly,\n        isInvalid,\n        ...props,\n        ref,\n        type: \"number\",\n        step: 1,\n        onChange: handlerAll(props.onChange, (ev) =>\n          onChannelChange(ev, space),\n        ),\n      } as Dict\n    },\n    [required, disabled, readOnly, isInvalid, onChannelChange],\n  )\n\n  const getEyeDropperProps: UIPropGetter<\"button\"> = useCallback(\n    (props = {}, ref = null) => ({\n      disabled,\n      \"aria-label\": \"Pick a color\",\n      ...props,\n      ref,\n      onClick: handlerAll(props.onClick, onEyeDropperClick),\n    }),\n    [disabled, onEyeDropperClick],\n  )\n\n  const getSwatchProps: UIPropGetter<\n    \"div\",\n    ColorSwatchProps,\n    ColorSwatchProps\n  > = useCallback(\n    ({ color, ...props } = {}, ref = null) => ({\n      \"aria-label\": `Select ${color} as the color`,\n      disabled,\n      readOnly,\n      ...props,\n      ref,\n      color,\n      onClick: handlerAll(props.onClick, () => {\n        if (!color) return\n\n        onSwatchClick?.(color)\n        onChange(color)\n        onChangeEnd(color)\n      }),\n    }),\n    [disabled, readOnly, onSwatchClick, onChange, onChangeEnd],\n  )\n\n  return {\n    value: resolvedValue,\n    onChange,\n    eyeDropperSupported,\n    withAlpha,\n    isInteractive,\n    disabled,\n    readOnly,\n    channels,\n    getContainerProps,\n    getInputProps,\n    getSaturationSliderProps,\n    getHueSliderProps,\n    getAlphaSliderProps,\n    getEyeDropperProps,\n    getChannelProps,\n    getSwatchProps,\n  }\n}\n\nexport type UseColorSelectorReturn = ReturnType<typeof useColorSelector>\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAA+B;AAE/B,mBAAsB;AAEtB,IAAAA,gBAAmB;AACnB,IAAAC,gBAAsC;;;ACEtC,0BAIO;AAEP,oCAAqC;AACrC,6BAA8B;AAE9B,mBAgBO;AAEP,mBAAuD;AAiEhD,IAAM,CAAC,uBAAuB,uBAAuB,QAC1D,4BAAoC;AAAA,EAClC,MAAM;AAAA,EACN,cAAc;AAChB,CAAC;;;ADhEK;AArBD,IAAM,4BAAwB,wBAGnC,CAAC,EAAE,WAAW,cAAc,GAAG,KAAK,GAAG,QAAQ;AAC/C,QAAM,EAAE,WAAW,UAAU,iBAAiB,OAAO,IACnD,wBAAwB;AAE1B,QAAM,MAAmB;AAAA,IACvB,SAAS;AAAA,IACT,qBAAqB,UAAU,YAAY,MAAM,GAAG;AAAA,IACpD,GAAG,OAAO;AAAA,EACZ;AAEA,SACE;AAAA,IAAC,eAAG;AAAA,IAAH;AAAA,MACC;AAAA,MACA,eAAW,kBAAG,+BAA+B,SAAS;AAAA,MACtD,OAAO;AAAA,MACN,GAAG;AAAA,MAEH,mBAAS,IAAI,CAAC,EAAE,OAAO,OAAO,OAAO,KAAK,IAAI,MAC7C;AAAA,QAAC;AAAA;AAAA,UAEC,cAAc;AAAA,UACb,GAAG,gBAAgB,EAAE,GAAG,cAAc,OAAO,OAAO,KAAK,IAAI,CAAC;AAAA;AAAA,QAF1D;AAAA,MAGP,CACD;AAAA;AAAA,EACH;AAEJ,CAAC;AAYM,IAAM,2BAAuB,wBAGlC,CAAC,EAAE,WAAW,cAAc,GAAG,KAAK,GAAG,QAAQ;AAC/C,QAAM,SAAK,qBAAM;AACjB,MAAI,EAAE,MAAM,UAAU,UAAU,OAAO,IAAI,wBAAwB;AAEnE,MAAI,SAAS;AAAQ,WAAO;AAE5B,QAAM,MAAmB,EAAE,GAAG,OAAO,QAAQ;AAE7C,SACE,6CAAC,eAAG,KAAH,EAAO,eAAW,kBAAG,8BAA8B,SAAS,GAC1D;AAAA,mBACC;AAAA,MAAC,eAAG;AAAA,MAAH;AAAA,QACC,SAAS;AAAA,QACT,OAAO,EAAE,QAAQ,WAAW,gBAAgB,OAAU;AAAA,QACtD,OAAO;AAAA,UACL,SAAS;AAAA,UACT,eAAe,WAAW,SAAS;AAAA,UACnC,GAAG,OAAO;AAAA,QACZ;AAAA,QAEC;AAAA;AAAA,IACH,IACE;AAAA,IAEJ,4CAAC,sBAAM,KAAU,IAAQ,MAAY,OAAO,KAAM,GAAG,MAAM;AAAA,KAC7D;AAEJ,CAAC;","names":["import_utils","import_react"]}