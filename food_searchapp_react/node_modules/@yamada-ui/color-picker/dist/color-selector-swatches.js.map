{"version":3,"sources":["../src/color-selector-swatches.tsx","../src/color-swatch.tsx","../src/use-color-selector.ts"],"sourcesContent":["import { forwardRef, ui } from \"@yamada-ui/core\"\nimport type { CSSUIObject, HTMLUIProps, Token } from \"@yamada-ui/core\"\nimport { cx, replaceObject } from \"@yamada-ui/utils\"\nimport type { ReactNode } from \"react\"\nimport type { ColorSwatchProps } from \"./color-swatch\"\nimport { ColorSwatch } from \"./color-swatch\"\nimport { useColorSelectorContext } from \"./use-color-selector\"\n\ntype ColorSelectorSwatchesOptions = {\n  /**\n   * The swatches label to use.\n   */\n  swatchesLabel?: ReactNode\n  /**\n   * An array of colors in one of the supported formats.\n   * Used to render swatches list below the color selector.\n   */\n  swatches?: string[]\n  /**\n   * Number of swatches grid columns.\n   *\n   * @default 7\n   */\n  swatchesColumns?: Token<number>\n  /**\n   * Props for the color swatch component.\n   */\n  swatchProps?: ColorSwatchProps\n  /**\n   * Props for the swatches container element.\n   */\n  swatchesContainerProps?: Omit<HTMLUIProps<\"div\">, \"children\">\n}\n\nexport type ColorSelectorSwatchesProps = Omit<HTMLUIProps<\"div\">, \"children\"> &\n  ColorSelectorSwatchesOptions\n\nexport const ColorSelectorSwatches = forwardRef<\n  ColorSelectorSwatchesProps,\n  \"div\"\n>(\n  (\n    {\n      className,\n      swatchesLabel,\n      swatches,\n      swatchesContainerProps,\n      swatchProps,\n      swatchesColumns,\n      ...rest\n    },\n    ref,\n  ) => {\n    const { getSwatchProps, readOnly, styles } = useColorSelectorContext()\n\n    const css: CSSUIObject = {\n      display: \"grid\",\n      gridTemplateColumns: replaceObject(swatchesColumns, (value) =>\n        value != null ? `repeat(${value}, minmax(0, 1fr))` : undefined,\n      ) as CSSUIObject[\"gridTemplateColumns\"],\n      ...styles.swatches,\n    }\n\n    return swatches?.length ? (\n      <ui.div {...swatchesContainerProps}>\n        {swatchesLabel ? (\n          <ui.p\n            className=\"ui-color-selector__swatches__label\"\n            __css={{ ...styles.swatchesLabel }}\n          >\n            {swatchesLabel}\n          </ui.p>\n        ) : null}\n\n        <ui.div\n          ref={ref}\n          className={cx(\"ui-color-selector__swatches\", className)}\n          __css={css}\n          {...rest}\n        >\n          {swatches.map((color) => (\n            <ColorSwatch\n              as=\"button\"\n              key={color}\n              __css={{\n                boxSize: \"100%\",\n                pointerEvents: readOnly ? \"none\" : undefined,\n                ...styles.swatch,\n              }}\n              {...getSwatchProps({ color, ...swatchProps })}\n            />\n          ))}\n        </ui.div>\n      </ui.div>\n    ) : null\n  },\n)\n","import {\n  ui,\n  forwardRef,\n  omitThemeProps,\n  useMultiComponentStyle,\n} from \"@yamada-ui/core\"\nimport type { CSSUIObject, HTMLUIProps, ThemeProps } from \"@yamada-ui/core\"\nimport { cx } from \"@yamada-ui/utils\"\n\nconst defaultOverlays = (\n  background: string,\n  withShadow: boolean,\n): HTMLUIProps<\"div\">[] => {\n  let overlays: HTMLUIProps<\"div\">[] = [\n    {\n      bgImage:\n        \"linear-gradient(45deg, var(--ui-checkers) 25%, transparent 25%), linear-gradient(-45deg, var(--ui-checkers) 25%, transparent 25%), linear-gradient(45deg, transparent 75%, var(--ui-checkers) 75%), linear-gradient(-45deg, var(--ui-body) 75%, var(--ui-checkers) 75%)\",\n      bgSize: `8px 8px`,\n      bgPosition: `0 0, 0 4px, 4px -4px, -4px 0`,\n      var: [\n        {\n          __prefix: \"ui\",\n          name: \"checkers\",\n          token: \"colors\",\n          value: [\"blackAlpha.300\", \"whiteAlpha.300\"],\n        },\n        {\n          __prefix: \"ui\",\n          name: \"body\",\n          token: \"colors\",\n          value: [\"whiteAlpha.500\", \"blackAlpha.500\"],\n        },\n      ],\n    },\n    { background },\n  ]\n\n  if (withShadow)\n    overlays = [\n      ...overlays,\n      {\n        boxShadow: `rgba(0, 0, 0, .1) 0 0 0 1px inset, rgb(0, 0, 0, .15) 0 0 4px inset`,\n      },\n    ]\n\n  return overlays\n}\n\ntype ColorSwatchOptions = {\n  /**\n   * The color used for the swatch element.\n   *\n   * @default \"#ffffff00\"\n   */\n  color?: string\n  /**\n   * The overlay used for the swatch element.\n   */\n  overlays?: HTMLUIProps<\"div\">[]\n  /**\n   * If `true`, the swatch element has an inner `box-shadow`.\n   *\n   * @default true\n   */\n  withShadow?: boolean\n  /**\n   * If `true`, the color swatch will be perfectly round. Else, it'll be slightly round.\n   *\n   * @default false\n   */\n  isRounded?: boolean\n}\n\nexport type ColorSwatchProps = Omit<HTMLUIProps<\"div\">, \"color\"> &\n  ThemeProps<\"ColorSwatch\"> &\n  ColorSwatchOptions\n\n/**\n * `ColorSwatch` is a component that displays color samples.\n *\n * @see Docs https://yamada-ui.com/components/data-display/color-swatch\n */\nexport const ColorSwatch = forwardRef<ColorSwatchProps, \"div\">((props, ref) => {\n  const [styles, mergedProps] = useMultiComponentStyle(\"ColorSwatch\", props)\n  const {\n    className,\n    color = \"#ffffff00\",\n    withShadow = true,\n    overlays = defaultOverlays(color, withShadow),\n    isRounded,\n    __css,\n    ...rest\n  } = omitThemeProps(mergedProps)\n\n  const css: CSSUIObject = {\n    position: \"relative\",\n    _before: {\n      content: `\"\"`,\n      display: \"block\",\n      h: 0,\n      pb: \"100%\",\n    },\n    \"& > *\": {\n      overflow: \"hidden\",\n      position: \"absolute\",\n      top: \"0\",\n      right: \"0\",\n      bottom: \"0\",\n      left: \"0\",\n      display: \"flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      w: \"100%\",\n      h: \"100%\",\n    },\n    ...styles.container,\n    ...__css,\n  }\n\n  return (\n    <ui.div\n      ref={ref}\n      className={cx(\"ui-color-swatch\", className)}\n      {...(isRounded ? { rounded: \"fallback(full, 9999px)\" } : {})}\n      __css={css}\n      {...rest}\n    >\n      <ui.div {...(isRounded ? { rounded: \"fallback(full, 9999px)\" } : {})}>\n        {overlays.map((props, index) => (\n          <ui.div\n            key={index}\n            __css={{\n              position: \"absolute\",\n              top: 0,\n              left: 0,\n              right: 0,\n              bottom: 0,\n              ...styles.overlay,\n            }}\n            {...(isRounded ? { rounded: \"fallback(full, 9999px)\" } : {})}\n            {...props}\n          />\n        ))}\n      </ui.div>\n    </ui.div>\n  )\n})\n","import type {\n  CSSUIObject,\n  HTMLUIProps,\n  UIPropGetter,\n  ThemeProps,\n  RequiredUIPropGetter,\n} from \"@yamada-ui/core\"\nimport {\n  useFormControlProps,\n  type FormControlOptions,\n  formControlProperties,\n} from \"@yamada-ui/form-control\"\nimport type { InputProps } from \"@yamada-ui/input\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { useEyeDropper } from \"@yamada-ui/use-eye-dropper\"\nimport type { ColorFormat, Dict, Merge } from \"@yamada-ui/utils\"\nimport {\n  calcFormat,\n  convertColor,\n  createContext,\n  handlerAll,\n  hsvTo,\n  isString,\n  parseToHsv,\n  useCallbackRef,\n  useUpdateEffect,\n  omitObject,\n  parseToRgba,\n  parseToHsla,\n  rgbaTo,\n  hslaTo,\n  pickObject,\n} from \"@yamada-ui/utils\"\nimport type { ChangeEvent } from \"react\"\nimport { useCallback, useMemo, useRef, useState } from \"react\"\nimport type { AlphaSliderProps } from \"./alpha-slider\"\nimport type { ColorSwatchProps } from \"./color-swatch\"\nimport type { HueSliderProps } from \"./hue-slider\"\nimport type { SaturationSliderProps } from \"./saturation-slider\"\n\ntype Space = keyof Hsla | keyof Rgba\ntype Hsla = { h: number; s: number; l: number; a: number }\ntype Rgba = { r: number; g: number; b: number; a: number }\ntype Hsva = { h: number; s: number; v: number; a: number }\ntype Channel = {\n  label: string\n  space: Space\n  value: number\n  min: number\n  max: number\n}\n\nconst convertHsla = (value: string, fallback?: string): Hsla => {\n  let [h, s, l, a] = parseToHsla(value, fallback) ?? [0, 0, 1, 1]\n\n  if (a > 1) a = 1\n\n  return { h, s, l, a }\n}\n\nconst convertRgba = (value: string, fallback?: string): Rgba => {\n  let [r, g, b, a] = parseToRgba(value, fallback) ?? [255, 255, 255, 1]\n\n  if (r > 255) r = 255\n  if (g > 255) g = 255\n  if (b > 255) b = 255\n  if (a > 1) a = 1\n\n  return { r, g, b, a }\n}\n\nconst convertHsva = (value: string, fallback?: string): Hsva => {\n  const [h, s, v, a] = parseToHsv(value, fallback)\n\n  return { h, s, v, a }\n}\n\ntype ColorSelectorContext = {\n  value: string\n  onChange: (value: string | Partial<Hsva>) => void\n  eyeDropperSupported: boolean\n  withAlpha: boolean\n  isInteractive: boolean\n  disabled?: boolean\n  readOnly?: boolean\n  channels: Channel[]\n  size?: ThemeProps<\"ColorSelector\">[\"size\"]\n  getHueSliderProps: UIPropGetter<\"input\", HueSliderProps, HueSliderProps>\n  getAlphaSliderProps: UIPropGetter<\"input\", AlphaSliderProps, AlphaSliderProps>\n  getEyeDropperProps: UIPropGetter<\"button\">\n  getChannelProps: RequiredUIPropGetter<\n    \"input\",\n    Merge<InputProps, { space: Space }>,\n    InputProps\n  >\n  getSwatchProps: UIPropGetter<\"div\", ColorSwatchProps, ColorSwatchProps>\n  styles: Record<string, CSSUIObject>\n}\n\nexport const [ColorSelectorProvider, useColorSelectorContext] =\n  createContext<ColorSelectorContext>({\n    name: \"ColorSelectorContext\",\n    errorMessage: `useColorSelectorContext returned is 'undefined'. Seems you forgot to wrap the components in \"<ColorSelector />\"`,\n  })\n\ntype UseColorSelectorOptions = {\n  /**\n   * The base `id` to use for the color selector.\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms.\n   */\n  name?: string\n  /**\n   * The value of the color selector.\n   */\n  value?: string\n  /**\n   * The initial value of the color selector.\n   */\n  defaultValue?: string\n  /**\n   * The fallback value returned when color determination fails.\n   */\n  fallbackValue?: string\n  /**\n   * Function called whenever the color selector value changes.\n   */\n  onChange?: (value: string) => void\n  /**\n   * Function called when the user starts selecting a new value.\n   */\n  onChangeStart?: (value: string) => void\n  /**\n   * Function called when the user is done selecting a new value.\n   */\n  onChangeEnd?: (value: string) => void\n  /**\n   * Color format. For example, `hex`, `rgba`, etc.\n   *\n   * @default \"hexa\"\n   */\n  format?: ColorFormat\n  /**\n   * Function called whenever the color swatch click.\n   */\n  onSwatchClick?: (value: string) => void\n}\n\nexport type UseColorSelectorBaseProps = UseColorSelectorOptions &\n  FormControlOptions\n\nexport type UseColorSelectorProps = Omit<\n  HTMLUIProps<\"div\">,\n  \"defaultValue\" | \"onChange\" | \"children\"\n> &\n  UseColorSelectorBaseProps\n\nexport const useColorSelector = ({\n  isInvalid,\n  ...props\n}: UseColorSelectorProps) => {\n  let {\n    id,\n    name,\n    value: valueProp,\n    defaultValue,\n    fallbackValue,\n    onChange: onChangeProp,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    format,\n    required,\n    disabled,\n    readOnly,\n    onSwatchClick,\n    ...rest\n  } = useFormControlProps({ isInvalid, ...props })\n\n  const onChangeStartRef = useCallbackRef(onChangeStartProp)\n  const onChangeEndRef = useCallbackRef(onChangeEndProp)\n  const { supported: eyeDropperSupported, onOpen } = useEyeDropper()\n  const [value, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? fallbackValue,\n    onChange: onChangeProp,\n  })\n  const resolvedValue = value ?? \"#ffffff\"\n  const timeoutId = useRef<any>(undefined)\n  const formatRef = useRef<ColorFormat>(format ?? calcFormat(resolvedValue))\n  const isDraggingRef = useRef<boolean>(false)\n  const [parsedValue, setParsedValue] = useState<Hsva>(\n    convertHsva(resolvedValue, fallbackValue),\n  )\n  const { h, s, v, a } = parsedValue\n  const withAlpha = formatRef.current.endsWith(\"a\")\n  const isInteractive = !(disabled || readOnly)\n\n  const channels: Channel[] = useMemo(() => {\n    if (resolvedValue.startsWith(\"hsl\")) {\n      const { h, s, l, a } = convertHsla(resolvedValue, fallbackValue)\n\n      let channels: Channel[] = [\n        { label: \"H\", space: \"h\", value: Math.round(h), min: 0, max: 360 },\n        {\n          label: \"S(%)\",\n          space: \"s\",\n          value: Math.round(s * 100),\n          min: 0,\n          max: 100,\n        },\n        {\n          label: \"L(%)\",\n          space: \"l\",\n          value: Math.round(l * 100),\n          min: 0,\n          max: 100,\n        },\n      ]\n\n      if (withAlpha) {\n        channels = [\n          ...channels,\n          {\n            label: \"A(%)\",\n            space: \"a\",\n            value: Math.round(a * 100),\n            min: 0,\n            max: 100,\n          },\n        ]\n      }\n\n      return channels\n    } else {\n      const { r, g, b, a } = convertRgba(resolvedValue, fallbackValue)\n\n      let channels: Channel[] = [\n        { label: \"R\", space: \"r\", value: Math.round(r), min: 0, max: 255 },\n        { label: \"G\", space: \"g\", value: Math.round(g), min: 0, max: 255 },\n        { label: \"B\", space: \"b\", value: Math.round(b), min: 0, max: 255 },\n      ]\n\n      if (withAlpha) {\n        channels = [\n          ...channels,\n          {\n            label: \"A(%)\",\n            space: \"a\",\n            value: Math.round(a * 100),\n            min: 0,\n            max: 100,\n          },\n        ]\n      }\n\n      return channels\n    }\n  }, [resolvedValue, withAlpha, fallbackValue])\n\n  const onChange = useCallback(\n    (value: string | Partial<Hsva>) => {\n      if (isString(value)) {\n        setParsedValue(convertHsva(value, fallbackValue))\n      } else {\n        setParsedValue((prev) => ({ ...prev, ...value }))\n      }\n    },\n    [fallbackValue],\n  )\n\n  const onChangeStart = useCallback(\n    (value: Partial<Hsva>) => {\n      window.clearTimeout(timeoutId.current)\n\n      isDraggingRef.current = true\n\n      const { h, s, v, a } = { ...parsedValue, ...value }\n\n      const nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n\n      if (nextValue) onChangeStartRef(nextValue)\n    },\n    [formatRef, onChangeStartRef, fallbackValue, parsedValue],\n  )\n\n  const onChangeEnd = useCallback(\n    (value: string | Partial<Hsva>) => {\n      window.clearTimeout(timeoutId.current)\n\n      timeoutId.current = window.setTimeout(() => {\n        isDraggingRef.current = false\n      }, 200)\n\n      let nextValue: string | undefined\n\n      if (isString(value)) {\n        nextValue = convertColor(value, fallbackValue)(formatRef.current)\n      } else {\n        const { h, s, v, a } = { ...parsedValue, ...value }\n\n        nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n      }\n\n      if (nextValue) onChangeEndRef(nextValue)\n    },\n    [formatRef, onChangeEndRef, fallbackValue, parsedValue],\n  )\n\n  const onChannelChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>, space: Space) => {\n      let n = Math.floor(parseFloat(ev.target.value))\n\n      if (isNaN(n)) n = 0\n\n      if ([\"s\", \"l\", \"a\"].includes(space)) n = n / 100\n\n      let nextValue: string | undefined\n\n      if (resolvedValue.startsWith(\"hsl\")) {\n        const { h, s, l, a } = Object.assign(\n          convertHsla(resolvedValue, fallbackValue),\n          { [space]: n },\n        )\n\n        nextValue = hslaTo([h, s, l, a], fallbackValue)(formatRef.current)\n      } else {\n        const { r, g, b, a } = Object.assign(\n          convertRgba(resolvedValue, fallbackValue),\n          { [space]: n },\n        )\n\n        nextValue = rgbaTo([r, g, b, a], fallbackValue)(formatRef.current)\n      }\n\n      if (!nextValue) return\n\n      onChange(nextValue)\n      onChangeEnd(nextValue)\n    },\n    [resolvedValue, onChange, onChangeEnd, formatRef, fallbackValue],\n  )\n\n  const onEyeDropperClick = useCallback(async () => {\n    try {\n      const { sRGBHex } = (await onOpen()) ?? {}\n\n      if (!sRGBHex) return\n\n      onChange(sRGBHex)\n      onChangeEnd(sRGBHex)\n    } catch {}\n  }, [onOpen, onChange, onChangeEnd])\n\n  useUpdateEffect(() => {\n    const nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n\n    if (nextValue) setValue(nextValue)\n  }, [h, s, v, a])\n\n  useUpdateEffect(() => {\n    if (isDraggingRef.current) return\n\n    if (valueProp) setParsedValue(convertHsva(valueProp, fallbackValue))\n  }, [valueProp])\n\n  useUpdateEffect(() => {\n    if (!format || !value) return\n\n    formatRef.current = format\n\n    const nextValue = convertColor(value, fallbackValue)(format)\n\n    if (nextValue) setValue(nextValue)\n  }, [format])\n\n  const getContainerProps: UIPropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ref,\n    ...omitObject(rest, [\"aria-readonly\"]),\n  })\n\n  const getInputProps: UIPropGetter<\"input\"> = useCallback(\n    (props = {}, ref = null) => ({\n      ...pickObject(rest, formControlProperties),\n      ...props,\n      id,\n      ref,\n      type: \"hidden\",\n      name,\n      value: resolvedValue,\n      required,\n      disabled,\n      readOnly,\n    }),\n    [disabled, id, name, readOnly, required, rest, resolvedValue],\n  )\n\n  const getSaturationSliderProps: UIPropGetter<\n    \"input\",\n    SaturationSliderProps,\n    SaturationSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: [h, s, v],\n      onChange: handlerAll(props.onChange, ([, s, v]) => onChange({ s, v })),\n      onChangeStart: handlerAll(props.onChangeStart, ([, s, v]) =>\n        onChangeStart({ s, v }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, ([, s, v]) =>\n        onChangeEnd({ s, v }),\n      ),\n    }),\n    [\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      h,\n      s,\n      v,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getHueSliderProps: UIPropGetter<\n    \"input\",\n    HueSliderProps,\n    HueSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: h,\n      onChange: handlerAll(props.onChange, (h) => onChange({ h })),\n      onChangeStart: handlerAll(props.onChangeStart, (h) =>\n        onChangeStart({ h }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, (h) => onChangeEnd({ h })),\n    }),\n    [\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      h,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getAlphaSliderProps: UIPropGetter<\n    \"input\",\n    AlphaSliderProps,\n    AlphaSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: a,\n      color: hsvTo([h, s, v, a], fallbackValue)(formatRef.current),\n      onChange: handlerAll(props.onChange, (a) => onChange({ a })),\n      onChangeStart: handlerAll(props.onChangeStart, (a) =>\n        onChangeStart({ a }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, (a) => onChangeEnd({ a })),\n    }),\n    [\n      fallbackValue,\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      formatRef,\n      h,\n      s,\n      v,\n      a,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getChannelProps: RequiredUIPropGetter<\n    \"input\",\n    Merge<InputProps, { space: Space }>,\n    InputProps\n  > = useCallback(\n    ({ space, ...props }, ref = null) => {\n      return {\n        required,\n        disabled,\n        readOnly,\n        isInvalid,\n        ...props,\n        ref,\n        type: \"number\",\n        step: 1,\n        onChange: handlerAll(props.onChange, (ev) =>\n          onChannelChange(ev, space),\n        ),\n      } as Dict\n    },\n    [required, disabled, readOnly, isInvalid, onChannelChange],\n  )\n\n  const getEyeDropperProps: UIPropGetter<\"button\"> = useCallback(\n    (props = {}, ref = null) => ({\n      disabled,\n      \"aria-label\": \"Pick a color\",\n      ...props,\n      ref,\n      onClick: handlerAll(props.onClick, onEyeDropperClick),\n    }),\n    [disabled, onEyeDropperClick],\n  )\n\n  const getSwatchProps: UIPropGetter<\n    \"div\",\n    ColorSwatchProps,\n    ColorSwatchProps\n  > = useCallback(\n    ({ color, ...props } = {}, ref = null) => ({\n      \"aria-label\": `Select ${color} as the color`,\n      disabled,\n      readOnly,\n      ...props,\n      ref,\n      color,\n      onClick: handlerAll(props.onClick, () => {\n        if (!color) return\n\n        onSwatchClick?.(color)\n        onChange(color)\n        onChangeEnd(color)\n      }),\n    }),\n    [disabled, readOnly, onSwatchClick, onChange, onChangeEnd],\n  )\n\n  return {\n    value: resolvedValue,\n    onChange,\n    eyeDropperSupported,\n    withAlpha,\n    isInteractive,\n    disabled,\n    readOnly,\n    channels,\n    getContainerProps,\n    getInputProps,\n    getSaturationSliderProps,\n    getHueSliderProps,\n    getAlphaSliderProps,\n    getEyeDropperProps,\n    getChannelProps,\n    getSwatchProps,\n  }\n}\n\nexport type UseColorSelectorReturn = ReturnType<typeof useColorSelector>\n"],"mappings":"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","names":["import_core","import_utils","props","import_utils","import_jsx_runtime"]}