"use client"
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/use-color-selector.ts
var use_color_selector_exports = {};
__export(use_color_selector_exports, {
  ColorSelectorProvider: () => ColorSelectorProvider,
  useColorSelector: () => useColorSelector,
  useColorSelectorContext: () => useColorSelectorContext
});
module.exports = __toCommonJS(use_color_selector_exports);
var import_form_control = require("@yamada-ui/form-control");
var import_use_controllable_state = require("@yamada-ui/use-controllable-state");
var import_use_eye_dropper = require("@yamada-ui/use-eye-dropper");
var import_utils = require("@yamada-ui/utils");
var import_react = require("react");
var convertHsla = (value, fallback) => {
  var _a;
  let [h, s, l, a] = (_a = (0, import_utils.parseToHsla)(value, fallback)) != null ? _a : [0, 0, 1, 1];
  if (a > 1)
    a = 1;
  return { h, s, l, a };
};
var convertRgba = (value, fallback) => {
  var _a;
  let [r, g, b, a] = (_a = (0, import_utils.parseToRgba)(value, fallback)) != null ? _a : [255, 255, 255, 1];
  if (r > 255)
    r = 255;
  if (g > 255)
    g = 255;
  if (b > 255)
    b = 255;
  if (a > 1)
    a = 1;
  return { r, g, b, a };
};
var convertHsva = (value, fallback) => {
  const [h, s, v, a] = (0, import_utils.parseToHsv)(value, fallback);
  return { h, s, v, a };
};
var [ColorSelectorProvider, useColorSelectorContext] = (0, import_utils.createContext)({
  name: "ColorSelectorContext",
  errorMessage: `useColorSelectorContext returned is 'undefined'. Seems you forgot to wrap the components in "<ColorSelector />"`
});
var useColorSelector = ({
  isInvalid,
  ...props
}) => {
  let {
    id,
    name,
    value: valueProp,
    defaultValue,
    fallbackValue,
    onChange: onChangeProp,
    onChangeStart: onChangeStartProp,
    onChangeEnd: onChangeEndProp,
    format,
    required,
    disabled,
    readOnly,
    onSwatchClick,
    ...rest
  } = (0, import_form_control.useFormControlProps)({ isInvalid, ...props });
  const onChangeStartRef = (0, import_utils.useCallbackRef)(onChangeStartProp);
  const onChangeEndRef = (0, import_utils.useCallbackRef)(onChangeEndProp);
  const { supported: eyeDropperSupported, onOpen } = (0, import_use_eye_dropper.useEyeDropper)();
  const [value, setValue] = (0, import_use_controllable_state.useControllableState)({
    value: valueProp,
    defaultValue: defaultValue != null ? defaultValue : fallbackValue,
    onChange: onChangeProp
  });
  const resolvedValue = value != null ? value : "#ffffff";
  const timeoutId = (0, import_react.useRef)(void 0);
  const formatRef = (0, import_react.useRef)(format != null ? format : (0, import_utils.calcFormat)(resolvedValue));
  const isDraggingRef = (0, import_react.useRef)(false);
  const [parsedValue, setParsedValue] = (0, import_react.useState)(
    convertHsva(resolvedValue, fallbackValue)
  );
  const { h, s, v, a } = parsedValue;
  const withAlpha = formatRef.current.endsWith("a");
  const isInteractive = !(disabled || readOnly);
  const channels = (0, import_react.useMemo)(() => {
    if (resolvedValue.startsWith("hsl")) {
      const { h: h2, s: s2, l, a: a2 } = convertHsla(resolvedValue, fallbackValue);
      let channels2 = [
        { label: "H", space: "h", value: Math.round(h2), min: 0, max: 360 },
        {
          label: "S(%)",
          space: "s",
          value: Math.round(s2 * 100),
          min: 0,
          max: 100
        },
        {
          label: "L(%)",
          space: "l",
          value: Math.round(l * 100),
          min: 0,
          max: 100
        }
      ];
      if (withAlpha) {
        channels2 = [
          ...channels2,
          {
            label: "A(%)",
            space: "a",
            value: Math.round(a2 * 100),
            min: 0,
            max: 100
          }
        ];
      }
      return channels2;
    } else {
      const { r, g, b, a: a2 } = convertRgba(resolvedValue, fallbackValue);
      let channels2 = [
        { label: "R", space: "r", value: Math.round(r), min: 0, max: 255 },
        { label: "G", space: "g", value: Math.round(g), min: 0, max: 255 },
        { label: "B", space: "b", value: Math.round(b), min: 0, max: 255 }
      ];
      if (withAlpha) {
        channels2 = [
          ...channels2,
          {
            label: "A(%)",
            space: "a",
            value: Math.round(a2 * 100),
            min: 0,
            max: 100
          }
        ];
      }
      return channels2;
    }
  }, [resolvedValue, withAlpha, fallbackValue]);
  const onChange = (0, import_react.useCallback)(
    (value2) => {
      if ((0, import_utils.isString)(value2)) {
        setParsedValue(convertHsva(value2, fallbackValue));
      } else {
        setParsedValue((prev) => ({ ...prev, ...value2 }));
      }
    },
    [fallbackValue]
  );
  const onChangeStart = (0, import_react.useCallback)(
    (value2) => {
      window.clearTimeout(timeoutId.current);
      isDraggingRef.current = true;
      const { h: h2, s: s2, v: v2, a: a2 } = { ...parsedValue, ...value2 };
      const nextValue = (0, import_utils.hsvTo)([h2, s2, v2, a2], fallbackValue)(formatRef.current);
      if (nextValue)
        onChangeStartRef(nextValue);
    },
    [formatRef, onChangeStartRef, fallbackValue, parsedValue]
  );
  const onChangeEnd = (0, import_react.useCallback)(
    (value2) => {
      window.clearTimeout(timeoutId.current);
      timeoutId.current = window.setTimeout(() => {
        isDraggingRef.current = false;
      }, 200);
      let nextValue;
      if ((0, import_utils.isString)(value2)) {
        nextValue = (0, import_utils.convertColor)(value2, fallbackValue)(formatRef.current);
      } else {
        const { h: h2, s: s2, v: v2, a: a2 } = { ...parsedValue, ...value2 };
        nextValue = (0, import_utils.hsvTo)([h2, s2, v2, a2], fallbackValue)(formatRef.current);
      }
      if (nextValue)
        onChangeEndRef(nextValue);
    },
    [formatRef, onChangeEndRef, fallbackValue, parsedValue]
  );
  const onChannelChange = (0, import_react.useCallback)(
    (ev, space) => {
      let n = Math.floor(parseFloat(ev.target.value));
      if (isNaN(n))
        n = 0;
      if (["s", "l", "a"].includes(space))
        n = n / 100;
      let nextValue;
      if (resolvedValue.startsWith("hsl")) {
        const { h: h2, s: s2, l, a: a2 } = Object.assign(
          convertHsla(resolvedValue, fallbackValue),
          { [space]: n }
        );
        nextValue = (0, import_utils.hslaTo)([h2, s2, l, a2], fallbackValue)(formatRef.current);
      } else {
        const { r, g, b, a: a2 } = Object.assign(
          convertRgba(resolvedValue, fallbackValue),
          { [space]: n }
        );
        nextValue = (0, import_utils.rgbaTo)([r, g, b, a2], fallbackValue)(formatRef.current);
      }
      if (!nextValue)
        return;
      onChange(nextValue);
      onChangeEnd(nextValue);
    },
    [resolvedValue, onChange, onChangeEnd, formatRef, fallbackValue]
  );
  const onEyeDropperClick = (0, import_react.useCallback)(async () => {
    var _a;
    try {
      const { sRGBHex } = (_a = await onOpen()) != null ? _a : {};
      if (!sRGBHex)
        return;
      onChange(sRGBHex);
      onChangeEnd(sRGBHex);
    } catch {
    }
  }, [onOpen, onChange, onChangeEnd]);
  (0, import_utils.useUpdateEffect)(() => {
    const nextValue = (0, import_utils.hsvTo)([h, s, v, a], fallbackValue)(formatRef.current);
    if (nextValue)
      setValue(nextValue);
  }, [h, s, v, a]);
  (0, import_utils.useUpdateEffect)(() => {
    if (isDraggingRef.current)
      return;
    if (valueProp)
      setParsedValue(convertHsva(valueProp, fallbackValue));
  }, [valueProp]);
  (0, import_utils.useUpdateEffect)(() => {
    if (!format || !value)
      return;
    formatRef.current = format;
    const nextValue = (0, import_utils.convertColor)(value, fallbackValue)(format);
    if (nextValue)
      setValue(nextValue);
  }, [format]);
  const getContainerProps = (props2 = {}, ref = null) => ({
    ...props2,
    ref,
    ...(0, import_utils.omitObject)(rest, ["aria-readonly"])
  });
  const getInputProps = (0, import_react.useCallback)(
    (props2 = {}, ref = null) => ({
      ...(0, import_utils.pickObject)(rest, import_form_control.formControlProperties),
      ...props2,
      id,
      ref,
      type: "hidden",
      name,
      value: resolvedValue,
      required,
      disabled,
      readOnly
    }),
    [disabled, id, name, readOnly, required, rest, resolvedValue]
  );
  const getSaturationSliderProps = (0, import_react.useCallback)(
    (props2 = {}, ref = null) => ({
      required,
      disabled,
      readOnly,
      isInvalid,
      ...props2,
      ref,
      value: [h, s, v],
      onChange: (0, import_utils.handlerAll)(props2.onChange, ([, s2, v2]) => onChange({ s: s2, v: v2 })),
      onChangeStart: (0, import_utils.handlerAll)(
        props2.onChangeStart,
        ([, s2, v2]) => onChangeStart({ s: s2, v: v2 })
      ),
      onChangeEnd: (0, import_utils.handlerAll)(
        props2.onChangeEnd,
        ([, s2, v2]) => onChangeEnd({ s: s2, v: v2 })
      )
    }),
    [
      required,
      disabled,
      readOnly,
      isInvalid,
      h,
      s,
      v,
      onChange,
      onChangeStart,
      onChangeEnd
    ]
  );
  const getHueSliderProps = (0, import_react.useCallback)(
    (props2 = {}, ref = null) => ({
      required,
      disabled,
      readOnly,
      isInvalid,
      ...props2,
      ref,
      value: h,
      onChange: (0, import_utils.handlerAll)(props2.onChange, (h2) => onChange({ h: h2 })),
      onChangeStart: (0, import_utils.handlerAll)(
        props2.onChangeStart,
        (h2) => onChangeStart({ h: h2 })
      ),
      onChangeEnd: (0, import_utils.handlerAll)(props2.onChangeEnd, (h2) => onChangeEnd({ h: h2 }))
    }),
    [
      required,
      disabled,
      readOnly,
      isInvalid,
      h,
      onChange,
      onChangeStart,
      onChangeEnd
    ]
  );
  const getAlphaSliderProps = (0, import_react.useCallback)(
    (props2 = {}, ref = null) => ({
      required,
      disabled,
      readOnly,
      isInvalid,
      ...props2,
      ref,
      value: a,
      color: (0, import_utils.hsvTo)([h, s, v, a], fallbackValue)(formatRef.current),
      onChange: (0, import_utils.handlerAll)(props2.onChange, (a2) => onChange({ a: a2 })),
      onChangeStart: (0, import_utils.handlerAll)(
        props2.onChangeStart,
        (a2) => onChangeStart({ a: a2 })
      ),
      onChangeEnd: (0, import_utils.handlerAll)(props2.onChangeEnd, (a2) => onChangeEnd({ a: a2 }))
    }),
    [
      fallbackValue,
      required,
      disabled,
      readOnly,
      isInvalid,
      formatRef,
      h,
      s,
      v,
      a,
      onChange,
      onChangeStart,
      onChangeEnd
    ]
  );
  const getChannelProps = (0, import_react.useCallback)(
    ({ space, ...props2 }, ref = null) => {
      return {
        required,
        disabled,
        readOnly,
        isInvalid,
        ...props2,
        ref,
        type: "number",
        step: 1,
        onChange: (0, import_utils.handlerAll)(
          props2.onChange,
          (ev) => onChannelChange(ev, space)
        )
      };
    },
    [required, disabled, readOnly, isInvalid, onChannelChange]
  );
  const getEyeDropperProps = (0, import_react.useCallback)(
    (props2 = {}, ref = null) => ({
      disabled,
      "aria-label": "Pick a color",
      ...props2,
      ref,
      onClick: (0, import_utils.handlerAll)(props2.onClick, onEyeDropperClick)
    }),
    [disabled, onEyeDropperClick]
  );
  const getSwatchProps = (0, import_react.useCallback)(
    ({ color, ...props2 } = {}, ref = null) => ({
      "aria-label": `Select ${color} as the color`,
      disabled,
      readOnly,
      ...props2,
      ref,
      color,
      onClick: (0, import_utils.handlerAll)(props2.onClick, () => {
        if (!color)
          return;
        onSwatchClick == null ? void 0 : onSwatchClick(color);
        onChange(color);
        onChangeEnd(color);
      })
    }),
    [disabled, readOnly, onSwatchClick, onChange, onChangeEnd]
  );
  return {
    value: resolvedValue,
    onChange,
    eyeDropperSupported,
    withAlpha,
    isInteractive,
    disabled,
    readOnly,
    channels,
    getContainerProps,
    getInputProps,
    getSaturationSliderProps,
    getHueSliderProps,
    getAlphaSliderProps,
    getEyeDropperProps,
    getChannelProps,
    getSwatchProps
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ColorSelectorProvider,
  useColorSelector,
  useColorSelectorContext
});
//# sourceMappingURL=use-color-selector.js.map