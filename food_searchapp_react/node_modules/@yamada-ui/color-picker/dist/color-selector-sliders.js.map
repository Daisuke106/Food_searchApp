{"version":3,"sources":["../src/color-selector-sliders.tsx","../src/alpha-slider.tsx","../src/use-color-slider.ts","../src/hue-slider.tsx","../src/use-color-selector.ts"],"sourcesContent":["import { forwardRef, ui } from \"@yamada-ui/core\"\nimport type { CSSUIObject, HTMLUIProps } from \"@yamada-ui/core\"\nimport { cx } from \"@yamada-ui/utils\"\nimport type { ForwardedRef } from \"react\"\nimport type { AlphaSliderProps } from \"./alpha-slider\"\nimport { AlphaSlider } from \"./alpha-slider\"\nimport type { HueSliderProps } from \"./hue-slider\"\nimport { HueSlider } from \"./hue-slider\"\nimport { useColorSelectorContext } from \"./use-color-selector\"\n\ntype ColorSelectorSlidersOptions = {\n  /**\n   * Ref for the hue slider component.\n   */\n  hueSliderRef?: ForwardedRef<HTMLInputElement>\n  /**\n   * Props for the hue slider component.\n   */\n  hueSliderProps?: Omit<HueSliderProps, \"value\" | \"defaultValue\">\n  /**\n   * Ref for the alpha slider component.\n   */\n  alphaSliderRef?: ForwardedRef<HTMLInputElement>\n  /**\n   * Props for the alpha slider component.\n   */\n  alphaSliderProps?: Omit<AlphaSliderProps, \"value\" | \"defaultValue\">\n}\n\nexport type ColorSelectorSlidersProps = Omit<HTMLUIProps<\"div\">, \"children\"> &\n  ColorSelectorSlidersOptions\n\nexport const ColorSelectorSliders = forwardRef<\n  ColorSelectorSlidersProps,\n  \"div\"\n>(\n  (\n    {\n      className,\n      hueSliderRef,\n      hueSliderProps,\n      alphaSliderRef,\n      alphaSliderProps,\n      ...rest\n    },\n    ref,\n  ) => {\n    let { size, withAlpha, getHueSliderProps, getAlphaSliderProps, styles } =\n      useColorSelectorContext()\n\n    if (size === \"full\") size = \"lg\"\n\n    const css: CSSUIObject = {\n      display: \"flex\",\n      flexDirection: \"column\",\n      ...styles.sliders,\n    }\n\n    return (\n      <ui.div\n        ref={ref}\n        className={cx(\"ui-color-selector__sliders\", className)}\n        __css={css}\n        {...rest}\n      >\n        <HueSlider\n          size={size}\n          className=\"ui-color-selector__hue-slider\"\n          __css={{ ...styles.hueSlider }}\n          {...getHueSliderProps(hueSliderProps, hueSliderRef)}\n        />\n\n        {withAlpha ? (\n          <AlphaSlider\n            size={size}\n            className=\"ui-color-selector__alpha-slider\"\n            __css={{ ...styles.alphaSlider }}\n            {...getAlphaSliderProps(alphaSliderProps, alphaSliderRef)}\n          />\n        ) : null}\n      </ui.div>\n    )\n  },\n)\n","import {\n  ui,\n  forwardRef,\n  omitThemeProps,\n  useMultiComponentStyle,\n} from \"@yamada-ui/core\"\nimport type { CSSUIObject, HTMLUIProps, ThemeProps } from \"@yamada-ui/core\"\nimport { alphaToHex, convertColor, cx } from \"@yamada-ui/utils\"\nimport type { UseColorSliderProps } from \"./use-color-slider\"\nimport { useColorSlider } from \"./use-color-slider\"\n\nconst defaultOverlays = (\n  color: string,\n  min: number,\n  max: number,\n  withShadow: boolean,\n): HTMLUIProps<\"div\">[] => {\n  let overlays: HTMLUIProps<\"div\">[] = [\n    {\n      bgImage:\n        \"linear-gradient(45deg, var(--ui-checkers) 25%, transparent 25%), linear-gradient(-45deg, var(--ui-checkers) 25%, transparent 25%), linear-gradient(45deg, transparent 75%, var(--ui-checkers) 75%), linear-gradient(-45deg, var(--ui-body) 75%, var(--ui-checkers) 75%)\",\n      bgSize: `8px 8px`,\n      bgPosition: `0 0, 0 4px, 4px -4px, -4px 0`,\n      var: [\n        {\n          __prefix: \"ui\",\n          name: \"checkers\",\n          token: \"colors\",\n          value: [\"blackAlpha.300\", \"whiteAlpha.300\"],\n        },\n        {\n          __prefix: \"ui\",\n          name: \"body\",\n          token: \"colors\",\n          value: [\"whiteAlpha.500\", \"blackAlpha.500\"],\n        },\n      ],\n    },\n    {\n      bgGradient: `linear(to-r, ${\n        convertColor(color)(\"hex\") + alphaToHex(min)\n      }, ${convertColor(color)(\"hex\") + alphaToHex(max)})`,\n    },\n  ]\n\n  if (withShadow)\n    overlays = [\n      ...overlays,\n      {\n        boxShadow: `rgba(0, 0, 0, .1) 0 0 0 1px inset, rgb(0, 0, 0, .15) 0 0 4px inset`,\n      },\n    ]\n\n  return overlays\n}\n\ntype AlphaSliderOptions = {\n  /**\n   * The color used for the slider.\n   *\n   * @default \"#ffffff\"\n   */\n  color?: string\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   *\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   *\n   * @default 1\n   */\n  max?: number\n  /**\n   * The step in which increments or decrements have to be made.\n   *\n   * @default 0.01\n   */\n  step?: number\n  /**\n   * If `true`, the slider has an inner `box-shadow`.\n   *\n   * @default true\n   */\n  withShadow?: boolean\n  /**\n   * Props for slider input element.\n   */\n  inputProps?: HTMLUIProps<\"input\">\n  /**\n   * Props for slider track element.\n   */\n  trackProps?: HTMLUIProps<\"div\">\n  /**\n   * Props for slider thumb element.\n   */\n  thumbProps?: HTMLUIProps<\"div\">\n  /**\n   * The overlay used for the slider.\n   */\n  overlays?: HTMLUIProps<\"div\">[]\n}\n\nexport type AlphaSliderProps = ThemeProps<\"AlphaSlider\"> &\n  Partial<Omit<UseColorSliderProps, \"color\">> &\n  AlphaSliderOptions\n\n/**\n * `AlphaSlider` is a component used to allow the user to select color transparency.\n *\n * @see Docs https://yamada-ui.com/components/forms/alpha-slider\n */\nexport const AlphaSlider = forwardRef<AlphaSliderProps, \"input\">(\n  (props, ref) => {\n    const [styles, mergedProps] = useMultiComponentStyle(\"AlphaSlider\", props)\n    const {\n      className,\n      inputProps,\n      trackProps,\n      thumbProps,\n      color = \"#ffffff\",\n      min = 0,\n      max = 1,\n      withShadow = true,\n      overlays = defaultOverlays(color, min, max, withShadow),\n      __css,\n      ...computedProps\n    } = omitThemeProps(mergedProps)\n    const { getContainerProps, getTrackProps, getInputProps, getThumbProps } =\n      useColorSlider({\n        min,\n        max,\n        step: 0.01,\n        thumbColor: \"transparent\",\n        ...computedProps,\n      })\n\n    const css: CSSUIObject = {\n      position: \"relative\",\n      ...styles.container,\n      ...__css,\n    }\n\n    return (\n      <ui.div\n        className={cx(\"ui-alpha-slider\", className)}\n        __css={css}\n        {...getContainerProps()}\n      >\n        <ui.input {...getInputProps(inputProps, ref)} />\n\n        {overlays.map((props, index) => (\n          <ui.div\n            key={index}\n            className=\"ui-alpha-slider__overlay\"\n            __css={{\n              position: \"absolute\",\n              top: 0,\n              left: 0,\n              right: 0,\n              bottom: 0,\n              ...styles.overlay,\n            }}\n            {...props}\n          />\n        ))}\n\n        <ui.div\n          className=\"ui-alpha-slider__track\"\n          __css={{\n            position: \"relative\",\n            w: \"100%\",\n            h: \"100%\",\n            ...styles.track,\n          }}\n          {...getTrackProps(trackProps)}\n        >\n          <ui.div\n            className=\"ui-alpha-slider__thumb\"\n            __css={{ ...styles.thumb }}\n            {...getThumbProps(thumbProps)}\n          />\n        </ui.div>\n      </ui.div>\n    )\n  },\n)\n","import type { CSSUIProps, HTMLUIProps, UIPropGetter } from \"@yamada-ui/core\"\nimport {\n  useFormControlProps,\n  type FormControlOptions,\n  formControlProperties,\n  getFormControlProperties,\n} from \"@yamada-ui/form-control\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { useLatestRef } from \"@yamada-ui/use-latest-ref\"\nimport { usePanEvent } from \"@yamada-ui/use-pan-event\"\nimport { useSize } from \"@yamada-ui/use-size\"\nimport {\n  omitObject,\n  dataAttr,\n  handlerAll,\n  mergeRefs,\n  valueToPercent,\n  clampNumber,\n  useCallbackRef,\n  roundNumberToStep,\n  useUpdateEffect,\n  percentToValue,\n  pickObject,\n} from \"@yamada-ui/utils\"\nimport type { CSSProperties, KeyboardEvent, KeyboardEventHandler } from \"react\"\nimport { useCallback, useRef, useState } from \"react\"\n\ntype UseColorSliderOptions = {\n  /**\n   * The base `id` to use for the slider.\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms.\n   */\n  name?: string\n  /**\n   * The value of the slider.\n   */\n  value?: number\n  /**\n   * The initial value of the slider.\n   */\n  defaultValue?: number\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   */\n  min: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   */\n  max: number\n  /**\n   * The step in which increments or decrements have to be made.\n   *\n   * @default 1\n   */\n  step?: number\n  /**\n   * Function called whenever the slider value changes.\n   */\n  onChange?: (value: number) => void\n  /**\n   * Function called when the user starts selecting a new value.\n   */\n  onChangeStart?: (value: number) => void\n  /**\n   * Function called when the user is done selecting a new value.\n   */\n  onChangeEnd?: (value: number) => void\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   *\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The CSS `background` property. Used in `background` of thumb element.\n   */\n  thumbColor?: CSSUIProps[\"bg\"]\n}\n\nexport type UseColorSliderProps = Omit<\n  HTMLUIProps<\"div\">,\n  \"defaultValue\" | \"onChange\"\n> &\n  UseColorSliderOptions &\n  FormControlOptions\n\nexport const useColorSlider = ({\n  focusThumbOnChange = true,\n  ...props\n}: UseColorSliderProps) => {\n  if (!focusThumbOnChange) props.isReadOnly = true\n\n  let {\n    id,\n    name,\n    value: valueProp,\n    defaultValue,\n    min = 0,\n    max,\n    step = 1,\n    onChange: onChangeProp,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    thumbColor,\n    required,\n    disabled,\n    readOnly,\n    ...rest\n  } = useFormControlProps(props)\n\n  const onChangeStart = useCallbackRef(onChangeStartProp)\n  const onChangeEnd = useCallbackRef(onChangeEndProp)\n\n  const [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? min + (max - min) / 2,\n    onChange: onChangeProp,\n  })\n  const value = clampNumber(computedValue, min, max)\n  const thumbPercent = valueToPercent(value, min, max)\n  const [isDragging, setDragging] = useState(false)\n  const isInteractive = !(disabled || readOnly)\n\n  const oneStep = step || (max - min) / 100\n  const tenStep = (max - min) / 10\n\n  const containerRef = useRef<HTMLElement>(null)\n  const trackRef = useRef<HTMLElement>(null)\n  const thumbRef = useRef<HTMLElement>(null)\n  const latestRef = useLatestRef({\n    value,\n    min,\n    max,\n    step,\n    isInteractive,\n    eventSource: null as \"pointer\" | \"keyboard\" | null,\n    focusThumbOnChange,\n  })\n\n  const thumbSize = useSize(thumbRef)\n\n  const getValueFromPointer = useCallback(\n    (ev: any) => {\n      if (!trackRef.current) return\n\n      const { min, max, step } = latestRef.current\n\n      latestRef.current.eventSource = \"pointer\"\n\n      const { left, width } = trackRef.current.getBoundingClientRect()\n      const { clientX } = ev.touches?.[0] ?? ev\n\n      let percent = (clientX - left) / width\n\n      let nextValue = percentToValue(percent, min, max)\n\n      if (step) nextValue = parseFloat(roundNumberToStep(nextValue, min, step))\n\n      nextValue = clampNumber(nextValue, min, max)\n\n      return nextValue\n    },\n    [latestRef],\n  )\n\n  const setValueFromPointer = (ev: MouseEvent | TouchEvent | PointerEvent) => {\n    const { value } = latestRef.current\n    const nextValue = getValueFromPointer(ev)\n\n    if (nextValue != null && nextValue !== value) setValue(nextValue)\n  }\n\n  const focusThumb = useCallback(() => {\n    const { focusThumbOnChange } = latestRef.current\n\n    if (focusThumbOnChange) setTimeout(() => thumbRef.current?.focus())\n  }, [latestRef])\n\n  const constrain = useCallback(\n    (value: number) => {\n      const { isInteractive, min, max } = latestRef.current\n\n      if (!isInteractive) return\n\n      value = parseFloat(roundNumberToStep(value, min, oneStep))\n      value = clampNumber(value, min, max)\n\n      setValue(value)\n    },\n    [setValue, latestRef, oneStep],\n  )\n\n  const stepUp = useCallback(\n    (step = oneStep) => constrain(value + step),\n    [constrain, value, oneStep],\n  )\n\n  const stepDown = useCallback(\n    (step = oneStep) => constrain(value - step),\n    [constrain, value, oneStep],\n  )\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLElement>) => {\n      const { min, max } = latestRef.current\n\n      const actions: Record<string, KeyboardEventHandler> = {\n        ArrowRight: () => stepUp(),\n        ArrowUp: () => stepUp(),\n        ArrowLeft: () => stepDown(),\n        ArrowDown: () => stepDown(),\n        PageUp: () => stepUp(tenStep),\n        PageDown: () => stepDown(tenStep),\n        Home: () => constrain(min),\n        End: () => constrain(max),\n      }\n\n      const action = actions[ev.key]\n\n      if (!action) return\n\n      ev.preventDefault()\n      ev.stopPropagation()\n\n      action(ev)\n\n      latestRef.current.eventSource = \"keyboard\"\n    },\n    [constrain, latestRef, stepDown, stepUp, tenStep],\n  )\n\n  usePanEvent(containerRef, {\n    onSessionStart: (ev) => {\n      const { isInteractive, value } = latestRef.current\n\n      if (!isInteractive) return\n\n      setDragging(true)\n      focusThumb()\n      setValueFromPointer(ev)\n      onChangeStart(value)\n    },\n    onSessionEnd: () => {\n      const { isInteractive, value } = latestRef.current\n\n      if (!isInteractive) return\n\n      setDragging(false)\n      onChangeEnd(value)\n    },\n    onMove: (ev) => {\n      const { isInteractive } = latestRef.current\n\n      if (!isInteractive) return\n\n      setValueFromPointer(ev)\n    },\n  })\n\n  useUpdateEffect(() => {\n    const { eventSource, value } = latestRef.current\n\n    if (eventSource === \"keyboard\") onChangeEnd(value)\n  }, [value, onChangeEnd])\n\n  const getContainerProps: UIPropGetter = useCallback(\n    (props = {}, ref = null) => {\n      const { width: w } = thumbSize ?? { width: 0 }\n\n      const style: CSSProperties = {\n        ...props.style,\n        ...rest.style,\n        paddingInline: `${w / 2}px`,\n      }\n\n      return {\n        ...props,\n        ...omitObject(rest, [\"aria-readonly\"]),\n        ref: mergeRefs(ref, containerRef),\n        tabIndex: -1,\n        style,\n      }\n    },\n    [rest, thumbSize],\n  )\n\n  const getInputProps: UIPropGetter<\"input\"> = useCallback(\n    (props = {}, ref = null) => ({\n      ...pickObject(rest, formControlProperties),\n      ...props,\n      id,\n      ref,\n      type: \"hidden\",\n      name,\n      value,\n      required,\n      disabled,\n      readOnly,\n    }),\n    [disabled, id, name, readOnly, required, rest, value],\n  )\n\n  const getTrackProps: UIPropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...pickObject(\n        rest,\n        getFormControlProperties({ omit: [\"aria-readonly\"] }),\n      ),\n      ...props,\n      ref: mergeRefs(ref, trackRef),\n    }),\n    [rest],\n  )\n\n  const getThumbProps: UIPropGetter = useCallback(\n    (props = {}, ref = null) => {\n      const n = thumbPercent\n      const { width: w } = thumbSize ?? { width: 0 }\n\n      const style: CSSProperties = {\n        ...props.style,\n        position: \"absolute\",\n        userSelect: \"none\",\n        touchAction: \"none\",\n        left: `calc(${n}% - ${w / 2}px)`,\n      }\n\n      return {\n        \"aria-label\": \"Slider thumb\",\n        bg: thumbColor ?? `hsl(${value}, 100%, 50%)`,\n        ...pickObject(rest, formControlProperties),\n        ...props,\n        ref: mergeRefs(ref, thumbRef),\n        tabIndex: isInteractive && focusThumbOnChange ? 0 : undefined,\n        role: \"slider\",\n        \"aria-valuenow\": value,\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"data-active\": dataAttr(isDragging && focusThumbOnChange),\n        onKeyDown: handlerAll(props.onKeyDown, onKeyDown),\n        onFocus: handlerAll(props.onFocus, rest.onFocus),\n        onBlur: handlerAll(props.onBlur, rest.onBlur),\n        style,\n      }\n    },\n    [\n      thumbColor,\n      focusThumbOnChange,\n      isDragging,\n      isInteractive,\n      min,\n      max,\n      onKeyDown,\n      rest,\n      thumbPercent,\n      thumbSize,\n      value,\n    ],\n  )\n\n  return {\n    value,\n    getContainerProps,\n    getTrackProps,\n    getInputProps,\n    getThumbProps,\n  }\n}\n\nexport type UseColorSliderReturn = ReturnType<typeof useColorSlider>\n","import {\n  ui,\n  forwardRef,\n  omitThemeProps,\n  useMultiComponentStyle,\n} from \"@yamada-ui/core\"\nimport type { CSSUIObject, HTMLUIProps, ThemeProps } from \"@yamada-ui/core\"\nimport { cx } from \"@yamada-ui/utils\"\nimport type { UseColorSliderProps } from \"./use-color-slider\"\nimport { useColorSlider } from \"./use-color-slider\"\n\nconst defaultOverlays = (\n  min: number,\n  max: number,\n  withShadow: boolean,\n): HTMLUIProps<\"div\">[] => {\n  let overlays: HTMLUIProps<\"div\">[] = [\n    {\n      bgGradient: `linear(to-r, ${[...Array(7)]\n        .map(\n          (_, index) =>\n            `hsl(${Math.round(min + ((max - min) / 6) * index)}, 100%, 50%)`,\n        )\n        .join(\", \")})`,\n    },\n  ]\n\n  if (withShadow)\n    overlays = [\n      ...overlays,\n      {\n        boxShadow: `rgba(0, 0, 0, .1) 0 0 0 1px inset, rgb(0, 0, 0, .15) 0 0 4px inset`,\n      },\n    ]\n\n  return overlays\n}\n\ntype HueSliderOptions = {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   *\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   *\n   * @default 360\n   */\n  max?: number\n  /**\n   * The step in which increments or decrements have to be made.\n   *\n   * @default 1\n   */\n  step?: number\n  /**\n   * If `true`, the slider has an inner `box-shadow`.\n   *\n   * @default true\n   */\n  withShadow?: boolean\n  /**\n   * Props for slider input element.\n   */\n  inputProps?: HTMLUIProps<\"input\">\n  /**\n   * Props for slider track element.\n   */\n  trackProps?: HTMLUIProps<\"div\">\n  /**\n   * Props for slider thumb element.\n   */\n  thumbProps?: HTMLUIProps<\"div\">\n  /**\n   * The overlay used for the slider.\n   */\n  overlays?: HTMLUIProps<\"div\">[]\n}\n\n/**\n * `HueSlider` is a component used to allow the user to select a color hue.\n *\n * @see Docs https://yamada-ui.com/components/forms/hue-slider\n */\nexport type HueSliderProps = ThemeProps<\"HueSlider\"> &\n  Partial<UseColorSliderProps> &\n  HueSliderOptions\n\nexport const HueSlider = forwardRef<HueSliderProps, \"input\">((props, ref) => {\n  const [styles, mergedProps] = useMultiComponentStyle(\"HueSlider\", props)\n  const {\n    className,\n    inputProps,\n    trackProps,\n    thumbProps,\n    min = 0,\n    max = 360,\n    withShadow = true,\n    overlays = defaultOverlays(min, max, withShadow),\n    __css,\n    ...computedProps\n  } = omitThemeProps(mergedProps)\n  const { getContainerProps, getTrackProps, getInputProps, getThumbProps } =\n    useColorSlider({ min, max, step: 1, ...computedProps })\n\n  const css: CSSUIObject = {\n    position: \"relative\",\n    ...styles.container,\n    ...__css,\n  }\n\n  return (\n    <ui.div\n      className={cx(\"ui-hue-slider\", className)}\n      __css={css}\n      {...getContainerProps()}\n    >\n      <ui.input {...getInputProps(inputProps, ref)} />\n\n      {overlays.map((props, index) => (\n        <ui.div\n          key={index}\n          className=\"ui-hue-slider__overlay\"\n          __css={{\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            ...styles.overlay,\n          }}\n          {...props}\n        />\n      ))}\n\n      <ui.div\n        className=\"ui-hue-slider__track\"\n        __css={{ position: \"relative\", w: \"100%\", h: \"100%\", ...styles.track }}\n        {...getTrackProps(trackProps)}\n      >\n        <ui.div\n          className=\"ui-hue-slider__thumb\"\n          __css={{ ...styles.thumb }}\n          {...getThumbProps(thumbProps)}\n        />\n      </ui.div>\n    </ui.div>\n  )\n})\n","import type {\n  CSSUIObject,\n  HTMLUIProps,\n  UIPropGetter,\n  ThemeProps,\n  RequiredUIPropGetter,\n} from \"@yamada-ui/core\"\nimport {\n  useFormControlProps,\n  type FormControlOptions,\n  formControlProperties,\n} from \"@yamada-ui/form-control\"\nimport type { InputProps } from \"@yamada-ui/input\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { useEyeDropper } from \"@yamada-ui/use-eye-dropper\"\nimport type { ColorFormat, Dict, Merge } from \"@yamada-ui/utils\"\nimport {\n  calcFormat,\n  convertColor,\n  createContext,\n  handlerAll,\n  hsvTo,\n  isString,\n  parseToHsv,\n  useCallbackRef,\n  useUpdateEffect,\n  omitObject,\n  parseToRgba,\n  parseToHsla,\n  rgbaTo,\n  hslaTo,\n  pickObject,\n} from \"@yamada-ui/utils\"\nimport type { ChangeEvent } from \"react\"\nimport { useCallback, useMemo, useRef, useState } from \"react\"\nimport type { AlphaSliderProps } from \"./alpha-slider\"\nimport type { ColorSwatchProps } from \"./color-swatch\"\nimport type { HueSliderProps } from \"./hue-slider\"\nimport type { SaturationSliderProps } from \"./saturation-slider\"\n\ntype Space = keyof Hsla | keyof Rgba\ntype Hsla = { h: number; s: number; l: number; a: number }\ntype Rgba = { r: number; g: number; b: number; a: number }\ntype Hsva = { h: number; s: number; v: number; a: number }\ntype Channel = {\n  label: string\n  space: Space\n  value: number\n  min: number\n  max: number\n}\n\nconst convertHsla = (value: string, fallback?: string): Hsla => {\n  let [h, s, l, a] = parseToHsla(value, fallback) ?? [0, 0, 1, 1]\n\n  if (a > 1) a = 1\n\n  return { h, s, l, a }\n}\n\nconst convertRgba = (value: string, fallback?: string): Rgba => {\n  let [r, g, b, a] = parseToRgba(value, fallback) ?? [255, 255, 255, 1]\n\n  if (r > 255) r = 255\n  if (g > 255) g = 255\n  if (b > 255) b = 255\n  if (a > 1) a = 1\n\n  return { r, g, b, a }\n}\n\nconst convertHsva = (value: string, fallback?: string): Hsva => {\n  const [h, s, v, a] = parseToHsv(value, fallback)\n\n  return { h, s, v, a }\n}\n\ntype ColorSelectorContext = {\n  value: string\n  onChange: (value: string | Partial<Hsva>) => void\n  eyeDropperSupported: boolean\n  withAlpha: boolean\n  isInteractive: boolean\n  disabled?: boolean\n  readOnly?: boolean\n  channels: Channel[]\n  size?: ThemeProps<\"ColorSelector\">[\"size\"]\n  getHueSliderProps: UIPropGetter<\"input\", HueSliderProps, HueSliderProps>\n  getAlphaSliderProps: UIPropGetter<\"input\", AlphaSliderProps, AlphaSliderProps>\n  getEyeDropperProps: UIPropGetter<\"button\">\n  getChannelProps: RequiredUIPropGetter<\n    \"input\",\n    Merge<InputProps, { space: Space }>,\n    InputProps\n  >\n  getSwatchProps: UIPropGetter<\"div\", ColorSwatchProps, ColorSwatchProps>\n  styles: Record<string, CSSUIObject>\n}\n\nexport const [ColorSelectorProvider, useColorSelectorContext] =\n  createContext<ColorSelectorContext>({\n    name: \"ColorSelectorContext\",\n    errorMessage: `useColorSelectorContext returned is 'undefined'. Seems you forgot to wrap the components in \"<ColorSelector />\"`,\n  })\n\ntype UseColorSelectorOptions = {\n  /**\n   * The base `id` to use for the color selector.\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms.\n   */\n  name?: string\n  /**\n   * The value of the color selector.\n   */\n  value?: string\n  /**\n   * The initial value of the color selector.\n   */\n  defaultValue?: string\n  /**\n   * The fallback value returned when color determination fails.\n   */\n  fallbackValue?: string\n  /**\n   * Function called whenever the color selector value changes.\n   */\n  onChange?: (value: string) => void\n  /**\n   * Function called when the user starts selecting a new value.\n   */\n  onChangeStart?: (value: string) => void\n  /**\n   * Function called when the user is done selecting a new value.\n   */\n  onChangeEnd?: (value: string) => void\n  /**\n   * Color format. For example, `hex`, `rgba`, etc.\n   *\n   * @default \"hexa\"\n   */\n  format?: ColorFormat\n  /**\n   * Function called whenever the color swatch click.\n   */\n  onSwatchClick?: (value: string) => void\n}\n\nexport type UseColorSelectorBaseProps = UseColorSelectorOptions &\n  FormControlOptions\n\nexport type UseColorSelectorProps = Omit<\n  HTMLUIProps<\"div\">,\n  \"defaultValue\" | \"onChange\" | \"children\"\n> &\n  UseColorSelectorBaseProps\n\nexport const useColorSelector = ({\n  isInvalid,\n  ...props\n}: UseColorSelectorProps) => {\n  let {\n    id,\n    name,\n    value: valueProp,\n    defaultValue,\n    fallbackValue,\n    onChange: onChangeProp,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    format,\n    required,\n    disabled,\n    readOnly,\n    onSwatchClick,\n    ...rest\n  } = useFormControlProps({ isInvalid, ...props })\n\n  const onChangeStartRef = useCallbackRef(onChangeStartProp)\n  const onChangeEndRef = useCallbackRef(onChangeEndProp)\n  const { supported: eyeDropperSupported, onOpen } = useEyeDropper()\n  const [value, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? fallbackValue,\n    onChange: onChangeProp,\n  })\n  const resolvedValue = value ?? \"#ffffff\"\n  const timeoutId = useRef<any>(undefined)\n  const formatRef = useRef<ColorFormat>(format ?? calcFormat(resolvedValue))\n  const isDraggingRef = useRef<boolean>(false)\n  const [parsedValue, setParsedValue] = useState<Hsva>(\n    convertHsva(resolvedValue, fallbackValue),\n  )\n  const { h, s, v, a } = parsedValue\n  const withAlpha = formatRef.current.endsWith(\"a\")\n  const isInteractive = !(disabled || readOnly)\n\n  const channels: Channel[] = useMemo(() => {\n    if (resolvedValue.startsWith(\"hsl\")) {\n      const { h, s, l, a } = convertHsla(resolvedValue, fallbackValue)\n\n      let channels: Channel[] = [\n        { label: \"H\", space: \"h\", value: Math.round(h), min: 0, max: 360 },\n        {\n          label: \"S(%)\",\n          space: \"s\",\n          value: Math.round(s * 100),\n          min: 0,\n          max: 100,\n        },\n        {\n          label: \"L(%)\",\n          space: \"l\",\n          value: Math.round(l * 100),\n          min: 0,\n          max: 100,\n        },\n      ]\n\n      if (withAlpha) {\n        channels = [\n          ...channels,\n          {\n            label: \"A(%)\",\n            space: \"a\",\n            value: Math.round(a * 100),\n            min: 0,\n            max: 100,\n          },\n        ]\n      }\n\n      return channels\n    } else {\n      const { r, g, b, a } = convertRgba(resolvedValue, fallbackValue)\n\n      let channels: Channel[] = [\n        { label: \"R\", space: \"r\", value: Math.round(r), min: 0, max: 255 },\n        { label: \"G\", space: \"g\", value: Math.round(g), min: 0, max: 255 },\n        { label: \"B\", space: \"b\", value: Math.round(b), min: 0, max: 255 },\n      ]\n\n      if (withAlpha) {\n        channels = [\n          ...channels,\n          {\n            label: \"A(%)\",\n            space: \"a\",\n            value: Math.round(a * 100),\n            min: 0,\n            max: 100,\n          },\n        ]\n      }\n\n      return channels\n    }\n  }, [resolvedValue, withAlpha, fallbackValue])\n\n  const onChange = useCallback(\n    (value: string | Partial<Hsva>) => {\n      if (isString(value)) {\n        setParsedValue(convertHsva(value, fallbackValue))\n      } else {\n        setParsedValue((prev) => ({ ...prev, ...value }))\n      }\n    },\n    [fallbackValue],\n  )\n\n  const onChangeStart = useCallback(\n    (value: Partial<Hsva>) => {\n      window.clearTimeout(timeoutId.current)\n\n      isDraggingRef.current = true\n\n      const { h, s, v, a } = { ...parsedValue, ...value }\n\n      const nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n\n      if (nextValue) onChangeStartRef(nextValue)\n    },\n    [formatRef, onChangeStartRef, fallbackValue, parsedValue],\n  )\n\n  const onChangeEnd = useCallback(\n    (value: string | Partial<Hsva>) => {\n      window.clearTimeout(timeoutId.current)\n\n      timeoutId.current = window.setTimeout(() => {\n        isDraggingRef.current = false\n      }, 200)\n\n      let nextValue: string | undefined\n\n      if (isString(value)) {\n        nextValue = convertColor(value, fallbackValue)(formatRef.current)\n      } else {\n        const { h, s, v, a } = { ...parsedValue, ...value }\n\n        nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n      }\n\n      if (nextValue) onChangeEndRef(nextValue)\n    },\n    [formatRef, onChangeEndRef, fallbackValue, parsedValue],\n  )\n\n  const onChannelChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>, space: Space) => {\n      let n = Math.floor(parseFloat(ev.target.value))\n\n      if (isNaN(n)) n = 0\n\n      if ([\"s\", \"l\", \"a\"].includes(space)) n = n / 100\n\n      let nextValue: string | undefined\n\n      if (resolvedValue.startsWith(\"hsl\")) {\n        const { h, s, l, a } = Object.assign(\n          convertHsla(resolvedValue, fallbackValue),\n          { [space]: n },\n        )\n\n        nextValue = hslaTo([h, s, l, a], fallbackValue)(formatRef.current)\n      } else {\n        const { r, g, b, a } = Object.assign(\n          convertRgba(resolvedValue, fallbackValue),\n          { [space]: n },\n        )\n\n        nextValue = rgbaTo([r, g, b, a], fallbackValue)(formatRef.current)\n      }\n\n      if (!nextValue) return\n\n      onChange(nextValue)\n      onChangeEnd(nextValue)\n    },\n    [resolvedValue, onChange, onChangeEnd, formatRef, fallbackValue],\n  )\n\n  const onEyeDropperClick = useCallback(async () => {\n    try {\n      const { sRGBHex } = (await onOpen()) ?? {}\n\n      if (!sRGBHex) return\n\n      onChange(sRGBHex)\n      onChangeEnd(sRGBHex)\n    } catch {}\n  }, [onOpen, onChange, onChangeEnd])\n\n  useUpdateEffect(() => {\n    const nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n\n    if (nextValue) setValue(nextValue)\n  }, [h, s, v, a])\n\n  useUpdateEffect(() => {\n    if (isDraggingRef.current) return\n\n    if (valueProp) setParsedValue(convertHsva(valueProp, fallbackValue))\n  }, [valueProp])\n\n  useUpdateEffect(() => {\n    if (!format || !value) return\n\n    formatRef.current = format\n\n    const nextValue = convertColor(value, fallbackValue)(format)\n\n    if (nextValue) setValue(nextValue)\n  }, [format])\n\n  const getContainerProps: UIPropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ref,\n    ...omitObject(rest, [\"aria-readonly\"]),\n  })\n\n  const getInputProps: UIPropGetter<\"input\"> = useCallback(\n    (props = {}, ref = null) => ({\n      ...pickObject(rest, formControlProperties),\n      ...props,\n      id,\n      ref,\n      type: \"hidden\",\n      name,\n      value: resolvedValue,\n      required,\n      disabled,\n      readOnly,\n    }),\n    [disabled, id, name, readOnly, required, rest, resolvedValue],\n  )\n\n  const getSaturationSliderProps: UIPropGetter<\n    \"input\",\n    SaturationSliderProps,\n    SaturationSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: [h, s, v],\n      onChange: handlerAll(props.onChange, ([, s, v]) => onChange({ s, v })),\n      onChangeStart: handlerAll(props.onChangeStart, ([, s, v]) =>\n        onChangeStart({ s, v }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, ([, s, v]) =>\n        onChangeEnd({ s, v }),\n      ),\n    }),\n    [\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      h,\n      s,\n      v,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getHueSliderProps: UIPropGetter<\n    \"input\",\n    HueSliderProps,\n    HueSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: h,\n      onChange: handlerAll(props.onChange, (h) => onChange({ h })),\n      onChangeStart: handlerAll(props.onChangeStart, (h) =>\n        onChangeStart({ h }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, (h) => onChangeEnd({ h })),\n    }),\n    [\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      h,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getAlphaSliderProps: UIPropGetter<\n    \"input\",\n    AlphaSliderProps,\n    AlphaSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: a,\n      color: hsvTo([h, s, v, a], fallbackValue)(formatRef.current),\n      onChange: handlerAll(props.onChange, (a) => onChange({ a })),\n      onChangeStart: handlerAll(props.onChangeStart, (a) =>\n        onChangeStart({ a }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, (a) => onChangeEnd({ a })),\n    }),\n    [\n      fallbackValue,\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      formatRef,\n      h,\n      s,\n      v,\n      a,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getChannelProps: RequiredUIPropGetter<\n    \"input\",\n    Merge<InputProps, { space: Space }>,\n    InputProps\n  > = useCallback(\n    ({ space, ...props }, ref = null) => {\n      return {\n        required,\n        disabled,\n        readOnly,\n        isInvalid,\n        ...props,\n        ref,\n        type: \"number\",\n        step: 1,\n        onChange: handlerAll(props.onChange, (ev) =>\n          onChannelChange(ev, space),\n        ),\n      } as Dict\n    },\n    [required, disabled, readOnly, isInvalid, onChannelChange],\n  )\n\n  const getEyeDropperProps: UIPropGetter<\"button\"> = useCallback(\n    (props = {}, ref = null) => ({\n      disabled,\n      \"aria-label\": \"Pick a color\",\n      ...props,\n      ref,\n      onClick: handlerAll(props.onClick, onEyeDropperClick),\n    }),\n    [disabled, onEyeDropperClick],\n  )\n\n  const getSwatchProps: UIPropGetter<\n    \"div\",\n    ColorSwatchProps,\n    ColorSwatchProps\n  > = useCallback(\n    ({ color, ...props } = {}, ref = null) => ({\n      \"aria-label\": `Select ${color} as the color`,\n      disabled,\n      readOnly,\n      ...props,\n      ref,\n      color,\n      onClick: handlerAll(props.onClick, () => {\n        if (!color) return\n\n        onSwatchClick?.(color)\n        onChange(color)\n        onChangeEnd(color)\n      }),\n    }),\n    [disabled, readOnly, onSwatchClick, onChange, onChangeEnd],\n  )\n\n  return {\n    value: resolvedValue,\n    onChange,\n    eyeDropperSupported,\n    withAlpha,\n    isInteractive,\n    disabled,\n    readOnly,\n    channels,\n    getContainerProps,\n    getInputProps,\n    getSaturationSliderProps,\n    getHueSliderProps,\n    getAlphaSliderProps,\n    getEyeDropperProps,\n    getChannelProps,\n    getSwatchProps,\n  }\n}\n\nexport type UseColorSelectorReturn = ReturnType<typeof useColorSelector>\n"],"mappings":"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","names":["import_core","import_utils","import_utils","min","max","step","value","focusThumbOnChange","isInteractive","props","props","import_core","import_utils","import_jsx_runtime","defaultOverlays","props","import_form_control","import_use_controllable_state","import_utils","import_react","import_jsx_runtime"]}