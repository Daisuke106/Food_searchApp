"use client"

// src/use-color-picker.ts
import { layoutStyleProperties } from "@yamada-ui/core";
import {
  formControlProperties,
  useFormControlProps
} from "@yamada-ui/form-control";
import { popoverProperties } from "@yamada-ui/popover";
import { useControllableState } from "@yamada-ui/use-controllable-state";
import { useDisclosure } from "@yamada-ui/use-disclosure";
import { useEyeDropper } from "@yamada-ui/use-eye-dropper";
import { useOutsideClick } from "@yamada-ui/use-outside-click";
import {
  createContext,
  dataAttr,
  handlerAll,
  mergeRefs,
  pickObject,
  splitObject,
  omitObject,
  getEventRelatedTarget,
  isContains,
  convertColor,
  calcFormat,
  useUpdateEffect
} from "@yamada-ui/utils";
import { useCallback, useRef, useState } from "react";
var [ColorPickerProvider, useColorPickerContext] = createContext({
  name: "ColorPickerContext",
  errorMessage: `useColorPickerContext returned is 'undefined'. Seems you forgot to wrap the components in "<ColorPicker />"`
});
var useColorPicker = ({
  value: valueProp,
  defaultValue,
  fallbackValue,
  defaultColor,
  onChange: onChangeProp,
  onChangeStart,
  onChangeEnd,
  onSwatchClick,
  formatInput = (value) => value,
  closeOnBlur = true,
  closeOnEsc = true,
  placement = "bottom-start",
  duration = 0.2,
  isOpen: isOpenProp,
  defaultIsOpen,
  onOpen: onOpenProp,
  onClose: onCloseProp,
  allowInput = true,
  closeOnSelectSwatch,
  format,
  swatchesLabel,
  swatches,
  swatchesColumns,
  withPicker,
  withChannel,
  withResult = false,
  withColorSelectorEyeDropper = false,
  colorSelectorVariant,
  colorSelectorSize,
  colorSelectorColorScheme,
  ...rest
}) => {
  var _a;
  rest = useFormControlProps(rest);
  const { "aria-readonly": _ariaReadonly, ...formControlProps } = pickObject(
    rest,
    formControlProperties
  );
  const { disabled, readOnly } = formControlProps;
  const [containerProps, inputProps] = splitObject(
    omitObject(rest, [...popoverProperties]),
    layoutStyleProperties
  );
  const containerRef = useRef(null);
  const fieldRef = useRef(null);
  const { supported: eyeDropperSupported, onOpen: onEyeDropperOpen } = useEyeDropper();
  const [value, setValue] = useControllableState({
    value: valueProp,
    defaultValue,
    onChange: onChangeProp
  });
  const formatRef = useRef(
    format != null ? format : calcFormat((_a = value != null ? value : defaultColor) != null ? _a : "")
  );
  const isInputFocused = useRef(false);
  const [inputValue, setInputValue] = useState(value != null ? value : "");
  const {
    isOpen,
    onOpen: onInternalOpen,
    onClose: onInternalClose
  } = useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onOpen: onOpenProp,
    onClose: onCloseProp
  });
  const isColorSelectorFull = colorSelectorSize === "full";
  const onOpen = useCallback(() => {
    if (disabled || readOnly)
      return;
    onInternalOpen();
  }, [onInternalOpen, disabled, readOnly]);
  const onClose = useCallback(() => {
    if (!isOpen)
      return;
    const next = convertColor(value, fallbackValue)(formatRef.current);
    setValue((prev) => !next || prev === next ? prev : next);
    setInputValue(formatInput(next != null ? next : ""));
    onInternalClose();
  }, [
    formatRef,
    isOpen,
    setValue,
    onInternalClose,
    value,
    formatInput,
    setInputValue,
    fallbackValue
  ]);
  const onContainerClick = useCallback(() => {
    if (isOpen)
      return;
    onOpen();
  }, [isOpen, onOpen]);
  const onInputFocus = useCallback(() => {
    isInputFocused.current = true;
    if (isOpen)
      return;
    onOpen();
  }, [isOpen, onOpen]);
  const onInputBlur = useCallback(() => {
    isInputFocused.current = false;
  }, []);
  const onContainerBlur = useCallback(
    (ev) => {
      const relatedTarget = getEventRelatedTarget(ev);
      if (isContains(containerRef.current, relatedTarget))
        return;
      if (!closeOnBlur)
        return;
      if (isOpen)
        onClose();
    },
    [closeOnBlur, isOpen, onClose]
  );
  const onInputKeyDown = useCallback(
    (ev) => {
      if (ev.key === " ")
        ev.key = ev.code;
      if (disabled || readOnly)
        return;
      const actions = {
        Space: !isOpen ? onOpen : void 0,
        Enter: !isOpen ? onOpen : void 0,
        Escape: closeOnEsc ? onClose : void 0
      };
      const action = actions[ev.key];
      if (!action)
        return;
      ev.preventDefault();
      ev.stopPropagation();
      action();
    },
    [disabled, readOnly, isOpen, onOpen, closeOnEsc, onClose]
  );
  const onInputChange = useCallback(
    (ev) => {
      const value2 = ev.target.value;
      setInputValue(formatInput(value2));
      setValue(value2);
    },
    [setInputValue, formatInput, setValue]
  );
  const onColorSelectorChange = useCallback(
    (value2) => {
      setValue(value2);
      setTimeout(() => {
        if (!isInputFocused.current)
          setInputValue(formatInput(value2));
      });
    },
    [setValue, formatInput]
  );
  const onEyeDropperClick = useCallback(
    async (ev) => {
      var _a2;
      ev.preventDefault();
      ev.stopPropagation();
      try {
        const { sRGBHex } = (_a2 = await onEyeDropperOpen()) != null ? _a2 : {};
        if (!sRGBHex)
          return;
        onColorSelectorChange(sRGBHex);
        onChangeEnd == null ? void 0 : onChangeEnd(sRGBHex);
      } catch {
      }
    },
    [onEyeDropperOpen, onColorSelectorChange, onChangeEnd]
  );
  useOutsideClick({
    ref: containerRef,
    handler: onClose,
    enabled: isOpen && closeOnBlur
  });
  useUpdateEffect(() => {
    if (!format || !value)
      return;
    formatRef.current = format;
    const nextValue = convertColor(value, fallbackValue)(format);
    if (!nextValue)
      return;
    setInputValue(formatInput(nextValue));
    setValue(nextValue);
  }, [format]);
  useUpdateEffect(() => {
    if (isInputFocused.current || !valueProp)
      return;
    setInputValue(formatInput(valueProp));
  }, [valueProp]);
  const getPopoverProps = useCallback(
    (props) => ({
      matchWidth: isColorSelectorFull,
      ...rest,
      ...props,
      isOpen,
      onOpen,
      onClose,
      placement,
      duration,
      trigger: "never",
      closeOnButton: false
    }),
    [isColorSelectorFull, duration, onClose, onOpen, placement, rest, isOpen]
  );
  const getContainerProps = useCallback(
    (props = {}, ref = null) => ({
      ref: mergeRefs(containerRef, ref),
      ...containerProps,
      ...props,
      ...formControlProps,
      onClick: handlerAll(props.onClick, rest.onClick, onContainerClick),
      onBlur: handlerAll(props.onBlur, rest.onBlur, onContainerBlur)
    }),
    [containerProps, formControlProps, onContainerBlur, onContainerClick, rest]
  );
  const getFieldProps = useCallback(
    (props = {}, ref = null) => ({
      ref: mergeRefs(fieldRef, ref),
      tabIndex: !allowInput ? -1 : 0,
      ...inputProps,
      ...props,
      style: {
        ...props.style,
        ...!allowInput ? { pointerEvents: "none" } : {}
      },
      value: inputValue,
      "data-active": dataAttr(isOpen),
      "aria-expanded": dataAttr(isOpen),
      onFocus: handlerAll(props.onFocus, rest.onFocus, onInputFocus),
      onKeyDown: handlerAll(props.onKeyDown, rest.onKeyDown, onInputKeyDown),
      onChange: handlerAll(props.onChange, onInputChange),
      onBlur: handlerAll(props.onFocus, onInputBlur)
    }),
    [
      allowInput,
      inputProps,
      inputValue,
      isOpen,
      rest,
      onInputFocus,
      onInputKeyDown,
      onInputChange,
      onInputBlur
    ]
  );
  const getEyeDropperProps = useCallback(
    (props = {}, ref = null) => ({
      disabled,
      "aria-label": "Pick a color",
      ...props,
      ref,
      style: { ...props.style, pointerEvents: readOnly ? "none" : void 0 },
      onClick: handlerAll(props.onClick, onEyeDropperClick)
    }),
    [disabled, onEyeDropperClick, readOnly]
  );
  const getSelectorProps = useCallback(
    (props) => ({
      ...formControlProps,
      ...props,
      value,
      defaultValue: defaultColor,
      fallbackValue,
      onChange: onColorSelectorChange,
      onChangeStart,
      onChangeEnd,
      onSwatchClick: handlerAll(
        onSwatchClick,
        closeOnSelectSwatch ? onClose : void 0
      ),
      format: formatRef.current,
      withPicker,
      withChannel,
      withResult,
      withEyeDropper: withColorSelectorEyeDropper,
      swatchesLabel,
      swatches,
      swatchesColumns,
      variant: colorSelectorVariant,
      size: colorSelectorSize,
      colorScheme: colorSelectorColorScheme
    }),
    [
      formControlProps,
      value,
      fallbackValue,
      defaultColor,
      onColorSelectorChange,
      onChangeStart,
      onChangeEnd,
      onSwatchClick,
      onClose,
      closeOnSelectSwatch,
      formatRef,
      withPicker,
      withChannel,
      withResult,
      withColorSelectorEyeDropper,
      swatchesLabel,
      swatches,
      swatchesColumns,
      colorSelectorColorScheme,
      colorSelectorSize,
      colorSelectorVariant
    ]
  );
  return {
    value,
    eyeDropperSupported,
    allowInput,
    getPopoverProps,
    getContainerProps,
    getFieldProps,
    getSelectorProps,
    getEyeDropperProps
  };
};

export {
  ColorPickerProvider,
  useColorPickerContext,
  useColorPicker
};
//# sourceMappingURL=chunk-SBN7FEOE.mjs.map