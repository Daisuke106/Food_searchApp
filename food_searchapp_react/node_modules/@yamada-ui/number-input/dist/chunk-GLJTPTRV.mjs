"use client"

// src/number-input.tsx
import {
  ui,
  forwardRef,
  useMultiComponentStyle,
  omitThemeProps
} from "@yamada-ui/core";
import {
  formControlProperties,
  useFormControlProps
} from "@yamada-ui/form-control";
import { ChevronIcon } from "@yamada-ui/icon";
import { useCounter } from "@yamada-ui/use-counter";
import { useEventListener } from "@yamada-ui/use-event-listener";
import { useInterval } from "@yamada-ui/use-interval";
import {
  ariaAttr,
  createContext,
  cx,
  handlerAll,
  mergeRefs,
  pickObject,
  useCallbackRef,
  useSafeLayoutEffect,
  useUpdateEffect
} from "@yamada-ui/utils";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { jsx, jsxs } from "react/jsx-runtime";
var isDefaultValidCharacter = (character) => /^[Ee0-9+\-.]$/.test(character);
var isValidNumericKeyboardEvent = ({ key, ctrlKey, altKey, metaKey }, isValid) => {
  if (key == null)
    return true;
  const isModifierKey = ctrlKey || altKey || metaKey;
  const isSingleCharacterKey = key.length === 1;
  if (!isSingleCharacterKey || isModifierKey)
    return true;
  return isValid(key);
};
var getStep = ({
  ctrlKey,
  shiftKey,
  metaKey
}) => {
  let ratio = 1;
  if (metaKey || ctrlKey)
    ratio = 0.1;
  if (shiftKey)
    ratio = 10;
  return ratio;
};
var useNumberInput = (props = {}) => {
  const {
    id,
    name,
    value: valueProp,
    defaultValue,
    inputMode = "decimal",
    pattern = "[0-9]*(.[0-9]+)?",
    required,
    disabled,
    readOnly,
    focusInputOnChange = true,
    clampValueOnBlur = true,
    keepWithinRange = true,
    allowMouseWheel,
    min = Number.MIN_SAFE_INTEGER,
    max = Number.MAX_SAFE_INTEGER,
    step: stepProp,
    precision,
    parse: parseProp,
    format: formatProp,
    onInvalid: onInvalidProp,
    isValidCharacter: isValidCharacterProp,
    getAriaValueText: getAriaValueTextProp,
    onChange: onChangeProp,
    onFocus: onFocusProp,
    onBlur: onBlurProp,
    "aria-invalid": isInvalid,
    ...rest
  } = useFormControlProps(props);
  const formControlProps = pickObject(rest, formControlProperties);
  const isRequired = required;
  const isReadOnly = readOnly;
  const isDisabled = disabled;
  const [isFocused, setFocused] = useState(false);
  const isInteractive = !(readOnly || disabled);
  const inputRef = useRef(null);
  const inputSelectionRef = useRef(null);
  const incrementRef = useRef(null);
  const decrementRef = useRef(null);
  const onFocus = useCallbackRef(
    handlerAll(onFocusProp, (ev) => {
      var _a, _b, _c;
      setFocused(true);
      if (!inputSelectionRef.current)
        return;
      ev.target.selectionStart = (_b = inputSelectionRef.current.start) != null ? _b : (_a = ev.currentTarget.value) == null ? void 0 : _a.length;
      ev.currentTarget.selectionEnd = (_c = inputSelectionRef.current.end) != null ? _c : ev.currentTarget.selectionStart;
    })
  );
  const onBlur = useCallbackRef(
    handlerAll(onBlurProp, () => {
      setFocused(false);
      if (clampValueOnBlur)
        validateAndClamp();
    })
  );
  const onInvalid = useCallbackRef(onInvalidProp);
  const getAriaValueText = useCallbackRef(getAriaValueTextProp);
  const isValidCharacter = useCallbackRef(
    isValidCharacterProp != null ? isValidCharacterProp : isDefaultValidCharacter
  );
  const {
    isMin,
    isMax,
    isOut,
    value,
    valueAsNumber,
    setValue,
    update,
    cast,
    ...counter
  } = useCounter({
    value: valueProp,
    defaultValue,
    step: stepProp,
    min,
    max,
    precision,
    keepWithinRange,
    onChange: onChangeProp
  });
  const valueText = useMemo(() => {
    let text = getAriaValueText == null ? void 0 : getAriaValueText(value);
    if (text != null)
      return text;
    text = value.toString();
    return !text ? void 0 : text;
  }, [value, getAriaValueText]);
  const sanitize = useCallback(
    (value2) => value2.split("").filter(isValidCharacter).join(""),
    [isValidCharacter]
  );
  const parse = useCallback(
    (value2) => {
      var _a;
      return (_a = parseProp == null ? void 0 : parseProp(value2)) != null ? _a : value2;
    },
    [parseProp]
  );
  const format = useCallback(
    (value2) => {
      var _a;
      return ((_a = formatProp == null ? void 0 : formatProp(value2)) != null ? _a : value2).toString();
    },
    [formatProp]
  );
  const increment = useCallback(
    (step = stepProp != null ? stepProp : 1) => {
      if (isInteractive)
        counter.increment(step);
    },
    [isInteractive, counter, stepProp]
  );
  const decrement = useCallback(
    (step = stepProp != null ? stepProp : 1) => {
      if (isInteractive)
        counter.decrement(step);
    },
    [isInteractive, counter, stepProp]
  );
  const validateAndClamp = useCallback(() => {
    let next = value;
    if (value === "")
      return;
    const valueStartsWithE = /^[eE]/.test(value.toString());
    if (valueStartsWithE) {
      setValue("");
    } else {
      if (valueAsNumber < min)
        next = min;
      if (valueAsNumber > max)
        next = max;
      cast(next);
    }
  }, [cast, max, min, setValue, value, valueAsNumber]);
  const onChange = useCallback(
    (ev) => {
      if (ev.nativeEvent.isComposing)
        return;
      const parsedInput = parse(ev.currentTarget.value);
      update(sanitize(parsedInput));
      inputSelectionRef.current = {
        start: ev.currentTarget.selectionStart,
        end: ev.currentTarget.selectionEnd
      };
    },
    [parse, update, sanitize]
  );
  const onKeyDown = useCallback(
    (ev) => {
      if (ev.nativeEvent.isComposing)
        return;
      if (!isValidNumericKeyboardEvent(ev, isValidCharacter))
        ev.preventDefault();
      const step = getStep(ev) * (stepProp != null ? stepProp : 1);
      const keyMap = {
        ArrowUp: () => increment(step),
        ArrowDown: () => decrement(step),
        Home: () => update(min),
        End: () => update(max)
      };
      const action = keyMap[ev.key];
      if (!action)
        return;
      ev.preventDefault();
      action(ev);
    },
    [decrement, increment, isValidCharacter, max, min, stepProp, update]
  );
  const { up, down, stop, isSpinning } = useSpinner(increment, decrement);
  useAttributeObserver(incrementRef, ["disabled"], isSpinning, stop);
  useAttributeObserver(decrementRef, ["disabled"], isSpinning, stop);
  const focusInput = useCallback(() => {
    if (focusInputOnChange)
      requestAnimationFrame(() => {
        var _a;
        (_a = inputRef.current) == null ? void 0 : _a.focus();
      });
  }, [focusInputOnChange]);
  const eventUp = useCallback(
    (ev) => {
      ev.preventDefault();
      up();
      focusInput();
    },
    [focusInput, up]
  );
  const eventDown = useCallback(
    (ev) => {
      ev.preventDefault();
      down();
      focusInput();
    },
    [focusInput, down]
  );
  useUpdateEffect(() => {
    if (valueAsNumber > max) {
      onInvalid == null ? void 0 : onInvalid("rangeOverflow", format(value), valueAsNumber);
    } else if (valueAsNumber < min) {
      onInvalid == null ? void 0 : onInvalid("rangeOverflow", format(value), valueAsNumber);
    }
  }, [valueAsNumber, value, format, onInvalid]);
  useSafeLayoutEffect(() => {
    if (!inputRef.current)
      return;
    const notInSync = inputRef.current.value != value;
    if (!notInSync)
      return;
    const parsedInput = parse(inputRef.current.value);
    setValue(sanitize(parsedInput));
  }, [parse, sanitize]);
  useEventListener(
    () => inputRef.current,
    "wheel",
    (ev) => {
      var _a, _b;
      const ownerDocument = (_b = (_a = inputRef.current) == null ? void 0 : _a.ownerDocument) != null ? _b : document;
      const isFocused2 = ownerDocument.activeElement === inputRef.current;
      if (!allowMouseWheel || !isFocused2)
        return;
      ev.preventDefault();
      const step = getStep(ev) * (stepProp != null ? stepProp : 1);
      const direction = Math.sign(ev.deltaY);
      if (direction === -1) {
        increment(step);
      } else if (direction === 1) {
        decrement(step);
      }
    },
    { passive: false }
  );
  const getInputProps = useCallback(
    (props2 = {}, ref = null) => ({
      id,
      name,
      type: "text",
      role: "spinbutton",
      inputMode,
      pattern,
      required,
      disabled,
      readOnly,
      ...formControlProps,
      ...props2,
      min,
      max,
      step: stepProp,
      ref: mergeRefs(inputRef, ref),
      value: format(value),
      "aria-valuemin": min,
      "aria-valuemax": max,
      "aria-valuenow": Number.isNaN(valueAsNumber) ? void 0 : valueAsNumber,
      "aria-valuetext": valueText,
      "aria-invalid": ariaAttr(isInvalid != null ? isInvalid : isOut),
      autoComplete: "off",
      autoCorrect: "off",
      onChange: handlerAll(props2.onChange, onChange),
      onKeyDown: handlerAll(props2.onKeyDown, onKeyDown),
      onFocus: handlerAll(props2.onFocus, onFocus),
      onBlur: handlerAll(props2.onBlur, onBlur)
    }),
    [
      id,
      name,
      inputMode,
      pattern,
      required,
      disabled,
      readOnly,
      formControlProps,
      min,
      max,
      stepProp,
      format,
      value,
      valueAsNumber,
      valueText,
      isInvalid,
      isOut,
      onChange,
      onKeyDown,
      onFocus,
      onBlur
    ]
  );
  const getIncrementProps = useCallback(
    (props2 = {}, ref = null) => {
      var _a;
      const trulyDisabled = disabled || keepWithinRange && isMax;
      return {
        required,
        readOnly,
        disabled: trulyDisabled,
        ...formControlProps,
        ...props2,
        style: {
          ...props2.style,
          cursor: readOnly ? "not-allowed" : (_a = props2.style) == null ? void 0 : _a.cursor
        },
        ref: mergeRefs(ref, incrementRef),
        role: "button",
        tabIndex: -1,
        onPointerDown: handlerAll(props2.onPointerDown, (ev) => {
          if (ev.button === 0 && !trulyDisabled)
            eventUp(ev);
        }),
        onPointerLeave: handlerAll(props2.onPointerLeave, stop),
        onPointerUp: handlerAll(props2.onPointerUp, stop)
      };
    },
    [
      disabled,
      keepWithinRange,
      isMax,
      required,
      readOnly,
      formControlProps,
      stop,
      eventUp
    ]
  );
  const getDecrementProps = useCallback(
    (props2 = {}, ref = null) => {
      var _a;
      const trulyDisabled = disabled || keepWithinRange && isMin;
      return {
        required,
        readOnly,
        disabled: trulyDisabled,
        ...formControlProps,
        ...props2,
        style: {
          ...props2.style,
          cursor: readOnly ? "not-allowed" : (_a = props2.style) == null ? void 0 : _a.cursor
        },
        ref: mergeRefs(ref, decrementRef),
        role: "button",
        tabIndex: -1,
        onPointerDown: handlerAll(props2.onPointerDown, (ev) => {
          if (ev.button === 0 && !trulyDisabled)
            eventDown(ev);
        }),
        onPointerLeave: handlerAll(props2.onPointerLeave, stop),
        onPointerUp: handlerAll(props2.onPointerUp, stop)
      };
    },
    [
      disabled,
      keepWithinRange,
      isMin,
      required,
      readOnly,
      formControlProps,
      stop,
      eventDown
    ]
  );
  return {
    props: rest,
    value: format(value),
    valueAsNumber,
    isFocused,
    isRequired,
    isReadOnly,
    isDisabled,
    getInputProps,
    getIncrementProps,
    getDecrementProps
  };
};
var INTERVAL = 50;
var DELAY = 300;
var useSpinner = (increment, decrement) => {
  const [isSpinning, setIsSpinning] = useState(false);
  const [action, setAction] = useState(null);
  const [isOnce, setIsOnce] = useState(true);
  const timeoutRef = useRef(null);
  const removeTimeout = () => clearTimeout(timeoutRef.current);
  useInterval(
    () => {
      if (action === "increment")
        increment();
      if (action === "decrement")
        decrement();
    },
    isSpinning ? INTERVAL : null
  );
  const up = useCallback(() => {
    if (isOnce)
      increment();
    timeoutRef.current = setTimeout(() => {
      setIsOnce(false);
      setIsSpinning(true);
      setAction("increment");
    }, DELAY);
  }, [increment, isOnce]);
  const down = useCallback(() => {
    if (isOnce)
      decrement();
    timeoutRef.current = setTimeout(() => {
      setIsOnce(false);
      setIsSpinning(true);
      setAction("decrement");
    }, DELAY);
  }, [decrement, isOnce]);
  const stop = useCallback(() => {
    setIsOnce(true);
    setIsSpinning(false);
    removeTimeout();
  }, []);
  useEffect(() => {
    return () => removeTimeout();
  }, []);
  return { up, down, stop, isSpinning };
};
var useAttributeObserver = (ref, attributeFilter, enabled, func) => {
  useEffect(() => {
    var _a;
    if (!ref.current || !enabled)
      return;
    const ownerDocument = (_a = ref.current.ownerDocument.defaultView) != null ? _a : window;
    const observer = new ownerDocument.MutationObserver((changes) => {
      for (const { type, attributeName } of changes) {
        if (type === "attributes" && attributeName && attributeFilter.includes(attributeName))
          func();
      }
    });
    observer.observe(ref.current, { attributes: true, attributeFilter });
    return () => observer.disconnect();
  });
};
var [NumberInputContextProvider, useNumberInputContext] = createContext({
  strict: false,
  name: "NumberInputContext"
});
var NumberInput = forwardRef(
  (props, ref) => {
    const [styles, mergedProps] = useMultiComponentStyle("NumberInput", props);
    const {
      className,
      isStepper = true,
      containerProps,
      addonProps,
      incrementProps,
      decrementProps,
      ...computedProps
    } = omitThemeProps(mergedProps);
    const {
      getInputProps,
      getIncrementProps,
      getDecrementProps,
      props: rest
    } = useNumberInput(computedProps);
    const css = {
      position: "relative",
      zIndex: 0,
      ...styles.container
    };
    return /* @__PURE__ */ jsx(
      NumberInputContextProvider,
      {
        value: { getInputProps, getIncrementProps, getDecrementProps, styles },
        children: /* @__PURE__ */ jsxs(
          ui.div,
          {
            className: cx("ui-number-input", className),
            __css: css,
            ...containerProps,
            children: [
              /* @__PURE__ */ jsx(
                NumberInputField,
                {
                  ...getInputProps(rest, ref)
                }
              ),
              isStepper ? /* @__PURE__ */ jsxs(NumberInputAddon, { ...addonProps, children: [
                /* @__PURE__ */ jsx(NumberIncrementStepper, { ...incrementProps }),
                /* @__PURE__ */ jsx(NumberDecrementStepper, { ...decrementProps })
              ] }) : null
            ]
          }
        )
      }
    );
  }
);
var NumberInputField = forwardRef(
  ({ className, ...rest }, ref) => {
    const { styles } = useNumberInputContext();
    const css = {
      width: "100%",
      ...styles.field
    };
    return /* @__PURE__ */ jsx(
      ui.input,
      {
        ref,
        className: cx("ui-number-input__field", className),
        __css: css,
        ...rest
      }
    );
  }
);
var NumberInputAddon = forwardRef(
  ({ className, ...rest }, ref) => {
    const { styles } = useNumberInputContext();
    const css = {
      display: "flex",
      flexDirection: "column",
      position: "absolute",
      top: "0",
      insetEnd: "0px",
      margin: "1px",
      height: "calc(100% - 2px)",
      zIndex: "fallback(yamcha, 1)",
      ...styles.addon
    };
    return /* @__PURE__ */ jsx(
      ui.div,
      {
        ref,
        className: cx("ui-number-input__addon", className),
        "aria-hidden": true,
        __css: css,
        ...rest
      }
    );
  }
);
var Stepper = ui("div", {
  baseStyle: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    flex: 1,
    transitionProperty: "common",
    transitionDuration: "normal",
    userSelect: "none",
    cursor: "pointer",
    lineHeight: "normal"
  }
});
var NumberIncrementStepper = forwardRef(
  ({ className, children, ...rest }, ref) => {
    const { getIncrementProps, styles } = useNumberInputContext();
    const css = { ...styles.stepper };
    return /* @__PURE__ */ jsx(
      Stepper,
      {
        className: cx("ui-number-input__stepper--up", className),
        ...getIncrementProps(rest, ref),
        __css: css,
        children: children != null ? children : /* @__PURE__ */ jsx(ChevronIcon, { __css: { transform: "rotate(180deg)" } })
      }
    );
  }
);
var NumberDecrementStepper = forwardRef(
  ({ className, children, ...rest }, ref) => {
    const { getDecrementProps, styles } = useNumberInputContext();
    const css = { ...styles.stepper };
    return /* @__PURE__ */ jsx(
      Stepper,
      {
        className: cx("ui-number-input__stepper--down", className),
        ...getDecrementProps(rest, ref),
        __css: css,
        children: children != null ? children : /* @__PURE__ */ jsx(ChevronIcon, {})
      }
    );
  }
);

export {
  useNumberInput,
  NumberInput
};
//# sourceMappingURL=chunk-GLJTPTRV.mjs.map