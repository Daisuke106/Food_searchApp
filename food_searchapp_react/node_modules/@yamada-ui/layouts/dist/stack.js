"use client"
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/stack.tsx
var stack_exports = {};
__export(stack_exports, {
  HStack: () => HStack,
  Stack: () => Stack,
  VStack: () => VStack,
  ZStack: () => ZStack
});
module.exports = __toCommonJS(stack_exports);
var import_core = require("@yamada-ui/core");
var import_utils = require("@yamada-ui/utils");
var import_react = require("react");
var import_jsx_runtime = require("react/jsx-runtime");
var Stack = (0, import_core.forwardRef)(
  ({
    direction: flexDirection = "column",
    justify: justifyContent,
    align: alignItems,
    wrap: flexWrap,
    gap = "fallback(md, 1rem)",
    divider,
    className,
    children,
    ...rest
  }, ref) => {
    const isColumn = (value) => value === "column" || value === "column-reverse";
    const dividerCSS = (0, import_react.useMemo)(
      () => ({
        w: (0, import_utils.replaceObject)(
          flexDirection,
          (value) => isColumn(value) ? "100%" : "fix-content"
        ),
        h: (0, import_utils.replaceObject)(
          flexDirection,
          (value) => isColumn(value) ? "fix-content" : "100%"
        ),
        borderLeftWidth: (0, import_utils.replaceObject)(
          flexDirection,
          (value) => isColumn(value) ? 0 : "1px"
        ),
        borderBottomWidth: (0, import_utils.replaceObject)(
          flexDirection,
          (value) => isColumn(value) ? "1px" : 0
        )
      }),
      [flexDirection]
    );
    const validChildren = (0, import_utils.getValidChildren)(children);
    const cloneChildren = divider ? validChildren.map((child, index) => {
      const key = typeof child.key !== "undefined" ? child.key : index;
      const cloneDivider = (0, import_react.cloneElement)(
        divider,
        {
          __css: dividerCSS
        }
      );
      return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_react.Fragment, { children: [
        !!index ? cloneDivider : null,
        child
      ] }, key);
    }) : validChildren;
    const css = (0, import_react.useMemo)(
      () => ({
        display: "flex",
        flexDirection,
        justifyContent,
        alignItems,
        flexWrap,
        gap
      }),
      [alignItems, flexDirection, flexWrap, gap, justifyContent]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_core.ui.div,
      {
        ref,
        className: (0, import_utils.cx)("ui-stack", className),
        __css: css,
        ...rest,
        children: cloneChildren
      }
    );
  }
);
var HStack = (0, import_core.forwardRef)(
  ({ className, ...rest }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    Stack,
    {
      ref,
      className: (0, import_utils.cx)("ui-stack--horizontal", className),
      direction: "row",
      align: "center",
      ...rest
    }
  )
);
var VStack = (0, import_core.forwardRef)(
  ({ className, ...rest }, ref) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    Stack,
    {
      ref,
      className: (0, import_utils.cx)("ui-stack--vertical", className),
      direction: "column",
      align: "stretch",
      w: "100%",
      ...rest
    }
  )
);
var ZStack = (0, import_core.forwardRef)(
  ({
    className,
    direction = "bottom",
    startIndex = 0,
    gap = "fallback(md, 1rem)",
    reverse = false,
    fit = true,
    children,
    ...rest
  }, ref) => {
    const refMap = (0, import_react.useRef)(/* @__PURE__ */ new Map());
    const [rect, setRect] = (0, import_react.useState)({
      width: 0,
      height: 0
    });
    const boxSize = {
      minWidth: `${rect.width}px`,
      minHeight: `${rect.height}px`
    };
    const css = {
      position: "relative",
      overflow: "hidden",
      var: [{ __prefix: "ui", name: "space", token: "spaces", value: gap }],
      ...fit ? boxSize : {}
    };
    const vertical = (0, import_react.useCallback)(
      (space) => {
        if (direction.includes("top")) {
          return { [!reverse ? "bottom" : "top"]: space };
        } else if (direction.includes("bottom")) {
          return { [!reverse ? "top" : "bottom"]: space };
        } else {
          return { [!reverse ? "top" : "bottom"]: 0 };
        }
      },
      [direction, reverse]
    );
    const horizontal = (0, import_react.useCallback)(
      (space) => {
        if (direction.includes("left")) {
          return { [!reverse ? "right" : "left"]: space };
        } else if (direction.includes("right")) {
          return { [!reverse ? "left" : "right"]: space };
        } else {
          return { [!reverse ? "left" : "right"]: 0 };
        }
      },
      [direction, reverse]
    );
    const cloneChildren = (0, import_react.useMemo)(() => {
      const validChildren = (0, import_utils.getValidChildren)(children);
      const clonedChildren = validChildren.map((child, index) => {
        var _a;
        const ref2 = (0, import_react.createRef)();
        refMap.current.set(index, ref2);
        const key = (_a = child.key) != null ? _a : index;
        const zIndex = startIndex + index;
        const space = `calc(var(--ui-space) * ${index})`;
        let css2 = {};
        css2 = {
          ...css2,
          position: "absolute",
          zIndex
        };
        css2 = { ...css2, ...vertical(space) };
        css2 = { ...css2, ...horizontal(space) };
        const props = {
          ...child.props,
          ref: (0, import_utils.mergeRefs)(child.ref, ref2),
          __css: css2
        };
        const clonedChild = (0, import_react.cloneElement)(child, props);
        return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: clonedChild }, key);
      });
      return clonedChildren;
    }, [children, startIndex, vertical, horizontal]);
    (0, import_react.useEffect)(() => {
      if (!fit)
        return;
      let isNegativeLeft = direction.includes("left");
      let isNegativeTop = direction.includes("top");
      let width = 0;
      let height = 0;
      if (reverse) {
        isNegativeLeft = !isNegativeLeft;
        isNegativeTop = !isNegativeTop;
      }
      for (const ref2 of refMap.current.values()) {
        if (!ref2.current)
          continue;
        let { offsetParent, offsetWidth, offsetHeight, offsetTop, offsetLeft } = ref2.current;
        if (!offsetParent)
          continue;
        if (isNegativeLeft) {
          offsetLeft = offsetParent.offsetWidth - offsetLeft - offsetWidth;
        }
        if (isNegativeTop) {
          offsetTop = offsetParent.offsetHeight - offsetTop - offsetHeight;
        }
        offsetWidth += offsetLeft;
        offsetHeight += offsetTop;
        if (offsetWidth > width)
          width = offsetWidth;
        if (offsetHeight > height)
          height = offsetHeight;
      }
      setRect({ width, height });
    }, [cloneChildren, direction, reverse, fit]);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_core.ui.div,
      {
        ref,
        className: (0, import_utils.cx)("ui-stack--depth", className),
        __css: css,
        ...rest,
        children: cloneChildren
      }
    );
  }
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HStack,
  Stack,
  VStack,
  ZStack
});
//# sourceMappingURL=stack.js.map