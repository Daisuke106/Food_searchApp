"use client"

// src/use-pagination.ts
import { useControllableState } from "@yamada-ui/use-controllable-state";
import { useValue } from "@yamada-ui/use-value";
import { createContext } from "@yamada-ui/utils";
import { useCallback, useMemo } from "react";
var [PaginationProvider, usePaginationContext] = createContext({
  strict: false,
  name: "PaginationContext"
});
var computedRange = (start, end) => Array.from({ length: end - start + 1 }, (_, index) => index + start);
var usePagination = ({
  page,
  defaultPage = 1,
  total,
  siblings = 1,
  boundaries = 1,
  isDisabled = false,
  onChange: onChangeProp
}) => {
  const computedSiblings = useValue(siblings);
  const computedBoundaries = useValue(boundaries);
  const [currentPage, setCurrentPage] = useControllableState({
    value: page,
    defaultValue: defaultPage,
    onChange: onChangeProp
  });
  const onFirst = useCallback(() => setCurrentPage(1), [setCurrentPage]);
  const onLast = useCallback(
    () => setCurrentPage(total),
    [setCurrentPage, total]
  );
  const onPrev = useCallback(
    () => setCurrentPage((prev) => prev === 1 ? prev : prev - 1),
    [setCurrentPage]
  );
  const onNext = useCallback(
    () => setCurrentPage((prev) => prev === total ? prev : prev + 1),
    [setCurrentPage, total]
  );
  const onChange = useCallback(
    (page2) => setCurrentPage(page2),
    [setCurrentPage]
  );
  const range = useMemo(() => {
    const minimumTotal = computedSiblings * 2 + 3 + computedBoundaries * 2;
    if (minimumTotal >= total)
      return computedRange(1, total);
    const prevSiblings = Math.max(
      currentPage - computedSiblings,
      computedBoundaries
    );
    const nextSiblings = Math.min(
      currentPage + computedSiblings,
      total - computedBoundaries
    );
    const prevDots = prevSiblings > computedBoundaries + 2;
    const nextDots = nextSiblings < total - (computedBoundaries + 1);
    if (!prevDots && nextDots) {
      const prevPages = computedSiblings * 2 + computedBoundaries + 2;
      return [
        ...computedRange(1, prevPages),
        "dots",
        ...computedRange(total - (computedBoundaries - 1), total)
      ];
    }
    if (prevDots && !nextDots) {
      const nextPages = computedBoundaries + 1 + 2 * computedSiblings;
      return [
        ...computedRange(1, computedBoundaries),
        "dots",
        ...computedRange(total - nextPages, total)
      ];
    }
    return [
      ...computedRange(1, computedBoundaries),
      "dots",
      ...computedRange(prevSiblings, nextSiblings),
      "dots",
      ...computedRange(total - computedBoundaries + 1, total)
    ];
  }, [computedBoundaries, computedSiblings, currentPage, total]);
  return {
    currentPage,
    total,
    isDisabled,
    onFirst,
    onLast,
    onPrev,
    onNext,
    onChange,
    range
  };
};

export {
  PaginationProvider,
  usePaginationContext,
  computedRange,
  usePagination
};
//# sourceMappingURL=chunk-EKJTBKZD.mjs.map