{"version":3,"sources":["../src/use-pagination.ts"],"sourcesContent":["import type { CSSUIObject, Token } from \"@yamada-ui/core\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { useValue } from \"@yamada-ui/use-value\"\nimport { createContext } from \"@yamada-ui/utils\"\nimport { useCallback, useMemo } from \"react\"\n\ntype PaginationContext = Record<string, CSSUIObject>\n\nexport const [PaginationProvider, usePaginationContext] =\n  createContext<PaginationContext>({\n    strict: false,\n    name: \"PaginationContext\",\n  })\n\nexport type UsePaginationProps = {\n  /**\n   * The page of the pagination.\n   * Should be less than `total` and greater than `1`.\n   */\n  page?: number\n  /**\n   * The initial page of the pagination.\n   * Should be less than `total` and greater than `1`.\n   *\n   * @default 1\n   */\n  defaultPage?: number\n  /**\n   * The total number of pages in pagination.\n   */\n  total: number\n  /** Number of siblings displayed on the left/right side of selected page.\n   *\n   * @default 1\n   */\n  siblings?: Token<number>\n  /**\n   * Number of elements visible on the left/right edges.\n   *\n   * @default 1\n   */\n  boundaries?: Token<number>\n  /**\n   * If `true`, the pagination all item will be disabled.\n   *\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * The callback invoked when the page changes.\n   */\n  onChange?: (page: number) => void\n}\n\nexport const computedRange = (start: number, end: number) =>\n  Array.from({ length: end - start + 1 }, (_, index) => index + start)\n\nexport const usePagination = ({\n  page,\n  defaultPage = 1,\n  total,\n  siblings = 1,\n  boundaries = 1,\n  isDisabled = false,\n  onChange: onChangeProp,\n}: UsePaginationProps) => {\n  const computedSiblings = useValue(siblings)\n  const computedBoundaries = useValue(boundaries)\n\n  const [currentPage, setCurrentPage] = useControllableState({\n    value: page,\n    defaultValue: defaultPage,\n    onChange: onChangeProp,\n  })\n\n  const onFirst = useCallback(() => setCurrentPage(1), [setCurrentPage])\n\n  const onLast = useCallback(\n    () => setCurrentPage(total),\n    [setCurrentPage, total],\n  )\n\n  const onPrev = useCallback(\n    () => setCurrentPage((prev) => (prev === 1 ? prev : prev - 1)),\n    [setCurrentPage],\n  )\n\n  const onNext = useCallback(\n    () => setCurrentPage((prev) => (prev === total ? prev : prev + 1)),\n    [setCurrentPage, total],\n  )\n\n  const onChange = useCallback(\n    (page: number) => setCurrentPage(page),\n    [setCurrentPage],\n  )\n\n  const range = useMemo((): (number | \"dots\")[] => {\n    const minimumTotal = computedSiblings * 2 + 3 + computedBoundaries * 2\n\n    if (minimumTotal >= total) return computedRange(1, total)\n\n    const prevSiblings = Math.max(\n      currentPage - computedSiblings,\n      computedBoundaries,\n    )\n    const nextSiblings = Math.min(\n      currentPage + computedSiblings,\n      total - computedBoundaries,\n    )\n\n    const prevDots = prevSiblings > computedBoundaries + 2\n    const nextDots = nextSiblings < total - (computedBoundaries + 1)\n\n    if (!prevDots && nextDots) {\n      const prevPages = computedSiblings * 2 + computedBoundaries + 2\n\n      return [\n        ...computedRange(1, prevPages),\n        \"dots\",\n        ...computedRange(total - (computedBoundaries - 1), total),\n      ]\n    }\n\n    if (prevDots && !nextDots) {\n      const nextPages = computedBoundaries + 1 + 2 * computedSiblings\n\n      return [\n        ...computedRange(1, computedBoundaries),\n        \"dots\",\n        ...computedRange(total - nextPages, total),\n      ]\n    }\n\n    return [\n      ...computedRange(1, computedBoundaries),\n      \"dots\",\n      ...computedRange(prevSiblings, nextSiblings),\n      \"dots\",\n      ...computedRange(total - computedBoundaries + 1, total),\n    ]\n  }, [computedBoundaries, computedSiblings, currentPage, total])\n\n  return {\n    currentPage,\n    total,\n    isDisabled,\n    onFirst,\n    onLast,\n    onPrev,\n    onNext,\n    onChange,\n    range,\n  }\n}\n\nexport type UsePaginationReturn = ReturnType<typeof usePagination>\n"],"mappings":";;;AACA,SAAS,4BAA4B;AACrC,SAAS,gBAAgB;AACzB,SAAS,qBAAqB;AAC9B,SAAS,aAAa,eAAe;AAI9B,IAAM,CAAC,oBAAoB,oBAAoB,IACpD,cAAiC;AAAA,EAC/B,QAAQ;AAAA,EACR,MAAM;AACR,CAAC;AA0CI,IAAM,gBAAgB,CAAC,OAAe,QAC3C,MAAM,KAAK,EAAE,QAAQ,MAAM,QAAQ,EAAE,GAAG,CAAC,GAAG,UAAU,QAAQ,KAAK;AAE9D,IAAM,gBAAgB,CAAC;AAAA,EAC5B;AAAA,EACA,cAAc;AAAA,EACd;AAAA,EACA,WAAW;AAAA,EACX,aAAa;AAAA,EACb,aAAa;AAAA,EACb,UAAU;AACZ,MAA0B;AACxB,QAAM,mBAAmB,SAAS,QAAQ;AAC1C,QAAM,qBAAqB,SAAS,UAAU;AAE9C,QAAM,CAAC,aAAa,cAAc,IAAI,qBAAqB;AAAA,IACzD,OAAO;AAAA,IACP,cAAc;AAAA,IACd,UAAU;AAAA,EACZ,CAAC;AAED,QAAM,UAAU,YAAY,MAAM,eAAe,CAAC,GAAG,CAAC,cAAc,CAAC;AAErE,QAAM,SAAS;AAAA,IACb,MAAM,eAAe,KAAK;AAAA,IAC1B,CAAC,gBAAgB,KAAK;AAAA,EACxB;AAEA,QAAM,SAAS;AAAA,IACb,MAAM,eAAe,CAAC,SAAU,SAAS,IAAI,OAAO,OAAO,CAAE;AAAA,IAC7D,CAAC,cAAc;AAAA,EACjB;AAEA,QAAM,SAAS;AAAA,IACb,MAAM,eAAe,CAAC,SAAU,SAAS,QAAQ,OAAO,OAAO,CAAE;AAAA,IACjE,CAAC,gBAAgB,KAAK;AAAA,EACxB;AAEA,QAAM,WAAW;AAAA,IACf,CAACA,UAAiB,eAAeA,KAAI;AAAA,IACrC,CAAC,cAAc;AAAA,EACjB;AAEA,QAAM,QAAQ,QAAQ,MAA2B;AAC/C,UAAM,eAAe,mBAAmB,IAAI,IAAI,qBAAqB;AAErE,QAAI,gBAAgB;AAAO,aAAO,cAAc,GAAG,KAAK;AAExD,UAAM,eAAe,KAAK;AAAA,MACxB,cAAc;AAAA,MACd;AAAA,IACF;AACA,UAAM,eAAe,KAAK;AAAA,MACxB,cAAc;AAAA,MACd,QAAQ;AAAA,IACV;AAEA,UAAM,WAAW,eAAe,qBAAqB;AACrD,UAAM,WAAW,eAAe,SAAS,qBAAqB;AAE9D,QAAI,CAAC,YAAY,UAAU;AACzB,YAAM,YAAY,mBAAmB,IAAI,qBAAqB;AAE9D,aAAO;AAAA,QACL,GAAG,cAAc,GAAG,SAAS;AAAA,QAC7B;AAAA,QACA,GAAG,cAAc,SAAS,qBAAqB,IAAI,KAAK;AAAA,MAC1D;AAAA,IACF;AAEA,QAAI,YAAY,CAAC,UAAU;AACzB,YAAM,YAAY,qBAAqB,IAAI,IAAI;AAE/C,aAAO;AAAA,QACL,GAAG,cAAc,GAAG,kBAAkB;AAAA,QACtC;AAAA,QACA,GAAG,cAAc,QAAQ,WAAW,KAAK;AAAA,MAC3C;AAAA,IACF;AAEA,WAAO;AAAA,MACL,GAAG,cAAc,GAAG,kBAAkB;AAAA,MACtC;AAAA,MACA,GAAG,cAAc,cAAc,YAAY;AAAA,MAC3C;AAAA,MACA,GAAG,cAAc,QAAQ,qBAAqB,GAAG,KAAK;AAAA,IACxD;AAAA,EACF,GAAG,CAAC,oBAAoB,kBAAkB,aAAa,KAAK,CAAC;AAE7D,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;","names":["page"]}