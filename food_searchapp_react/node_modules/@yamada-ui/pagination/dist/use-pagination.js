"use client"
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/use-pagination.ts
var use_pagination_exports = {};
__export(use_pagination_exports, {
  PaginationProvider: () => PaginationProvider,
  computedRange: () => computedRange,
  usePagination: () => usePagination,
  usePaginationContext: () => usePaginationContext
});
module.exports = __toCommonJS(use_pagination_exports);
var import_use_controllable_state = require("@yamada-ui/use-controllable-state");
var import_use_value = require("@yamada-ui/use-value");
var import_utils = require("@yamada-ui/utils");
var import_react = require("react");
var [PaginationProvider, usePaginationContext] = (0, import_utils.createContext)({
  strict: false,
  name: "PaginationContext"
});
var computedRange = (start, end) => Array.from({ length: end - start + 1 }, (_, index) => index + start);
var usePagination = ({
  page,
  defaultPage = 1,
  total,
  siblings = 1,
  boundaries = 1,
  isDisabled = false,
  onChange: onChangeProp
}) => {
  const computedSiblings = (0, import_use_value.useValue)(siblings);
  const computedBoundaries = (0, import_use_value.useValue)(boundaries);
  const [currentPage, setCurrentPage] = (0, import_use_controllable_state.useControllableState)({
    value: page,
    defaultValue: defaultPage,
    onChange: onChangeProp
  });
  const onFirst = (0, import_react.useCallback)(() => setCurrentPage(1), [setCurrentPage]);
  const onLast = (0, import_react.useCallback)(
    () => setCurrentPage(total),
    [setCurrentPage, total]
  );
  const onPrev = (0, import_react.useCallback)(
    () => setCurrentPage((prev) => prev === 1 ? prev : prev - 1),
    [setCurrentPage]
  );
  const onNext = (0, import_react.useCallback)(
    () => setCurrentPage((prev) => prev === total ? prev : prev + 1),
    [setCurrentPage, total]
  );
  const onChange = (0, import_react.useCallback)(
    (page2) => setCurrentPage(page2),
    [setCurrentPage]
  );
  const range = (0, import_react.useMemo)(() => {
    const minimumTotal = computedSiblings * 2 + 3 + computedBoundaries * 2;
    if (minimumTotal >= total)
      return computedRange(1, total);
    const prevSiblings = Math.max(
      currentPage - computedSiblings,
      computedBoundaries
    );
    const nextSiblings = Math.min(
      currentPage + computedSiblings,
      total - computedBoundaries
    );
    const prevDots = prevSiblings > computedBoundaries + 2;
    const nextDots = nextSiblings < total - (computedBoundaries + 1);
    if (!prevDots && nextDots) {
      const prevPages = computedSiblings * 2 + computedBoundaries + 2;
      return [
        ...computedRange(1, prevPages),
        "dots",
        ...computedRange(total - (computedBoundaries - 1), total)
      ];
    }
    if (prevDots && !nextDots) {
      const nextPages = computedBoundaries + 1 + 2 * computedSiblings;
      return [
        ...computedRange(1, computedBoundaries),
        "dots",
        ...computedRange(total - nextPages, total)
      ];
    }
    return [
      ...computedRange(1, computedBoundaries),
      "dots",
      ...computedRange(prevSiblings, nextSiblings),
      "dots",
      ...computedRange(total - computedBoundaries + 1, total)
    ];
  }, [computedBoundaries, computedSiblings, currentPage, total]);
  return {
    currentPage,
    total,
    isDisabled,
    onFirst,
    onLast,
    onPrev,
    onNext,
    onChange,
    range
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PaginationProvider,
  computedRange,
  usePagination,
  usePaginationContext
});
//# sourceMappingURL=use-pagination.js.map