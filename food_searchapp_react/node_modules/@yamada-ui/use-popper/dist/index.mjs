"use client"

// src/index.ts
import { createPopper } from "@popperjs/core";
import { useValue } from "@yamada-ui/use-value";
import { mergeRefs } from "@yamada-ui/utils";
import { useCallback, useEffect, useRef } from "react";
var popperProperties = [
  "enabled",
  "offset",
  "gutter",
  "preventOverflow",
  "flip",
  "matchWidth",
  "boundary",
  "eventListeners",
  "strategy",
  "placement",
  "modifiers"
];
var defaultEventListeners = {
  scroll: true,
  resize: true
};
var transforms = {
  top: "bottom center",
  "top-start": "bottom left",
  "top-end": "bottom right",
  bottom: "top center",
  "bottom-start": "top left",
  "bottom-end": "top right",
  left: "right center",
  "left-start": "right top",
  "left-end": "right bottom",
  right: "left center",
  "right-start": "left top",
  "right-end": "left bottom"
};
var usePopper = ({
  enabled = true,
  eventListeners = true,
  matchWidth,
  offset,
  gutter: _gutter = 8,
  flip = true,
  preventOverflow = true,
  boundary = "clippingParents",
  strategy = "absolute",
  placement: _placement = "bottom",
  modifiers
} = {}) => {
  const reference = useRef(null);
  const popper = useRef(null);
  const instance = useRef(null);
  const gutter = useValue(_gutter);
  const placement = useValue(_placement);
  const cleanup = useRef(() => {
  });
  const setupPopper = useCallback(() => {
    var _a;
    if (!enabled || !reference.current || !popper.current)
      return;
    (_a = cleanup.current) == null ? void 0 : _a.call(cleanup);
    const modifierTransformOrigin = {
      name: "transformOrigin",
      enabled: true,
      phase: "write",
      fn: ({ state }) => {
        state.elements.popper.style.setProperty(
          "--popper-transform-origin",
          transforms[state.placement]
        );
      },
      effect: ({ state }) => () => {
        state.elements.popper.style.setProperty(
          "--popper-transform-origin",
          transforms[state.placement]
        );
      }
    };
    const modifierEventListeners = {
      name: "eventListeners",
      ...typeof eventListeners === "object" ? {
        enabled: true,
        options: { ...defaultEventListeners, ...eventListeners }
      } : {
        enabled: eventListeners,
        options: defaultEventListeners
      }
    };
    const modifierOffset = {
      name: "offset",
      options: { offset: offset != null ? offset : [0, gutter] }
    };
    const modifierFlip = {
      name: "flip",
      enabled: !!flip,
      options: { padding: 8 }
    };
    const modifierPreventOverflow = {
      name: "preventOverflow",
      enabled: !!preventOverflow,
      options: { boundary }
    };
    const modifierMatchWidth = {
      name: "matchWidth",
      enabled: !!matchWidth,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: ({ state }) => {
        state.styles.popper.width = `${state.rects.reference.width}px`;
      },
      effect: ({ state }) => () => {
        state.elements.popper.style.width = `${state.elements.reference.offsetWidth}px`;
      }
    };
    instance.current = createPopper(reference.current, popper.current, {
      placement,
      modifiers: [
        modifierTransformOrigin,
        modifierMatchWidth,
        modifierEventListeners,
        modifierOffset,
        modifierFlip,
        modifierPreventOverflow,
        ...modifiers != null ? modifiers : []
      ],
      strategy
    });
    instance.current.forceUpdate();
    cleanup.current = instance.current.destroy;
  }, [
    placement,
    enabled,
    modifiers,
    matchWidth,
    eventListeners,
    offset,
    gutter,
    flip,
    preventOverflow,
    boundary,
    strategy
  ]);
  useEffect(() => {
    return () => {
      var _a;
      if (reference.current || popper.current)
        return;
      (_a = instance.current) == null ? void 0 : _a.destroy();
      instance.current = null;
    };
  }, []);
  const referenceRef = useCallback(
    (el) => {
      reference.current = el;
      setupPopper();
    },
    [setupPopper]
  );
  const getReferenceProps = useCallback(
    (props = {}, ref = null) => ({
      ...props,
      ref: mergeRefs(referenceRef, ref)
    }),
    [referenceRef]
  );
  const popperRef = useCallback(
    (el) => {
      popper.current = el;
      setupPopper();
    },
    [setupPopper]
  );
  const getPopperProps = useCallback(
    (props = {}, ref = null) => ({
      ...props,
      ref: mergeRefs(popperRef, ref),
      style: {
        ...props.style,
        position: strategy,
        minWidth: matchWidth ? void 0 : "max-content",
        inset: "0 auto auto 0"
      }
    }),
    [strategy, popperRef, matchWidth]
  );
  return {
    update: () => {
      var _a;
      return (_a = instance.current) == null ? void 0 : _a.update();
    },
    forceUpdate: () => {
      var _a;
      return (_a = instance.current) == null ? void 0 : _a.forceUpdate();
    },
    transformOrigin: "var(--popper-transform-origin)",
    referenceRef,
    popperRef,
    getPopperProps,
    getReferenceProps
  };
};
export {
  popperProperties,
  usePopper
};
//# sourceMappingURL=index.mjs.map