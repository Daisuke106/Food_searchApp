"use client"

// src/radio-group.tsx
import { useFormControl as useFormControl2 } from "@yamada-ui/form-control";
import { Flex } from "@yamada-ui/layouts";
import { useControllableState } from "@yamada-ui/use-controllable-state";
import {
  createContext,
  cx as cx2,
  isObject,
  mergeRefs,
  useCallbackRef as useCallbackRef2,
  getValidChildren
} from "@yamada-ui/utils";
import { useCallback as useCallback2, useId as useId2, useRef, forwardRef as forwardRef2 } from "react";

// src/radio.tsx
import { ui, useMultiComponentStyle, omitThemeProps } from "@yamada-ui/core";
import {
  useFormControl,
  useFormControlProps,
  formControlProperties
} from "@yamada-ui/form-control";
import { trackFocusVisible } from "@yamada-ui/use-focus-visible";
import {
  cx,
  useCallbackRef,
  funcAll,
  handlerAll,
  dataAttr,
  splitObject
} from "@yamada-ui/utils";
import { forwardRef, useCallback, useEffect, useId, useState } from "react";
import { jsx, jsxs } from "react/jsx-runtime";
var useRadio = ({
  id,
  ...props
}) => {
  id != null ? id : id = useId();
  const {
    id: _id,
    name,
    value,
    isChecked: isCheckedProp,
    defaultIsChecked,
    required,
    disabled,
    readOnly,
    onChange: onChangeProp,
    onFocus: onFocusProp,
    onBlur: onBlurProp,
    ...computedProps
  } = useFormControlProps({ id, ...props });
  const [{ "aria-readonly": _ariaReadonly, ...formControlProps }, rest] = splitObject(computedProps, formControlProperties);
  const [isFocusVisible, setIsFocusVisible] = useState(false);
  const [isFocused, setFocused] = useState(false);
  const [isHovered, setHovered] = useState(false);
  const [isActive, setActive] = useState(false);
  const [isChecked, setIsChecked] = useState(!!defaultIsChecked);
  const isControlled = isCheckedProp !== void 0;
  const checked = isControlled ? isCheckedProp : isChecked;
  useEffect(() => {
    return trackFocusVisible(setIsFocusVisible);
  }, []);
  const onChange = useCallbackRef(
    (ev) => {
      if (readOnly || disabled) {
        ev.preventDefault();
        return;
      }
      if (!isControlled)
        setIsChecked(ev.target.checked);
      onChangeProp == null ? void 0 : onChangeProp(ev);
    },
    [readOnly, disabled, isControlled]
  );
  const onFocus = useCallbackRef(onFocusProp);
  const onBlur = useCallbackRef(onBlurProp);
  const onKeyDown = useCallback(
    ({ key }) => {
      if (key === " ")
        setActive(true);
    },
    [setActive]
  );
  const onKeyUp = useCallback(
    ({ key }) => {
      if (key === " ")
        setActive(false);
    },
    [setActive]
  );
  const getContainerProps = useCallback(
    (props2 = {}, ref = null) => ({
      ...formControlProps,
      ...props2,
      ref,
      "data-checked": dataAttr(checked)
    }),
    [checked, formControlProps]
  );
  const getIconProps = useCallback(
    (props2 = {}, ref = null) => ({
      ...formControlProps,
      ...props2,
      ref,
      "data-active": dataAttr(isActive),
      "data-hover": dataAttr(isHovered),
      "data-checked": dataAttr(checked),
      "data-focus": dataAttr(isFocused),
      "data-focus-visible": dataAttr(isFocused && isFocusVisible),
      "aria-hidden": true,
      onMouseDown: handlerAll(props2.onMouseDown, () => setActive(true)),
      onMouseUp: handlerAll(props2.onMouseUp, () => setActive(false)),
      onMouseEnter: handlerAll(props2.onMouseEnter, () => setHovered(true)),
      onMouseLeave: handlerAll(props2.onMouseLeave, () => setHovered(false))
    }),
    [checked, isActive, isFocused, isFocusVisible, isHovered, formControlProps]
  );
  const getInputProps = useCallback(
    (props2 = {}, ref = null) => ({
      ...formControlProps,
      ...props2,
      ref,
      id,
      type: "radio",
      name,
      value,
      required,
      disabled,
      readOnly,
      checked,
      style: {
        border: "0px",
        clip: "rect(0px, 0px, 0px, 0px)",
        height: "1px",
        width: "1px",
        margin: "-1px",
        padding: "0px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        position: "absolute"
      },
      onChange: handlerAll(props2.onChange, onChange),
      onBlur: handlerAll(props2.onBlur, onBlur, () => setFocused(false)),
      onFocus: handlerAll(props2.onFocus, onFocus, () => setFocused(true)),
      onKeyDown: handlerAll(props2.onKeyDown, onKeyDown),
      onKeyUp: handlerAll(props2.onKeyUp, onKeyUp)
    }),
    [
      formControlProps,
      id,
      name,
      value,
      required,
      disabled,
      readOnly,
      checked,
      onChange,
      onBlur,
      onFocus,
      onKeyDown,
      onKeyUp
    ]
  );
  const getLabelProps = useCallback(
    (props2 = {}, ref = null) => ({
      ...formControlProps,
      props: props2,
      ref,
      onMouseDown: handlerAll(props2.onMouseDown, (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
      }),
      onTouchStart: handlerAll(props2.onTouchStart, (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
      }),
      "data-checked": dataAttr(checked)
    }),
    [checked, formControlProps]
  );
  return {
    props: rest,
    isFocusVisible,
    isFocused,
    isHovered,
    isActive,
    isChecked: checked,
    getContainerProps,
    getInputProps,
    getIconProps,
    getLabelProps
  };
};
var Radio = forwardRef(
  (props, ref) => {
    var _a, _b, _c, _d;
    const group = useRadioGroupContext();
    const { value: groupValue, ...groupProps } = { ...group };
    const control = useFormControl(props);
    const [styles, mergedProps] = useMultiComponentStyle("Radio", {
      ...groupProps,
      ...props
    });
    const {
      className,
      gap = "0.5rem",
      isRequired = (_a = groupProps.isRequired) != null ? _a : control.isRequired,
      isReadOnly = (_b = groupProps.isReadOnly) != null ? _b : control.isReadOnly,
      isDisabled = (_c = groupProps.isDisabled) != null ? _c : control.isDisabled,
      isInvalid = (_d = groupProps.isInvalid) != null ? _d : control.isInvalid,
      iconProps,
      inputProps,
      labelProps,
      children,
      ...computedProps
    } = omitThemeProps(mergedProps);
    const isChecked = groupValue && computedProps.value ? groupValue === computedProps.value : computedProps.isChecked;
    const onChange = groupProps.onChange && computedProps.value ? funcAll(groupProps.onChange, computedProps.onChange) : computedProps.onChange;
    const {
      getContainerProps,
      getInputProps,
      getIconProps,
      getLabelProps,
      props: rest
    } = useRadio({
      ...computedProps,
      isRequired,
      isReadOnly,
      isDisabled,
      isInvalid,
      isChecked,
      onChange
    });
    return /* @__PURE__ */ jsxs(
      ui.label,
      {
        className: cx("ui-radio", className),
        ...getContainerProps(),
        ...rest,
        __css: {
          cursor: "pointer",
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          verticalAlign: "top",
          gap,
          ...styles.container
        },
        children: [
          /* @__PURE__ */ jsx(
            ui.input,
            {
              className: "ui-radio__input",
              ...getInputProps(inputProps, ref)
            }
          ),
          /* @__PURE__ */ jsx(
            ui.span,
            {
              className: "ui-radio__icon",
              ...getIconProps(iconProps),
              __css: {
                position: "relative",
                display: "inline-block",
                userSelect: "none",
                ...styles.icon
              }
            }
          ),
          /* @__PURE__ */ jsx(
            ui.span,
            {
              className: "ui-radio__label",
              ...getLabelProps(labelProps),
              __css: { ...styles.label },
              children
            }
          )
        ]
      }
    );
  }
);
Radio.displayName = "Radio";

// src/radio-group.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
var isEvent = (value) => value && isObject(value) && isObject(value.target);
var useRadioGroup = ({
  id,
  name,
  isNative,
  value: valueProp,
  defaultValue,
  onChange: onChangeProp,
  ...props
}) => {
  id != null ? id : id = useId2();
  name != null ? name : name = `radio-${id}`;
  const onChangeRef = useCallbackRef2(onChangeProp);
  const [value, setValue] = useControllableState({
    value: valueProp,
    defaultValue,
    onChange: onChangeRef
  });
  const containerRef = useRef(null);
  const onFocus = useCallback2(() => {
    const container = containerRef.current;
    if (!container)
      return;
    let query = `input:not(:disabled):checked`;
    let firstInput = container.querySelector(query);
    if (firstInput) {
      firstInput.focus();
    } else {
      query = `input:not(:disabled)`;
      firstInput = container.querySelector(query);
      firstInput == null ? void 0 : firstInput.focus();
    }
  }, []);
  const onChange = useCallback2(
    (evOrValue) => {
      const nextValue = isEvent(evOrValue) ? evOrValue.target.value : evOrValue;
      setValue(nextValue);
    },
    [setValue]
  );
  const getContainerProps = useCallback2(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(ref, containerRef),
      role: "group"
    }),
    []
  );
  const getRadioProps = useCallback2(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref,
      name,
      [isNative ? "checked" : "isChecked"]: value != null ? props2.value === value : void 0,
      onChange
    }),
    [name, value, onChange, isNative]
  );
  return {
    props,
    id,
    name,
    value,
    setValue,
    onChange,
    onFocus,
    getContainerProps,
    getRadioProps
  };
};
var [RadioGroupProvider, useRadioGroupContext] = createContext({
  strict: false,
  name: "RadioGroupContext"
});
var RadioGroup = forwardRef2(
  ({
    className,
    size,
    variant,
    colorScheme,
    children,
    items = [],
    direction = "column",
    gap,
    ...props
  }, ref) => {
    const {
      id,
      name,
      value,
      onChange,
      getContainerProps,
      props: computedProps
    } = useRadioGroup(props);
    const { isRequired, isReadOnly, isDisabled, isInvalid, ...rest } = useFormControl2({
      id,
      ...computedProps
    });
    const validChildren = getValidChildren(children);
    let computedChildren = [];
    if (!validChildren.length && items.length) {
      computedChildren = items.map(({ label, value: value2, ...props2 }, i) => /* @__PURE__ */ jsx2(Radio, { value: value2, ...props2, children: label }, i));
    }
    return /* @__PURE__ */ jsx2(
      RadioGroupProvider,
      {
        value: {
          size,
          variant,
          colorScheme,
          isRequired,
          isReadOnly,
          isDisabled,
          isInvalid,
          name,
          value,
          onChange
        },
        children: /* @__PURE__ */ jsx2(
          Flex,
          {
            ref,
            className: cx2("ui-radio-group", className),
            gap: gap != null ? gap : direction === "row" ? "1rem" : void 0,
            ...getContainerProps({
              ...rest,
              id,
              name
            }),
            direction,
            children: children != null ? children : computedChildren
          }
        )
      }
    );
  }
);
RadioGroup.displayName = "RadioGroup";

export {
  useRadioGroup,
  useRadioGroupContext,
  RadioGroup,
  useRadio,
  Radio
};
//# sourceMappingURL=chunk-6SNWQQAY.mjs.map