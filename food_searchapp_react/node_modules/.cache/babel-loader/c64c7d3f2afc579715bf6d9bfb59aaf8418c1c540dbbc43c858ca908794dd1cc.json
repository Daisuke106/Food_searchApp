{"ast":null,"code":"\"use client\";\n\n// src/use-color-selector.ts\nimport { useFormControlProps, formControlProperties } from \"@yamada-ui/form-control\";\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\";\nimport { useEyeDropper } from \"@yamada-ui/use-eye-dropper\";\nimport { calcFormat, convertColor, createContext, handlerAll, hsvTo, isString, parseToHsv, useCallbackRef, useUpdateEffect, omitObject, parseToRgba, parseToHsla, rgbaTo, hslaTo, pickObject } from \"@yamada-ui/utils\";\nimport { useCallback, useMemo, useRef, useState } from \"react\";\nvar convertHsla = (value, fallback) => {\n  var _a;\n  let [h, s, l, a] = (_a = parseToHsla(value, fallback)) != null ? _a : [0, 0, 1, 1];\n  if (a > 1) a = 1;\n  return {\n    h,\n    s,\n    l,\n    a\n  };\n};\nvar convertRgba = (value, fallback) => {\n  var _a;\n  let [r, g, b, a] = (_a = parseToRgba(value, fallback)) != null ? _a : [255, 255, 255, 1];\n  if (r > 255) r = 255;\n  if (g > 255) g = 255;\n  if (b > 255) b = 255;\n  if (a > 1) a = 1;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n};\nvar convertHsva = (value, fallback) => {\n  const [h, s, v, a] = parseToHsv(value, fallback);\n  return {\n    h,\n    s,\n    v,\n    a\n  };\n};\nvar [ColorSelectorProvider, useColorSelectorContext] = createContext({\n  name: \"ColorSelectorContext\",\n  errorMessage: \"useColorSelectorContext returned is 'undefined'. Seems you forgot to wrap the components in \\\"<ColorSelector />\\\"\"\n});\nvar useColorSelector = _ref => {\n  let {\n    isInvalid,\n    ...props\n  } = _ref;\n  let {\n    id,\n    name,\n    value: valueProp,\n    defaultValue,\n    fallbackValue,\n    onChange: onChangeProp,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    format,\n    required,\n    disabled,\n    readOnly,\n    onSwatchClick,\n    ...rest\n  } = useFormControlProps({\n    isInvalid,\n    ...props\n  });\n  const onChangeStartRef = useCallbackRef(onChangeStartProp);\n  const onChangeEndRef = useCallbackRef(onChangeEndProp);\n  const {\n    supported: eyeDropperSupported,\n    onOpen\n  } = useEyeDropper();\n  const [value, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue != null ? defaultValue : fallbackValue,\n    onChange: onChangeProp\n  });\n  const resolvedValue = value != null ? value : \"#ffffff\";\n  const timeoutId = useRef(void 0);\n  const formatRef = useRef(format != null ? format : calcFormat(resolvedValue));\n  const isDraggingRef = useRef(false);\n  const [parsedValue, setParsedValue] = useState(convertHsva(resolvedValue, fallbackValue));\n  const {\n    h,\n    s,\n    v,\n    a\n  } = parsedValue;\n  const withAlpha = formatRef.current.endsWith(\"a\");\n  const isInteractive = !(disabled || readOnly);\n  const channels = useMemo(() => {\n    if (resolvedValue.startsWith(\"hsl\")) {\n      const {\n        h: h2,\n        s: s2,\n        l,\n        a: a2\n      } = convertHsla(resolvedValue, fallbackValue);\n      let channels2 = [{\n        label: \"H\",\n        space: \"h\",\n        value: Math.round(h2),\n        min: 0,\n        max: 360\n      }, {\n        label: \"S(%)\",\n        space: \"s\",\n        value: Math.round(s2 * 100),\n        min: 0,\n        max: 100\n      }, {\n        label: \"L(%)\",\n        space: \"l\",\n        value: Math.round(l * 100),\n        min: 0,\n        max: 100\n      }];\n      if (withAlpha) {\n        channels2 = [...channels2, {\n          label: \"A(%)\",\n          space: \"a\",\n          value: Math.round(a2 * 100),\n          min: 0,\n          max: 100\n        }];\n      }\n      return channels2;\n    } else {\n      const {\n        r,\n        g,\n        b,\n        a: a2\n      } = convertRgba(resolvedValue, fallbackValue);\n      let channels2 = [{\n        label: \"R\",\n        space: \"r\",\n        value: Math.round(r),\n        min: 0,\n        max: 255\n      }, {\n        label: \"G\",\n        space: \"g\",\n        value: Math.round(g),\n        min: 0,\n        max: 255\n      }, {\n        label: \"B\",\n        space: \"b\",\n        value: Math.round(b),\n        min: 0,\n        max: 255\n      }];\n      if (withAlpha) {\n        channels2 = [...channels2, {\n          label: \"A(%)\",\n          space: \"a\",\n          value: Math.round(a2 * 100),\n          min: 0,\n          max: 100\n        }];\n      }\n      return channels2;\n    }\n  }, [resolvedValue, withAlpha, fallbackValue]);\n  const onChange = useCallback(value2 => {\n    if (isString(value2)) {\n      setParsedValue(convertHsva(value2, fallbackValue));\n    } else {\n      setParsedValue(prev => ({\n        ...prev,\n        ...value2\n      }));\n    }\n  }, [fallbackValue]);\n  const onChangeStart = useCallback(value2 => {\n    window.clearTimeout(timeoutId.current);\n    isDraggingRef.current = true;\n    const {\n      h: h2,\n      s: s2,\n      v: v2,\n      a: a2\n    } = {\n      ...parsedValue,\n      ...value2\n    };\n    const nextValue = hsvTo([h2, s2, v2, a2], fallbackValue)(formatRef.current);\n    if (nextValue) onChangeStartRef(nextValue);\n  }, [formatRef, onChangeStartRef, fallbackValue, parsedValue]);\n  const onChangeEnd = useCallback(value2 => {\n    window.clearTimeout(timeoutId.current);\n    timeoutId.current = window.setTimeout(() => {\n      isDraggingRef.current = false;\n    }, 200);\n    let nextValue;\n    if (isString(value2)) {\n      nextValue = convertColor(value2, fallbackValue)(formatRef.current);\n    } else {\n      const {\n        h: h2,\n        s: s2,\n        v: v2,\n        a: a2\n      } = {\n        ...parsedValue,\n        ...value2\n      };\n      nextValue = hsvTo([h2, s2, v2, a2], fallbackValue)(formatRef.current);\n    }\n    if (nextValue) onChangeEndRef(nextValue);\n  }, [formatRef, onChangeEndRef, fallbackValue, parsedValue]);\n  const onChannelChange = useCallback((ev, space) => {\n    let n = Math.floor(parseFloat(ev.target.value));\n    if (isNaN(n)) n = 0;\n    if ([\"s\", \"l\", \"a\"].includes(space)) n = n / 100;\n    let nextValue;\n    if (resolvedValue.startsWith(\"hsl\")) {\n      const {\n        h: h2,\n        s: s2,\n        l,\n        a: a2\n      } = Object.assign(convertHsla(resolvedValue, fallbackValue), {\n        [space]: n\n      });\n      nextValue = hslaTo([h2, s2, l, a2], fallbackValue)(formatRef.current);\n    } else {\n      const {\n        r,\n        g,\n        b,\n        a: a2\n      } = Object.assign(convertRgba(resolvedValue, fallbackValue), {\n        [space]: n\n      });\n      nextValue = rgbaTo([r, g, b, a2], fallbackValue)(formatRef.current);\n    }\n    if (!nextValue) return;\n    onChange(nextValue);\n    onChangeEnd(nextValue);\n  }, [resolvedValue, onChange, onChangeEnd, formatRef, fallbackValue]);\n  const onEyeDropperClick = useCallback(async () => {\n    var _a;\n    try {\n      const {\n        sRGBHex\n      } = (_a = await onOpen()) != null ? _a : {};\n      if (!sRGBHex) return;\n      onChange(sRGBHex);\n      onChangeEnd(sRGBHex);\n    } catch {}\n  }, [onOpen, onChange, onChangeEnd]);\n  useUpdateEffect(() => {\n    const nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current);\n    if (nextValue) setValue(nextValue);\n  }, [h, s, v, a]);\n  useUpdateEffect(() => {\n    if (isDraggingRef.current) return;\n    if (valueProp) setParsedValue(convertHsva(valueProp, fallbackValue));\n  }, [valueProp]);\n  useUpdateEffect(() => {\n    if (!format || !value) return;\n    formatRef.current = format;\n    const nextValue = convertColor(value, fallbackValue)(format);\n    if (nextValue) setValue(nextValue);\n  }, [format]);\n  const getContainerProps = function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      ...props2,\n      ref,\n      ...omitObject(rest, [\"aria-readonly\"])\n    };\n  };\n  const getInputProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      ...pickObject(rest, formControlProperties),\n      ...props2,\n      id,\n      ref,\n      type: \"hidden\",\n      name,\n      value: resolvedValue,\n      required,\n      disabled,\n      readOnly\n    };\n  }, [disabled, id, name, readOnly, required, rest, resolvedValue]);\n  const getSaturationSliderProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props2,\n      ref,\n      value: [h, s, v],\n      onChange: handlerAll(props2.onChange, _ref2 => {\n        let [, s2, v2] = _ref2;\n        return onChange({\n          s: s2,\n          v: v2\n        });\n      }),\n      onChangeStart: handlerAll(props2.onChangeStart, _ref3 => {\n        let [, s2, v2] = _ref3;\n        return onChangeStart({\n          s: s2,\n          v: v2\n        });\n      }),\n      onChangeEnd: handlerAll(props2.onChangeEnd, _ref4 => {\n        let [, s2, v2] = _ref4;\n        return onChangeEnd({\n          s: s2,\n          v: v2\n        });\n      })\n    };\n  }, [required, disabled, readOnly, isInvalid, h, s, v, onChange, onChangeStart, onChangeEnd]);\n  const getHueSliderProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props2,\n      ref,\n      value: h,\n      onChange: handlerAll(props2.onChange, h2 => onChange({\n        h: h2\n      })),\n      onChangeStart: handlerAll(props2.onChangeStart, h2 => onChangeStart({\n        h: h2\n      })),\n      onChangeEnd: handlerAll(props2.onChangeEnd, h2 => onChangeEnd({\n        h: h2\n      }))\n    };\n  }, [required, disabled, readOnly, isInvalid, h, onChange, onChangeStart, onChangeEnd]);\n  const getAlphaSliderProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props2,\n      ref,\n      value: a,\n      color: hsvTo([h, s, v, a], fallbackValue)(formatRef.current),\n      onChange: handlerAll(props2.onChange, a2 => onChange({\n        a: a2\n      })),\n      onChangeStart: handlerAll(props2.onChangeStart, a2 => onChangeStart({\n        a: a2\n      })),\n      onChangeEnd: handlerAll(props2.onChangeEnd, a2 => onChangeEnd({\n        a: a2\n      }))\n    };\n  }, [fallbackValue, required, disabled, readOnly, isInvalid, formatRef, h, s, v, a, onChange, onChangeStart, onChangeEnd]);\n  const getChannelProps = useCallback(function (_ref5) {\n    let {\n      space,\n      ...props2\n    } = _ref5;\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props2,\n      ref,\n      type: \"number\",\n      step: 1,\n      onChange: handlerAll(props2.onChange, ev => onChannelChange(ev, space))\n    };\n  }, [required, disabled, readOnly, isInvalid, onChannelChange]);\n  const getEyeDropperProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      disabled,\n      \"aria-label\": \"Pick a color\",\n      ...props2,\n      ref,\n      onClick: handlerAll(props2.onClick, onEyeDropperClick)\n    };\n  }, [disabled, onEyeDropperClick]);\n  const getSwatchProps = useCallback(function () {\n    let {\n      color,\n      ...props2\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      \"aria-label\": \"Select \".concat(color, \" as the color\"),\n      disabled,\n      readOnly,\n      ...props2,\n      ref,\n      color,\n      onClick: handlerAll(props2.onClick, () => {\n        if (!color) return;\n        onSwatchClick == null ? void 0 : onSwatchClick(color);\n        onChange(color);\n        onChangeEnd(color);\n      })\n    };\n  }, [disabled, readOnly, onSwatchClick, onChange, onChangeEnd]);\n  return {\n    value: resolvedValue,\n    onChange,\n    eyeDropperSupported,\n    withAlpha,\n    isInteractive,\n    disabled,\n    readOnly,\n    channels,\n    getContainerProps,\n    getInputProps,\n    getSaturationSliderProps,\n    getHueSliderProps,\n    getAlphaSliderProps,\n    getEyeDropperProps,\n    getChannelProps,\n    getSwatchProps\n  };\n};\nexport { ColorSelectorProvider, useColorSelectorContext, useColorSelector };","map":{"version":3,"names":["useFormControlProps","formControlProperties","useControllableState","useEyeDropper","calcFormat","convertColor","createContext","handlerAll","hsvTo","isString","parseToHsv","useCallbackRef","useUpdateEffect","omitObject","parseToRgba","parseToHsla","rgbaTo","hslaTo","pickObject","useCallback","useMemo","useRef","useState","convertHsla","value","fallback","_a","h","s","l","a","convertRgba","r","g","b","convertHsva","v","ColorSelectorProvider","useColorSelectorContext","name","errorMessage","useColorSelector","_ref","isInvalid","props","id","valueProp","defaultValue","fallbackValue","onChange","onChangeProp","onChangeStart","onChangeStartProp","onChangeEnd","onChangeEndProp","format","required","disabled","readOnly","onSwatchClick","rest","onChangeStartRef","onChangeEndRef","supported","eyeDropperSupported","onOpen","setValue","resolvedValue","timeoutId","formatRef","isDraggingRef","parsedValue","setParsedValue","withAlpha","current","endsWith","isInteractive","channels","startsWith","h2","s2","a2","channels2","label","space","Math","round","min","max","value2","prev","window","clearTimeout","v2","nextValue","setTimeout","onChannelChange","ev","n","floor","parseFloat","target","isNaN","includes","Object","assign","onEyeDropperClick","sRGBHex","getContainerProps","props2","arguments","length","undefined","ref","getInputProps","type","getSaturationSliderProps","_ref2","_ref3","_ref4","getHueSliderProps","getAlphaSliderProps","color","getChannelProps","_ref5","step","getEyeDropperProps","onClick","getSwatchProps","concat"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\color-picker\\src\\use-color-selector.ts"],"sourcesContent":["import type {\n  CSSUIObject,\n  HTMLUIProps,\n  UIPropGetter,\n  ThemeProps,\n  RequiredUIPropGetter,\n} from \"@yamada-ui/core\"\nimport {\n  useFormControlProps,\n  type FormControlOptions,\n  formControlProperties,\n} from \"@yamada-ui/form-control\"\nimport type { InputProps } from \"@yamada-ui/input\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { useEyeDropper } from \"@yamada-ui/use-eye-dropper\"\nimport type { ColorFormat, Dict, Merge } from \"@yamada-ui/utils\"\nimport {\n  calcFormat,\n  convertColor,\n  createContext,\n  handlerAll,\n  hsvTo,\n  isString,\n  parseToHsv,\n  useCallbackRef,\n  useUpdateEffect,\n  omitObject,\n  parseToRgba,\n  parseToHsla,\n  rgbaTo,\n  hslaTo,\n  pickObject,\n} from \"@yamada-ui/utils\"\nimport type { ChangeEvent } from \"react\"\nimport { useCallback, useMemo, useRef, useState } from \"react\"\nimport type { AlphaSliderProps } from \"./alpha-slider\"\nimport type { ColorSwatchProps } from \"./color-swatch\"\nimport type { HueSliderProps } from \"./hue-slider\"\nimport type { SaturationSliderProps } from \"./saturation-slider\"\n\ntype Space = keyof Hsla | keyof Rgba\ntype Hsla = { h: number; s: number; l: number; a: number }\ntype Rgba = { r: number; g: number; b: number; a: number }\ntype Hsva = { h: number; s: number; v: number; a: number }\ntype Channel = {\n  label: string\n  space: Space\n  value: number\n  min: number\n  max: number\n}\n\nconst convertHsla = (value: string, fallback?: string): Hsla => {\n  let [h, s, l, a] = parseToHsla(value, fallback) ?? [0, 0, 1, 1]\n\n  if (a > 1) a = 1\n\n  return { h, s, l, a }\n}\n\nconst convertRgba = (value: string, fallback?: string): Rgba => {\n  let [r, g, b, a] = parseToRgba(value, fallback) ?? [255, 255, 255, 1]\n\n  if (r > 255) r = 255\n  if (g > 255) g = 255\n  if (b > 255) b = 255\n  if (a > 1) a = 1\n\n  return { r, g, b, a }\n}\n\nconst convertHsva = (value: string, fallback?: string): Hsva => {\n  const [h, s, v, a] = parseToHsv(value, fallback)\n\n  return { h, s, v, a }\n}\n\ntype ColorSelectorContext = {\n  value: string\n  onChange: (value: string | Partial<Hsva>) => void\n  eyeDropperSupported: boolean\n  withAlpha: boolean\n  isInteractive: boolean\n  disabled?: boolean\n  readOnly?: boolean\n  channels: Channel[]\n  size?: ThemeProps<\"ColorSelector\">[\"size\"]\n  getHueSliderProps: UIPropGetter<\"input\", HueSliderProps, HueSliderProps>\n  getAlphaSliderProps: UIPropGetter<\"input\", AlphaSliderProps, AlphaSliderProps>\n  getEyeDropperProps: UIPropGetter<\"button\">\n  getChannelProps: RequiredUIPropGetter<\n    \"input\",\n    Merge<InputProps, { space: Space }>,\n    InputProps\n  >\n  getSwatchProps: UIPropGetter<\"div\", ColorSwatchProps, ColorSwatchProps>\n  styles: Record<string, CSSUIObject>\n}\n\nexport const [ColorSelectorProvider, useColorSelectorContext] =\n  createContext<ColorSelectorContext>({\n    name: \"ColorSelectorContext\",\n    errorMessage: `useColorSelectorContext returned is 'undefined'. Seems you forgot to wrap the components in \"<ColorSelector />\"`,\n  })\n\ntype UseColorSelectorOptions = {\n  /**\n   * The base `id` to use for the color selector.\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms.\n   */\n  name?: string\n  /**\n   * The value of the color selector.\n   */\n  value?: string\n  /**\n   * The initial value of the color selector.\n   */\n  defaultValue?: string\n  /**\n   * The fallback value returned when color determination fails.\n   */\n  fallbackValue?: string\n  /**\n   * Function called whenever the color selector value changes.\n   */\n  onChange?: (value: string) => void\n  /**\n   * Function called when the user starts selecting a new value.\n   */\n  onChangeStart?: (value: string) => void\n  /**\n   * Function called when the user is done selecting a new value.\n   */\n  onChangeEnd?: (value: string) => void\n  /**\n   * Color format. For example, `hex`, `rgba`, etc.\n   *\n   * @default \"hexa\"\n   */\n  format?: ColorFormat\n  /**\n   * Function called whenever the color swatch click.\n   */\n  onSwatchClick?: (value: string) => void\n}\n\nexport type UseColorSelectorBaseProps = UseColorSelectorOptions &\n  FormControlOptions\n\nexport type UseColorSelectorProps = Omit<\n  HTMLUIProps<\"div\">,\n  \"defaultValue\" | \"onChange\" | \"children\"\n> &\n  UseColorSelectorBaseProps\n\nexport const useColorSelector = ({\n  isInvalid,\n  ...props\n}: UseColorSelectorProps) => {\n  let {\n    id,\n    name,\n    value: valueProp,\n    defaultValue,\n    fallbackValue,\n    onChange: onChangeProp,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    format,\n    required,\n    disabled,\n    readOnly,\n    onSwatchClick,\n    ...rest\n  } = useFormControlProps({ isInvalid, ...props })\n\n  const onChangeStartRef = useCallbackRef(onChangeStartProp)\n  const onChangeEndRef = useCallbackRef(onChangeEndProp)\n  const { supported: eyeDropperSupported, onOpen } = useEyeDropper()\n  const [value, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? fallbackValue,\n    onChange: onChangeProp,\n  })\n  const resolvedValue = value ?? \"#ffffff\"\n  const timeoutId = useRef<any>(undefined)\n  const formatRef = useRef<ColorFormat>(format ?? calcFormat(resolvedValue))\n  const isDraggingRef = useRef<boolean>(false)\n  const [parsedValue, setParsedValue] = useState<Hsva>(\n    convertHsva(resolvedValue, fallbackValue),\n  )\n  const { h, s, v, a } = parsedValue\n  const withAlpha = formatRef.current.endsWith(\"a\")\n  const isInteractive = !(disabled || readOnly)\n\n  const channels: Channel[] = useMemo(() => {\n    if (resolvedValue.startsWith(\"hsl\")) {\n      const { h, s, l, a } = convertHsla(resolvedValue, fallbackValue)\n\n      let channels: Channel[] = [\n        { label: \"H\", space: \"h\", value: Math.round(h), min: 0, max: 360 },\n        {\n          label: \"S(%)\",\n          space: \"s\",\n          value: Math.round(s * 100),\n          min: 0,\n          max: 100,\n        },\n        {\n          label: \"L(%)\",\n          space: \"l\",\n          value: Math.round(l * 100),\n          min: 0,\n          max: 100,\n        },\n      ]\n\n      if (withAlpha) {\n        channels = [\n          ...channels,\n          {\n            label: \"A(%)\",\n            space: \"a\",\n            value: Math.round(a * 100),\n            min: 0,\n            max: 100,\n          },\n        ]\n      }\n\n      return channels\n    } else {\n      const { r, g, b, a } = convertRgba(resolvedValue, fallbackValue)\n\n      let channels: Channel[] = [\n        { label: \"R\", space: \"r\", value: Math.round(r), min: 0, max: 255 },\n        { label: \"G\", space: \"g\", value: Math.round(g), min: 0, max: 255 },\n        { label: \"B\", space: \"b\", value: Math.round(b), min: 0, max: 255 },\n      ]\n\n      if (withAlpha) {\n        channels = [\n          ...channels,\n          {\n            label: \"A(%)\",\n            space: \"a\",\n            value: Math.round(a * 100),\n            min: 0,\n            max: 100,\n          },\n        ]\n      }\n\n      return channels\n    }\n  }, [resolvedValue, withAlpha, fallbackValue])\n\n  const onChange = useCallback(\n    (value: string | Partial<Hsva>) => {\n      if (isString(value)) {\n        setParsedValue(convertHsva(value, fallbackValue))\n      } else {\n        setParsedValue((prev) => ({ ...prev, ...value }))\n      }\n    },\n    [fallbackValue],\n  )\n\n  const onChangeStart = useCallback(\n    (value: Partial<Hsva>) => {\n      window.clearTimeout(timeoutId.current)\n\n      isDraggingRef.current = true\n\n      const { h, s, v, a } = { ...parsedValue, ...value }\n\n      const nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n\n      if (nextValue) onChangeStartRef(nextValue)\n    },\n    [formatRef, onChangeStartRef, fallbackValue, parsedValue],\n  )\n\n  const onChangeEnd = useCallback(\n    (value: string | Partial<Hsva>) => {\n      window.clearTimeout(timeoutId.current)\n\n      timeoutId.current = window.setTimeout(() => {\n        isDraggingRef.current = false\n      }, 200)\n\n      let nextValue: string | undefined\n\n      if (isString(value)) {\n        nextValue = convertColor(value, fallbackValue)(formatRef.current)\n      } else {\n        const { h, s, v, a } = { ...parsedValue, ...value }\n\n        nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n      }\n\n      if (nextValue) onChangeEndRef(nextValue)\n    },\n    [formatRef, onChangeEndRef, fallbackValue, parsedValue],\n  )\n\n  const onChannelChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>, space: Space) => {\n      let n = Math.floor(parseFloat(ev.target.value))\n\n      if (isNaN(n)) n = 0\n\n      if ([\"s\", \"l\", \"a\"].includes(space)) n = n / 100\n\n      let nextValue: string | undefined\n\n      if (resolvedValue.startsWith(\"hsl\")) {\n        const { h, s, l, a } = Object.assign(\n          convertHsla(resolvedValue, fallbackValue),\n          { [space]: n },\n        )\n\n        nextValue = hslaTo([h, s, l, a], fallbackValue)(formatRef.current)\n      } else {\n        const { r, g, b, a } = Object.assign(\n          convertRgba(resolvedValue, fallbackValue),\n          { [space]: n },\n        )\n\n        nextValue = rgbaTo([r, g, b, a], fallbackValue)(formatRef.current)\n      }\n\n      if (!nextValue) return\n\n      onChange(nextValue)\n      onChangeEnd(nextValue)\n    },\n    [resolvedValue, onChange, onChangeEnd, formatRef, fallbackValue],\n  )\n\n  const onEyeDropperClick = useCallback(async () => {\n    try {\n      const { sRGBHex } = (await onOpen()) ?? {}\n\n      if (!sRGBHex) return\n\n      onChange(sRGBHex)\n      onChangeEnd(sRGBHex)\n    } catch {}\n  }, [onOpen, onChange, onChangeEnd])\n\n  useUpdateEffect(() => {\n    const nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n\n    if (nextValue) setValue(nextValue)\n  }, [h, s, v, a])\n\n  useUpdateEffect(() => {\n    if (isDraggingRef.current) return\n\n    if (valueProp) setParsedValue(convertHsva(valueProp, fallbackValue))\n  }, [valueProp])\n\n  useUpdateEffect(() => {\n    if (!format || !value) return\n\n    formatRef.current = format\n\n    const nextValue = convertColor(value, fallbackValue)(format)\n\n    if (nextValue) setValue(nextValue)\n  }, [format])\n\n  const getContainerProps: UIPropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ref,\n    ...omitObject(rest, [\"aria-readonly\"]),\n  })\n\n  const getInputProps: UIPropGetter<\"input\"> = useCallback(\n    (props = {}, ref = null) => ({\n      ...pickObject(rest, formControlProperties),\n      ...props,\n      id,\n      ref,\n      type: \"hidden\",\n      name,\n      value: resolvedValue,\n      required,\n      disabled,\n      readOnly,\n    }),\n    [disabled, id, name, readOnly, required, rest, resolvedValue],\n  )\n\n  const getSaturationSliderProps: UIPropGetter<\n    \"input\",\n    SaturationSliderProps,\n    SaturationSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: [h, s, v],\n      onChange: handlerAll(props.onChange, ([, s, v]) => onChange({ s, v })),\n      onChangeStart: handlerAll(props.onChangeStart, ([, s, v]) =>\n        onChangeStart({ s, v }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, ([, s, v]) =>\n        onChangeEnd({ s, v }),\n      ),\n    }),\n    [\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      h,\n      s,\n      v,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getHueSliderProps: UIPropGetter<\n    \"input\",\n    HueSliderProps,\n    HueSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: h,\n      onChange: handlerAll(props.onChange, (h) => onChange({ h })),\n      onChangeStart: handlerAll(props.onChangeStart, (h) =>\n        onChangeStart({ h }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, (h) => onChangeEnd({ h })),\n    }),\n    [\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      h,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getAlphaSliderProps: UIPropGetter<\n    \"input\",\n    AlphaSliderProps,\n    AlphaSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: a,\n      color: hsvTo([h, s, v, a], fallbackValue)(formatRef.current),\n      onChange: handlerAll(props.onChange, (a) => onChange({ a })),\n      onChangeStart: handlerAll(props.onChangeStart, (a) =>\n        onChangeStart({ a }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, (a) => onChangeEnd({ a })),\n    }),\n    [\n      fallbackValue,\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      formatRef,\n      h,\n      s,\n      v,\n      a,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getChannelProps: RequiredUIPropGetter<\n    \"input\",\n    Merge<InputProps, { space: Space }>,\n    InputProps\n  > = useCallback(\n    ({ space, ...props }, ref = null) => {\n      return {\n        required,\n        disabled,\n        readOnly,\n        isInvalid,\n        ...props,\n        ref,\n        type: \"number\",\n        step: 1,\n        onChange: handlerAll(props.onChange, (ev) =>\n          onChannelChange(ev, space),\n        ),\n      } as Dict\n    },\n    [required, disabled, readOnly, isInvalid, onChannelChange],\n  )\n\n  const getEyeDropperProps: UIPropGetter<\"button\"> = useCallback(\n    (props = {}, ref = null) => ({\n      disabled,\n      \"aria-label\": \"Pick a color\",\n      ...props,\n      ref,\n      onClick: handlerAll(props.onClick, onEyeDropperClick),\n    }),\n    [disabled, onEyeDropperClick],\n  )\n\n  const getSwatchProps: UIPropGetter<\n    \"div\",\n    ColorSwatchProps,\n    ColorSwatchProps\n  > = useCallback(\n    ({ color, ...props } = {}, ref = null) => ({\n      \"aria-label\": `Select ${color} as the color`,\n      disabled,\n      readOnly,\n      ...props,\n      ref,\n      color,\n      onClick: handlerAll(props.onClick, () => {\n        if (!color) return\n\n        onSwatchClick?.(color)\n        onChange(color)\n        onChangeEnd(color)\n      }),\n    }),\n    [disabled, readOnly, onSwatchClick, onChange, onChangeEnd],\n  )\n\n  return {\n    value: resolvedValue,\n    onChange,\n    eyeDropperSupported,\n    withAlpha,\n    isInteractive,\n    disabled,\n    readOnly,\n    channels,\n    getContainerProps,\n    getInputProps,\n    getSaturationSliderProps,\n    getHueSliderProps,\n    getAlphaSliderProps,\n    getEyeDropperProps,\n    getChannelProps,\n    getSwatchProps,\n  }\n}\n\nexport type UseColorSelectorReturn = ReturnType<typeof useColorSelector>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}