{"ast":null,"code":"\"use client\";\n\n// src/use-saturation-slider.ts\nimport { useFormControlProps, formControlProperties, getFormControlProperties } from \"@yamada-ui/form-control\";\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\";\nimport { useLatestRef } from \"@yamada-ui/use-latest-ref\";\nimport { usePanEvent } from \"@yamada-ui/use-pan-event\";\nimport { useSize } from \"@yamada-ui/use-size\";\nimport { omitObject, dataAttr, handlerAll, mergeRefs, useCallbackRef, runIfFunc, clampNumber, hsvTo, roundNumberToStep, pickObject, useUpdateEffect } from \"@yamada-ui/utils\";\nimport { useCallback, useMemo, useRef, useState } from \"react\";\nvar defaultOverlays = withShadow => {\n  let overlays = [([h]) => ({\n    bg: `hsl(${h}, 100%, 50%)`,\n    bgImage: \"linear-gradient(0deg, #000, transparent), linear-gradient(90deg, #fff, transparent)\"\n  })];\n  if (withShadow) overlays = [...overlays, {\n    boxShadow: `rgba(0, 0, 0, .1) 0 0 0 1px inset, rgb(0, 0, 0, .15) 0 0 4px inset`\n  }];\n  return overlays;\n};\nvar useSaturationSlider = ({\n  focusThumbOnChange = true,\n  ...props\n}) => {\n  if (!focusThumbOnChange) props.isReadOnly = true;\n  let {\n    id,\n    name,\n    value: valueProp,\n    defaultValue = [0, 0, 1],\n    onChange: onChangeProp,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 0.01,\n    thumbColor,\n    required,\n    disabled,\n    readOnly,\n    withShadow = true,\n    overlays: overlaysProp = defaultOverlays(withShadow),\n    ...rest\n  } = useFormControlProps(props);\n  const onChangeStart = useCallbackRef(onChangeStartProp);\n  const onChangeEnd = useCallbackRef(onChangeEndProp);\n  const [value, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue,\n    onChange: onChangeProp\n  });\n  const [isDragging, setDragging] = useState(false);\n  const isInteractive = !(disabled || readOnly);\n  let [h, s, v] = value;\n  s = clampNumber(s, 0, 1);\n  v = clampNumber(v, 0, 1);\n  const containerRef = useRef(null);\n  const trackRef = useRef(null);\n  const thumbRef = useRef(null);\n  const latestRef = useLatestRef({\n    value,\n    step,\n    isInteractive,\n    eventSource: null,\n    focusThumbOnChange\n  });\n  const thumbSize = useSize(thumbRef);\n  const overlays = useMemo(() => overlaysProp.map(propsOrFunc => runIfFunc(propsOrFunc, [h, s, v])), [overlaysProp, h, s, v]);\n  const getValueFromPointer = useCallback(ev => {\n    var _a, _b;\n    if (!trackRef.current) return [];\n    const {\n      step: step2\n    } = latestRef.current;\n    latestRef.current.eventSource = \"pointer\";\n    const {\n      bottom,\n      left,\n      height,\n      width\n    } = trackRef.current.getBoundingClientRect();\n    const {\n      clientX,\n      clientY\n    } = (_b = (_a = ev.touches) == null ? void 0 : _a[0]) != null ? _b : ev;\n    let s2 = clampNumber((clientX - left) / width, 0, 1);\n    let v2 = clampNumber((bottom - clientY) / height, 0, 1);\n    if (step2) {\n      s2 = parseFloat(roundNumberToStep(s2, 0, step2));\n      v2 = parseFloat(roundNumberToStep(v2, 0, step2));\n    }\n    return [s2, v2];\n  }, [latestRef]);\n  const setValueFromPointer = ev => {\n    const {\n      value: value2\n    } = latestRef.current;\n    const [nextS, nextV] = getValueFromPointer(ev);\n    if (nextS == null || nextV == null) return;\n    const [, s2, v2] = value2;\n    if (nextS !== s2 || nextV !== v2) setValue(([h2]) => [h2, nextS, nextV]);\n  };\n  const focusThumb = useCallback(() => {\n    const {\n      focusThumbOnChange: focusThumbOnChange2\n    } = latestRef.current;\n    if (focusThumbOnChange2) setTimeout(() => {\n      var _a;\n      return (_a = thumbRef.current) == null ? void 0 : _a.focus();\n    });\n  }, [latestRef]);\n  const constrain = useCallback(([s2, v2]) => {\n    const {\n      isInteractive: isInteractive2\n    } = latestRef.current;\n    if (!isInteractive2) return;\n    s2 = clampNumber(s2, 0, 1);\n    v2 = clampNumber(v2, 0, 1);\n    setValue(([h2]) => [h2, s2, v2]);\n  }, [latestRef, setValue]);\n  const onKeyDown = useCallback(ev => {\n    const actions = {\n      ArrowRight: () => constrain([s + step, v]),\n      ArrowUp: () => constrain([s, v + step]),\n      ArrowLeft: () => constrain([s - step, v]),\n      ArrowDown: () => constrain([s, v - step])\n    };\n    const action = actions[ev.key];\n    if (!action) return;\n    ev.preventDefault();\n    ev.stopPropagation();\n    action(ev);\n    latestRef.current.eventSource = \"keyboard\";\n  }, [latestRef, constrain, s, v, step]);\n  usePanEvent(containerRef, {\n    onSessionStart: ev => {\n      const {\n        isInteractive: isInteractive2,\n        value: value2\n      } = latestRef.current;\n      if (!isInteractive2) return;\n      setDragging(true);\n      focusThumb();\n      setValueFromPointer(ev);\n      onChangeStart(value2);\n    },\n    onSessionEnd: () => {\n      const {\n        isInteractive: isInteractive2,\n        value: value2\n      } = latestRef.current;\n      if (!isInteractive2) return;\n      setDragging(false);\n      onChangeEnd(value2);\n    },\n    onMove: ev => {\n      const {\n        isInteractive: isInteractive2\n      } = latestRef.current;\n      if (!isInteractive2) return;\n      setValueFromPointer(ev);\n    }\n  });\n  useUpdateEffect(() => {\n    const {\n      eventSource,\n      value: value2\n    } = latestRef.current;\n    if (eventSource === \"keyboard\") onChangeEnd(value2);\n  }, [value, onChangeEnd]);\n  const getContainerProps = useCallback((props2 = {}, ref = null) => ({\n    ...props2,\n    ...omitObject(rest, [\"aria-readonly\"]),\n    ref: mergeRefs(ref, containerRef),\n    tabIndex: -1\n  }), [rest]);\n  const getInnerProps = useCallback((props2 = {}, ref = null) => {\n    const {\n      width: w\n    } = thumbSize != null ? thumbSize : {\n      width: 0\n    };\n    const style = {\n      ...props2.style,\n      ...rest.style,\n      padding: `${w / 2}px`\n    };\n    return {\n      ...props2,\n      ref,\n      style\n    };\n  }, [rest, thumbSize]);\n  const getInputProps = useCallback((props2 = {}, ref = null) => ({\n    ...pickObject(rest, formControlProperties),\n    ...props2,\n    id,\n    ref,\n    type: \"hidden\",\n    name,\n    value: [h, s, v].toString(),\n    required,\n    disabled,\n    readOnly\n  }), [disabled, id, name, readOnly, required, rest, h, s, v]);\n  const getTrackProps = useCallback((props2 = {}, ref = null) => ({\n    ...pickObject(rest, getFormControlProperties({\n      omit: [\"aria-readonly\"]\n    })),\n    ...props2,\n    ref: mergeRefs(ref, trackRef)\n  }), [rest]);\n  const getThumbProps = useCallback((props2 = {}, ref = null) => {\n    const {\n      width,\n      height\n    } = thumbSize != null ? thumbSize : {\n      width: 0,\n      height: 0\n    };\n    const x = s * 100;\n    const y = v * 100;\n    const style = {\n      ...props2.style,\n      position: \"absolute\",\n      userSelect: \"none\",\n      touchAction: \"none\",\n      left: `calc(${x}% - ${width / 2}px)`,\n      bottom: `calc(${y}% - ${height / 2}px)`\n    };\n    return {\n      \"aria-label\": \"Saturation and brightness thumb\",\n      bg: thumbColor != null ? thumbColor : hsvTo([h, s, v])(),\n      ...pickObject(rest, formControlProperties),\n      ...props2,\n      ref: mergeRefs(ref, thumbRef),\n      tabIndex: isInteractive && focusThumbOnChange ? 0 : void 0,\n      role: \"slider\",\n      \"aria-valuenow\": s,\n      \"aria-valuemin\": 0,\n      \"aria-valuemax\": 100,\n      \"aria-valuetext\": `saturation ${s}, brightness ${v}`,\n      \"data-active\": dataAttr(isDragging && focusThumbOnChange),\n      onKeyDown: handlerAll(props2.onKeyDown, onKeyDown),\n      onFocus: handlerAll(props2.onFocus, rest.onFocus),\n      onBlur: handlerAll(props2.onBlur, rest.onBlur),\n      style\n    };\n  }, [h, s, v, thumbColor, focusThumbOnChange, isDragging, isInteractive, onKeyDown, rest, thumbSize]);\n  return {\n    value,\n    overlays,\n    getContainerProps,\n    getInnerProps,\n    getTrackProps,\n    getInputProps,\n    getThumbProps\n  };\n};\nexport { useSaturationSlider };","map":{"version":3,"names":["useFormControlProps","formControlProperties","getFormControlProperties","useControllableState","useLatestRef","usePanEvent","useSize","omitObject","dataAttr","handlerAll","mergeRefs","useCallbackRef","runIfFunc","clampNumber","hsvTo","roundNumberToStep","pickObject","useUpdateEffect","useCallback","useMemo","useRef","useState","defaultOverlays","withShadow","overlays","h","bg","bgImage","boxShadow","useSaturationSlider","focusThumbOnChange","props","isReadOnly","id","name","value","valueProp","defaultValue","onChange","onChangeProp","onChangeStart","onChangeStartProp","onChangeEnd","onChangeEndProp","step","thumbColor","required","disabled","readOnly","overlaysProp","rest","setValue","isDragging","setDragging","isInteractive","s","v","containerRef","trackRef","thumbRef","latestRef","eventSource","thumbSize","map","propsOrFunc","getValueFromPointer","ev","_a","_b","current","step2","bottom","left","height","width","getBoundingClientRect","clientX","clientY","touches","s2","v2","parseFloat","setValueFromPointer","value2","nextS","nextV","h2","focusThumb","focusThumbOnChange2","setTimeout","focus","constrain","isInteractive2","onKeyDown","actions","ArrowRight","ArrowUp","ArrowLeft","ArrowDown","action","key","preventDefault","stopPropagation","onSessionStart","onSessionEnd","onMove","getContainerProps","props2","ref","tabIndex","getInnerProps","w","style","padding","getInputProps","type","toString","getTrackProps","omit","getThumbProps","x","y","position","userSelect","touchAction","role","onFocus","onBlur"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\color-picker\\src\\use-saturation-slider.ts"],"sourcesContent":["import type { CSSUIProps, HTMLUIProps, UIPropGetter } from \"@yamada-ui/core\"\nimport {\n  useFormControlProps,\n  type FormControlOptions,\n  formControlProperties,\n  getFormControlProperties,\n} from \"@yamada-ui/form-control\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { useLatestRef } from \"@yamada-ui/use-latest-ref\"\nimport { usePanEvent } from \"@yamada-ui/use-pan-event\"\nimport { useSize } from \"@yamada-ui/use-size\"\nimport {\n  omitObject,\n  dataAttr,\n  handlerAll,\n  mergeRefs,\n  useCallbackRef,\n  runIfFunc,\n  clampNumber,\n  hsvTo,\n  roundNumberToStep,\n  pickObject,\n  useUpdateEffect,\n} from \"@yamada-ui/utils\"\nimport type { CSSProperties, KeyboardEvent, KeyboardEventHandler } from \"react\"\nimport { useCallback, useMemo, useRef, useState } from \"react\"\n\nexport type Hsv = [number, number, number]\ntype Overlay = HTMLUIProps<\"div\"> | ((value: Hsv) => HTMLUIProps<\"div\">)\n\nconst defaultOverlays = (withShadow: boolean): Overlay[] => {\n  let overlays: Overlay[] = [\n    ([h]) => ({\n      bg: `hsl(${h}, 100%, 50%)`,\n      bgImage:\n        \"linear-gradient(0deg, #000, transparent), linear-gradient(90deg, #fff, transparent)\",\n    }),\n  ]\n\n  if (withShadow)\n    overlays = [\n      ...overlays,\n      {\n        boxShadow: `rgba(0, 0, 0, .1) 0 0 0 1px inset, rgb(0, 0, 0, .15) 0 0 4px inset`,\n      },\n    ]\n\n  return overlays\n}\n\ntype UseSaturationSliderOptions = {\n  /**\n   * The base `id` to use for the saturation slider.\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms.\n   */\n  name?: string\n  /**\n   * The value of the saturation slider.\n   */\n  value?: Hsv\n  /**\n   * The initial value of the saturation slider.\n   *\n   * @default \"[0, 0, 1]\"\n   */\n  defaultValue?: Hsv\n  /**\n   * Function called whenever the saturation slider value changes.\n   */\n  onChange?: (value: Hsv) => void\n  /**\n   * Function called when the user starts selecting a new value.\n   */\n  onChangeStart?: (value: Hsv) => void\n  /**\n   * Function called when the user is done selecting a new value.\n   */\n  onChangeEnd?: (value: Hsv) => void\n  /**\n   * The step in which increments or decrements have to be made.\n   *\n   * @default 0.01\n   */\n  step?: number\n  /**\n   * If `false`, the saturation slider handle will not capture focus when value changes.\n   *\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The CSS `background` property. Used in `background` of thumb element.\n   */\n  thumbColor?: CSSUIProps[\"bg\"]\n  /**\n   * If `true`, the slider has an inner `box-shadow`.\n   *\n   * @default true\n   */\n  withShadow?: boolean\n  /**\n   * The overlay used for the saturation slider.\n   */\n  overlays?: Overlay[]\n}\n\nexport type UseSaturationSliderProps = Omit<\n  HTMLUIProps<\"div\">,\n  \"defaultValue\" | \"onChange\"\n> &\n  UseSaturationSliderOptions &\n  FormControlOptions\n\nexport const useSaturationSlider = ({\n  focusThumbOnChange = true,\n  ...props\n}: UseSaturationSliderProps) => {\n  if (!focusThumbOnChange) props.isReadOnly = true\n\n  let {\n    id,\n    name,\n    value: valueProp,\n    defaultValue = [0, 0, 1],\n    onChange: onChangeProp,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 0.01,\n    thumbColor,\n    required,\n    disabled,\n    readOnly,\n    withShadow = true,\n    overlays: overlaysProp = defaultOverlays(withShadow),\n    ...rest\n  } = useFormControlProps(props)\n\n  const onChangeStart = useCallbackRef(onChangeStartProp)\n  const onChangeEnd = useCallbackRef(onChangeEndProp)\n\n  const [value, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue,\n    onChange: onChangeProp,\n  })\n  const [isDragging, setDragging] = useState(false)\n  const isInteractive = !(disabled || readOnly)\n  let [h, s, v] = value\n\n  s = clampNumber(s, 0, 1)\n  v = clampNumber(v, 0, 1)\n\n  const containerRef = useRef<HTMLElement>(null)\n  const trackRef = useRef<HTMLElement>(null)\n  const thumbRef = useRef<HTMLElement>(null)\n  const latestRef = useLatestRef({\n    value,\n    step,\n    isInteractive,\n    eventSource: null as \"pointer\" | \"keyboard\" | null,\n    focusThumbOnChange,\n  })\n\n  const thumbSize = useSize(thumbRef)\n\n  const overlays = useMemo(\n    () => overlaysProp.map((propsOrFunc) => runIfFunc(propsOrFunc, [h, s, v])),\n    [overlaysProp, h, s, v],\n  )\n\n  const getValueFromPointer = useCallback(\n    (ev: any) => {\n      if (!trackRef.current) return []\n\n      const { step } = latestRef.current\n\n      latestRef.current.eventSource = \"pointer\"\n\n      const { bottom, left, height, width } =\n        trackRef.current.getBoundingClientRect()\n      const { clientX, clientY } = ev.touches?.[0] ?? ev\n\n      let s = clampNumber((clientX - left) / width, 0, 1)\n      let v = clampNumber((bottom - clientY) / height, 0, 1)\n\n      if (step) {\n        s = parseFloat(roundNumberToStep(s, 0, step))\n        v = parseFloat(roundNumberToStep(v, 0, step))\n      }\n\n      return [s, v]\n    },\n    [latestRef],\n  )\n\n  const setValueFromPointer = (ev: MouseEvent | TouchEvent | PointerEvent) => {\n    const { value } = latestRef.current\n    const [nextS, nextV] = getValueFromPointer(ev)\n\n    if (nextS == null || nextV == null) return\n\n    const [, s, v] = value\n\n    if (nextS !== s || nextV !== v) setValue(([h]) => [h, nextS, nextV])\n  }\n\n  const focusThumb = useCallback(() => {\n    const { focusThumbOnChange } = latestRef.current\n\n    if (focusThumbOnChange) setTimeout(() => thumbRef.current?.focus())\n  }, [latestRef])\n\n  const constrain = useCallback(\n    ([s, v]: [number, number]) => {\n      const { isInteractive } = latestRef.current\n\n      if (!isInteractive) return\n\n      s = clampNumber(s, 0, 1)\n      v = clampNumber(v, 0, 1)\n\n      setValue(([h]) => [h, s, v])\n    },\n    [latestRef, setValue],\n  )\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLElement>) => {\n      const actions: Record<string, KeyboardEventHandler> = {\n        ArrowRight: () => constrain([s + step, v]),\n        ArrowUp: () => constrain([s, v + step]),\n        ArrowLeft: () => constrain([s - step, v]),\n        ArrowDown: () => constrain([s, v - step]),\n      }\n\n      const action = actions[ev.key]\n\n      if (!action) return\n\n      ev.preventDefault()\n      ev.stopPropagation()\n\n      action(ev)\n\n      latestRef.current.eventSource = \"keyboard\"\n    },\n    [latestRef, constrain, s, v, step],\n  )\n\n  usePanEvent(containerRef, {\n    onSessionStart: (ev) => {\n      const { isInteractive, value } = latestRef.current\n\n      if (!isInteractive) return\n\n      setDragging(true)\n      focusThumb()\n      setValueFromPointer(ev)\n      onChangeStart(value)\n    },\n    onSessionEnd: () => {\n      const { isInteractive, value } = latestRef.current\n\n      if (!isInteractive) return\n\n      setDragging(false)\n      onChangeEnd(value)\n    },\n    onMove: (ev) => {\n      const { isInteractive } = latestRef.current\n\n      if (!isInteractive) return\n\n      setValueFromPointer(ev)\n    },\n  })\n\n  useUpdateEffect(() => {\n    const { eventSource, value } = latestRef.current\n\n    if (eventSource === \"keyboard\") onChangeEnd(value)\n  }, [value, onChangeEnd])\n\n  const getContainerProps: UIPropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ...omitObject(rest, [\"aria-readonly\"]),\n      ref: mergeRefs(ref, containerRef),\n      tabIndex: -1,\n    }),\n    [rest],\n  )\n\n  const getInnerProps: UIPropGetter = useCallback(\n    (props = {}, ref = null) => {\n      const { width: w } = thumbSize ?? { width: 0 }\n\n      const style: CSSProperties = {\n        ...props.style,\n        ...rest.style,\n        padding: `${w / 2}px`,\n      }\n\n      return {\n        ...props,\n        ref,\n        style,\n      }\n    },\n    [rest, thumbSize],\n  )\n\n  const getInputProps: UIPropGetter<\"input\"> = useCallback(\n    (props = {}, ref = null) => ({\n      ...pickObject(rest, formControlProperties),\n      ...props,\n      id,\n      ref,\n      type: \"hidden\",\n      name,\n      value: [h, s, v].toString(),\n      required,\n      disabled,\n      readOnly,\n    }),\n    [disabled, id, name, readOnly, required, rest, h, s, v],\n  )\n\n  const getTrackProps: UIPropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...pickObject(\n        rest,\n        getFormControlProperties({ omit: [\"aria-readonly\"] }),\n      ),\n      ...props,\n      ref: mergeRefs(ref, trackRef),\n    }),\n    [rest],\n  )\n\n  const getThumbProps: UIPropGetter = useCallback(\n    (props = {}, ref = null) => {\n      const { width, height } = thumbSize ?? { width: 0, height: 0 }\n      const x = s * 100\n      const y = v * 100\n\n      const style: CSSProperties = {\n        ...props.style,\n        position: \"absolute\",\n        userSelect: \"none\",\n        touchAction: \"none\",\n        left: `calc(${x}% - ${width / 2}px)`,\n        bottom: `calc(${y}% - ${height / 2}px)`,\n      }\n\n      return {\n        \"aria-label\": \"Saturation and brightness thumb\",\n        bg: thumbColor ?? hsvTo([h, s, v])(),\n        ...pickObject(rest, formControlProperties),\n        ...props,\n        ref: mergeRefs(ref, thumbRef),\n        tabIndex: isInteractive && focusThumbOnChange ? 0 : undefined,\n        role: \"slider\",\n        \"aria-valuenow\": s,\n        \"aria-valuemin\": 0,\n        \"aria-valuemax\": 100,\n        \"aria-valuetext\": `saturation ${s}, brightness ${v}`,\n        \"data-active\": dataAttr(isDragging && focusThumbOnChange),\n        onKeyDown: handlerAll(props.onKeyDown, onKeyDown),\n        onFocus: handlerAll(props.onFocus, rest.onFocus),\n        onBlur: handlerAll(props.onBlur, rest.onBlur),\n        style,\n      }\n    },\n    [\n      h,\n      s,\n      v,\n      thumbColor,\n      focusThumbOnChange,\n      isDragging,\n      isInteractive,\n      onKeyDown,\n      rest,\n      thumbSize,\n    ],\n  )\n\n  return {\n    value,\n    overlays,\n    getContainerProps,\n    getInnerProps,\n    getTrackProps,\n    getInputProps,\n    getThumbProps,\n  }\n}\n\nexport type UseSaturationSliderReturn = ReturnType<typeof useSaturationSlider>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}