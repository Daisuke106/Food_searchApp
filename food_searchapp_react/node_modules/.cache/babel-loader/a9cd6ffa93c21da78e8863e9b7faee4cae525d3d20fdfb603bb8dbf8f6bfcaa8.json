{"ast":null,"code":"\"use client\";\n\n// src/index.ts\nimport { assignRef, isElement, useCallbackRef, useUnmountEffect } from \"@yamada-ui/utils\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nvar isScrollable = (el, isVertical) => {\n  const style = getComputedStyle(el);\n  if ([\"auto\", \"scroll\", \"overlay\"].includes(style.overflow)) return true;\n  if (isVertical) {\n    return [\"auto\", \"scroll\", \"overlay\"].includes(style.overflowY);\n  } else {\n    return [\"auto\", \"scroll\", \"overlay\"].includes(style.overflowX);\n  }\n};\nvar onScroll = _ref => {\n  let {\n    root,\n    isVertical,\n    isReverse,\n    behavior,\n    position\n  } = _ref;\n  let options;\n  const el = isElement(root) && isScrollable(root, isVertical) ? root : document.body;\n  if (isVertical) {\n    options = {\n      top: position != null ? position : isReverse ? el.scrollHeight : 0,\n      behavior\n    };\n  } else {\n    options = {\n      left: position != null ? position : isReverse ? el.scrollWidth : 0,\n      behavior\n    };\n  }\n  if (el === document.body) {\n    window.scrollTo(options);\n  } else {\n    el.scrollTo(options);\n  }\n};\nvar getScrollPosition = (root, isVertical) => {\n  const el = isElement(root) && isScrollable(root, isVertical) ? root : document.body;\n  if (isVertical) {\n    return el.scrollHeight - el.scrollTop;\n  } else {\n    return el.scrollWidth - el.scrollLeft;\n  }\n};\nvar useInfiniteScroll = function () {\n  let {\n    orientation = \"vertical\",\n    rootRef,\n    rootMargin,\n    threshold,\n    initialLoad = false,\n    startIndex = initialLoad ? 0 : 1,\n    onLoad: onLoadProp,\n    resetRef,\n    indexRef: indexRefProp,\n    isDisabled = false,\n    isReverse = false,\n    behavior\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const ref = useRef(null);\n  const indexRef = useRef(startIndex);\n  const processingRef = useRef(false);\n  const observerRef = useRef(void 0);\n  const isMountedRef = useRef(false);\n  const prevScrollPosition = useRef(0);\n  const [isFinish, setIsFinish] = useState(false);\n  const onLoad = useCallbackRef(onLoadProp);\n  const isVertical = orientation === \"vertical\";\n  const options = useMemo(() => {\n    const root = rootRef == null ? void 0 : rootRef.current;\n    return {\n      root,\n      rootMargin,\n      threshold\n    };\n  }, [rootMargin, rootRef, threshold]);\n  const onReset = useCallback(function () {\n    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let runScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    indexRef.current = index;\n    setIsFinish(false);\n    if (runScroll) {\n      const root = rootRef == null ? void 0 : rootRef.current;\n      onScroll({\n        root,\n        isVertical,\n        isReverse,\n        behavior\n      });\n    }\n    if (isDisabled) return;\n    setTimeout(() => {\n      const observer = observerRef.current;\n      const el = ref.current;\n      if (el) observer == null ? void 0 : observer.observe(el);\n    });\n  }, [isDisabled, isReverse, rootRef, isVertical, behavior]);\n  const onFinish = useCallback(() => {\n    const observer = observerRef.current;\n    const el = ref.current;\n    if (el) observer == null ? void 0 : observer.unobserve(el);\n    setIsFinish(true);\n  }, []);\n  const createObserver = useCallback(() => {\n    const observer = new IntersectionObserver(async _ref2 => {\n      let [entry] = _ref2;\n      if (!entry.isIntersecting || processingRef.current) return;\n      const props = {\n        index: indexRef.current,\n        entry,\n        finish: onFinish\n      };\n      processingRef.current = true;\n      const root = rootRef == null ? void 0 : rootRef.current;\n      if (isReverse) {\n        prevScrollPosition.current = getScrollPosition(root, isVertical);\n      }\n      await (onLoad == null ? void 0 : onLoad(props));\n      if (isReverse) {\n        const position = prevScrollPosition.current;\n        onScroll({\n          root,\n          isVertical,\n          position\n        });\n      }\n      indexRef.current += 1;\n      processingRef.current = false;\n    }, options);\n    return observer;\n  }, [onFinish, onLoad, options, rootRef, isReverse, isVertical]);\n  useEffect(() => {\n    const setupObserver = async () => {\n      const el = ref.current;\n      const isMounted = isMountedRef.current;\n      const index = indexRef.current;\n      if (initialLoad && !isMounted) {\n        processingRef.current = true;\n        await onLoad({\n          index,\n          finish: onFinish\n        });\n        indexRef.current += 1;\n        processingRef.current = false;\n      }\n      if (isDisabled) return;\n      observerRef.current = createObserver();\n      const observer = observerRef.current;\n      if (isReverse && !isMounted) {\n        const root = rootRef == null ? void 0 : rootRef.current;\n        onScroll({\n          root,\n          isVertical,\n          isReverse\n        });\n        isMountedRef.current = true;\n      }\n      setTimeout(() => {\n        if (el) observer.observe(el);\n      });\n      return () => {\n        if (el) observer.unobserve(el);\n      };\n    };\n    setupObserver();\n  }, [createObserver, initialLoad, isDisabled, isReverse, isVertical, onFinish, onLoad, rootRef]);\n  useUnmountEffect(() => isMountedRef.current = false);\n  assignRef(resetRef, onReset);\n  assignRef(indexRefProp, index => indexRef.current = index);\n  return {\n    ref,\n    isFinish\n  };\n};\nexport { useInfiniteScroll };","map":{"version":3,"names":["assignRef","isElement","useCallbackRef","useUnmountEffect","useCallback","useEffect","useMemo","useRef","useState","isScrollable","el","isVertical","style","getComputedStyle","includes","overflow","overflowY","overflowX","onScroll","_ref","root","isReverse","behavior","position","options","document","body","top","scrollHeight","left","scrollWidth","window","scrollTo","getScrollPosition","scrollTop","scrollLeft","useInfiniteScroll","orientation","rootRef","rootMargin","threshold","initialLoad","startIndex","onLoad","onLoadProp","resetRef","indexRef","indexRefProp","isDisabled","arguments","length","undefined","ref","processingRef","observerRef","isMountedRef","prevScrollPosition","isFinish","setIsFinish","current","onReset","index","runScroll","setTimeout","observer","observe","onFinish","unobserve","createObserver","IntersectionObserver","_ref2","entry","isIntersecting","props","finish","setupObserver","isMounted"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\use-infinite-scroll\\src\\index.ts"],"sourcesContent":["import {\n  assignRef,\n  isElement,\n  useCallbackRef,\n  useUnmountEffect,\n} from \"@yamada-ui/utils\"\nimport type { RefObject } from \"react\"\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\"\n\nconst isScrollable = (el: HTMLElement, isVertical: boolean) => {\n  const style = getComputedStyle(el)\n\n  if ([\"auto\", \"scroll\", \"overlay\"].includes(style.overflow)) return true\n\n  if (isVertical) {\n    return [\"auto\", \"scroll\", \"overlay\"].includes(style.overflowY)\n  } else {\n    return [\"auto\", \"scroll\", \"overlay\"].includes(style.overflowX)\n  }\n}\n\nconst onScroll = ({\n  root,\n  isVertical,\n  isReverse,\n  behavior,\n  position,\n}: {\n  root: HTMLElement | null | undefined\n  isVertical: boolean\n  isReverse?: boolean\n  behavior?: ScrollBehavior\n  position?: number\n}) => {\n  let options: ScrollToOptions\n  const el =\n    isElement(root) && isScrollable(root, isVertical) ? root : document.body\n\n  if (isVertical) {\n    options = { top: position ?? (isReverse ? el.scrollHeight : 0), behavior }\n  } else {\n    options = { left: position ?? (isReverse ? el.scrollWidth : 0), behavior }\n  }\n\n  if (el === document.body) {\n    window.scrollTo(options)\n  } else {\n    el.scrollTo(options)\n  }\n}\n\nconst getScrollPosition = (\n  root: HTMLElement | null | undefined,\n  isVertical: boolean,\n) => {\n  const el =\n    isElement(root) && isScrollable(root, isVertical) ? root : document.body\n\n  if (isVertical) {\n    return el.scrollHeight - el.scrollTop\n  } else {\n    return el.scrollWidth - el.scrollLeft\n  }\n}\n\nexport type UseInfiniteScrollProps = Omit<IntersectionObserverInit, \"root\"> & {\n  /**\n   * The orientation of the infinite scroll.\n   *\n   * @default 'vertical'\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * The element that is used as the viewport for checking visibility of the target.\n   * Defaults to the browser viewport if not specified or if `null`.\n   */\n  rootRef?: RefObject<HTMLElement>\n  /**\n   * Margin around the root. Can have values similar to the CSS margin property,\n   * e.g. \"10px 20px 30px 40px\" (top, right, bottom, left).\n   */\n  rootMargin?: string\n  /**\n   * Either a single number or an array of numbers which indicate at what percentage of the target's visibility the observer's callback should be executed.\n   */\n  threshold?: number | number[]\n  /**\n   * If set the `onLoad` function will start from the given index.\n   * If `initialLoad` is `true`, index starts from `0`.\n   *\n   * @default 1\n   */\n  startIndex?: number\n  /**\n   * The callback invoked when trigger is intersect.\n   */\n  onLoad?: ({\n    index,\n    entry,\n    finish,\n  }: {\n    index: number\n    finish: () => void\n    entry?: IntersectionObserverEntry\n  }) => Promise<void>\n  /**\n   * Ref to a reset function.\n   */\n  resetRef?: RefObject<(index?: number, runScroll?: boolean) => void>\n  /**\n   * Ref to a reset index function.\n   */\n  indexRef?: RefObject<(index: number) => void>\n  /**\n   * If `true`, the infinite scroll is disabled.\n   *\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   *  If `true`, reverse direction.\n   *\n   * @default false\n   */\n  isReverse?: boolean\n  /**\n   * If `true`, invoke `onLoad` function for the first time.\n   *\n   * @default false\n   */\n  initialLoad?: boolean\n  /**\n   * Determines whether scrolling is instant or animates smoothly.\n   */\n  behavior?: ScrollBehavior\n}\n\n/**\n * `useInfiniteScroll` is a custom hook for providing infinite scroll functionality.\n *\n * @see Docs https://yamada-ui.com/hooks/use-infinite-scroll\n */\nexport const useInfiniteScroll = <T extends HTMLElement = HTMLDivElement>({\n  orientation = \"vertical\",\n  rootRef,\n  rootMargin,\n  threshold,\n  initialLoad = false,\n  startIndex = initialLoad ? 0 : 1,\n  onLoad: onLoadProp,\n  resetRef,\n  indexRef: indexRefProp,\n  isDisabled = false,\n  isReverse = false,\n  behavior,\n}: UseInfiniteScrollProps = {}) => {\n  const ref = useRef<T>(null)\n  const indexRef = useRef<number>(startIndex)\n  const processingRef = useRef<boolean>(false)\n  const observerRef = useRef<IntersectionObserver | undefined>(undefined)\n  const isMountedRef = useRef<boolean>(false)\n  const prevScrollPosition = useRef<number>(0)\n  const [isFinish, setIsFinish] = useState<boolean>(false)\n  const onLoad = useCallbackRef(onLoadProp)\n  const isVertical = orientation === \"vertical\"\n  const options: IntersectionObserverInit = useMemo(() => {\n    const root = rootRef?.current\n\n    return { root, rootMargin, threshold }\n  }, [rootMargin, rootRef, threshold])\n\n  const onReset = useCallback(\n    (index: number = 1, runScroll: boolean = true) => {\n      indexRef.current = index\n\n      setIsFinish(false)\n\n      if (runScroll) {\n        const root = rootRef?.current\n\n        onScroll({ root, isVertical, isReverse, behavior })\n      }\n\n      if (isDisabled) return\n\n      setTimeout(() => {\n        const observer = observerRef.current\n        const el = ref.current\n\n        if (el) observer?.observe(el)\n      })\n    },\n    [isDisabled, isReverse, rootRef, isVertical, behavior],\n  )\n\n  const onFinish = useCallback(() => {\n    const observer = observerRef.current\n    const el = ref.current\n\n    if (el) observer?.unobserve(el)\n\n    setIsFinish(true)\n  }, [])\n\n  const createObserver = useCallback(() => {\n    const observer = new IntersectionObserver(async ([entry]) => {\n      if (!entry.isIntersecting || processingRef.current) return\n\n      const props = { index: indexRef.current, entry, finish: onFinish }\n\n      processingRef.current = true\n\n      const root = rootRef?.current\n\n      if (isReverse) {\n        prevScrollPosition.current = getScrollPosition(root, isVertical)\n      }\n\n      await onLoad?.(props)\n\n      if (isReverse) {\n        const position = prevScrollPosition.current\n\n        onScroll({ root, isVertical, position })\n      }\n\n      indexRef.current += 1\n      processingRef.current = false\n    }, options)\n\n    return observer\n  }, [onFinish, onLoad, options, rootRef, isReverse, isVertical])\n\n  useEffect(() => {\n    const setupObserver = async () => {\n      const el = ref.current\n      const isMounted = isMountedRef.current\n      const index = indexRef.current\n\n      if (initialLoad && !isMounted) {\n        processingRef.current = true\n\n        await onLoad({ index, finish: onFinish })\n\n        indexRef.current += 1\n        processingRef.current = false\n      }\n\n      if (isDisabled) return\n\n      observerRef.current = createObserver()\n\n      const observer = observerRef.current\n\n      if (isReverse && !isMounted) {\n        const root = rootRef?.current\n\n        onScroll({ root, isVertical, isReverse })\n\n        isMountedRef.current = true\n      }\n\n      setTimeout(() => {\n        if (el) observer.observe(el)\n      })\n\n      return () => {\n        if (el) observer.unobserve(el)\n      }\n    }\n\n    setupObserver()\n  }, [\n    createObserver,\n    initialLoad,\n    isDisabled,\n    isReverse,\n    isVertical,\n    onFinish,\n    onLoad,\n    rootRef,\n  ])\n\n  useUnmountEffect(() => (isMountedRef.current = false))\n\n  assignRef(resetRef, onReset)\n  assignRef(indexRefProp, (index) => (indexRef.current = index))\n\n  return { ref, isFinish }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}