{"ast":null,"code":"\"use client\";\n\n// src/index.ts\nimport { useLatestRef } from \"@yamada-ui/use-latest-ref\";\nimport { addPointerEvent, getEventPoint, isMultiTouchEvent } from \"@yamada-ui/utils\";\nimport sync, { cancelSync, getFrameData } from \"framesync\";\nimport { useEffect, useRef } from \"react\";\nvar subtract = (a, b) => ({\n  x: a.x - b.x,\n  y: a.y - b.y\n});\nvar getPanInfo = (info, history) => ({\n  point: info.point,\n  delta: subtract(info.point, history[history.length - 1]),\n  offset: subtract(info.point, history[0]),\n  velocity: getVelocity(history, 0.1)\n});\nvar toMilliseconds = v => v * 1e3;\nvar getVelocity = (history, timeDelta) => {\n  if (history.length < 2) return {\n    x: 0,\n    y: 0\n  };\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = history[history.length - 1];\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) return {\n    x: 0,\n    y: 0\n  };\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;\n  if (time === 0) return {\n    x: 0,\n    y: 0\n  };\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) currentVelocity.x = 0;\n  if (currentVelocity.y === Infinity) currentVelocity.y = 0;\n  return currentVelocity;\n};\nvar pipe = (...fns) => v => fns.reduce((a, b) => b(a), v);\nvar distance1D = (a, b) => Math.abs(a - b);\nvar isPoint = point => \"x\" in point && \"y\" in point;\nvar distance = (a, b) => {\n  if (typeof a === \"number\" && typeof b === \"number\") return distance1D(a, b);\n  if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x);\n    const yDelta = distance1D(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n  }\n  return 0;\n};\nvar panEvent = (ev, handlers, threshold = 3) => {\n  var _a;\n  if (isMultiTouchEvent(ev)) return;\n  const win = (_a = ev.view) != null ? _a : window;\n  const info = {\n    point: getEventPoint(ev)\n  };\n  const {\n    timestamp\n  } = getFrameData();\n  const {\n    onSessionStart,\n    onStart,\n    onMove,\n    onEnd,\n    onSessionEnd\n  } = handlers;\n  const history = [{\n    ...info.point,\n    timestamp\n  }];\n  let startEvent = null;\n  let lastEvent = null;\n  let lastEventInfo = null;\n  ev.stopPropagation();\n  ev.preventDefault();\n  onSessionStart == null ? void 0 : onSessionStart(ev, getPanInfo(info, history));\n  const updatePoint = () => {\n    if (!(lastEvent && lastEventInfo)) return;\n    const info2 = getPanInfo(lastEventInfo, history);\n    const isPanStarted = startEvent !== null;\n    const isDistancePastThreshold = distance(info2.offset, {\n      x: 0,\n      y: 0\n    }) >= threshold;\n    if (!isPanStarted && !isDistancePastThreshold) return;\n    const {\n      timestamp: timestamp2\n    } = getFrameData();\n    history.push({\n      ...info2.point,\n      timestamp: timestamp2\n    });\n    if (!isPanStarted) {\n      onStart == null ? void 0 : onStart(lastEvent, info2);\n      startEvent = lastEvent;\n    }\n    onMove == null ? void 0 : onMove(lastEvent, info2);\n  };\n  const onPointerMove = (ev2, info2) => {\n    lastEvent = ev2;\n    lastEventInfo = info2;\n    sync.update(updatePoint, true);\n  };\n  const onPointerUp = (ev2, info2) => {\n    const panInfo = getPanInfo(info2, history);\n    onSessionEnd == null ? void 0 : onSessionEnd(ev2, panInfo);\n    end();\n    if (!onEnd || !startEvent) return;\n    onEnd == null ? void 0 : onEnd(ev2, panInfo);\n  };\n  const updateHandlers = newHandlers => {\n    handlers = newHandlers;\n  };\n  let removeListeners = pipe(addPointerEvent(win, \"pointermove\", onPointerMove), addPointerEvent(win, \"pointerup\", onPointerUp), addPointerEvent(win, \"pointercancel\", onPointerUp));\n  const end = () => {\n    removeListeners == null ? void 0 : removeListeners();\n    cancelSync.update(updatePoint);\n  };\n  return {\n    updateHandlers,\n    end\n  };\n};\nvar usePanEvent = (ref, {\n  onMove,\n  onStart,\n  onEnd,\n  onSessionStart,\n  onSessionEnd,\n  threshold\n}) => {\n  const hasPanEvents = !!onMove || !!onStart || !!onEnd || !!onSessionStart || !!onSessionEnd;\n  const panSession = useRef(null);\n  const handlersRef = useLatestRef({\n    onSessionStart,\n    onSessionEnd,\n    onStart,\n    onMove,\n    onEnd: (ev, info) => {\n      panSession.current = null;\n      onEnd == null ? void 0 : onEnd(ev, info);\n    }\n  });\n  useEffect(() => {\n    var _a;\n    (_a = panSession.current) == null ? void 0 : _a.updateHandlers(handlersRef.current);\n  });\n  useEffect(() => {\n    const node = ref.current;\n    if (!node || !hasPanEvents) return;\n    const onPointerDown = ev => {\n      panSession.current = panEvent(ev, handlersRef.current, threshold);\n    };\n    return addPointerEvent(node, \"pointerdown\", onPointerDown);\n  }, [ref, hasPanEvents, handlersRef, threshold]);\n  useEffect(() => {\n    return () => {\n      var _a;\n      (_a = panSession.current) == null ? void 0 : _a.end();\n      panSession.current = null;\n    };\n  }, []);\n};\nexport { usePanEvent };","map":{"version":3,"names":["useLatestRef","addPointerEvent","getEventPoint","isMultiTouchEvent","sync","cancelSync","getFrameData","useEffect","useRef","subtract","a","b","x","y","getPanInfo","info","history","point","delta","length","offset","velocity","getVelocity","toMilliseconds","v","timeDelta","i","timestampedPoint","lastPoint","timestamp","time","currentVelocity","Infinity","pipe","fns","reduce","distance1D","Math","abs","isPoint","distance","xDelta","yDelta","sqrt","panEvent","ev","handlers","threshold","_a","win","view","window","onSessionStart","onStart","onMove","onEnd","onSessionEnd","startEvent","lastEvent","lastEventInfo","stopPropagation","preventDefault","updatePoint","info2","isPanStarted","isDistancePastThreshold","timestamp2","push","onPointerMove","ev2","update","onPointerUp","panInfo","end","updateHandlers","newHandlers","removeListeners","usePanEvent","ref","hasPanEvents","panSession","handlersRef","current","node","onPointerDown"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\use-pan-event\\src\\index.ts"],"sourcesContent":["import { useLatestRef } from \"@yamada-ui/use-latest-ref\"\nimport type { AnyPointerEvent, Point, PointerEventInfo } from \"@yamada-ui/utils\"\nimport {\n  addPointerEvent,\n  getEventPoint,\n  isMultiTouchEvent,\n} from \"@yamada-ui/utils\"\nimport sync, { cancelSync, getFrameData } from \"framesync\"\nimport type { RefObject } from \"react\"\nimport { useEffect, useRef } from \"react\"\n\ntype PanEventInfo = {\n  point: Point\n  delta: Point\n  offset: Point\n  velocity: Point\n}\n\ntype PanEventHandler = (ev: AnyPointerEvent, info: PanEventInfo) => void\n\ntype TimestampedPoint = Point & { timestamp: number }\n\ntype PanEventHistory = TimestampedPoint[]\n\ntype PanEventHandlers = {\n  onSessionStart: PanEventHandler\n  onSessionEnd: PanEventHandler\n  onStart: PanEventHandler\n  onMove: PanEventHandler\n  onEnd: PanEventHandler\n}\n\nconst subtract = (a: Point, b: Point) => ({ x: a.x - b.x, y: a.y - b.y })\n\nconst getPanInfo = (info: PointerEventInfo, history: PanEventHistory) => ({\n  point: info.point,\n  delta: subtract(info.point, history[history.length - 1]),\n  offset: subtract(info.point, history[0]),\n  velocity: getVelocity(history, 0.1),\n})\n\nconst toMilliseconds = (v: number) => v * 1000\n\nconst getVelocity = (history: TimestampedPoint[], timeDelta: number): Point => {\n  if (history.length < 2) return { x: 0, y: 0 }\n\n  let i = history.length - 1\n  let timestampedPoint: TimestampedPoint | null = null\n\n  const lastPoint = history[history.length - 1]\n\n  while (i >= 0) {\n    timestampedPoint = history[i]\n\n    if (\n      lastPoint.timestamp - timestampedPoint.timestamp >\n      toMilliseconds(timeDelta)\n    ) {\n      break\n    }\n\n    i--\n  }\n\n  if (!timestampedPoint) return { x: 0, y: 0 }\n\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000\n\n  if (time === 0) return { x: 0, y: 0 }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time,\n  }\n\n  if (currentVelocity.x === Infinity) currentVelocity.x = 0\n\n  if (currentVelocity.y === Infinity) currentVelocity.y = 0\n\n  return currentVelocity\n}\n\nconst pipe =\n  <Y extends any>(...fns: ((a: Y) => Y)[]) =>\n  (v: Y) =>\n    fns.reduce((a, b) => b(a), v)\n\nconst distance1D = (a: number, b: number) => Math.abs(a - b)\n\nconst isPoint = (point: any): point is { x: number; y: number } =>\n  \"x\" in point && \"y\" in point\n\nconst distance = <Y extends Point | number>(a: Y, b: Y) => {\n  if (typeof a === \"number\" && typeof b === \"number\") return distance1D(a, b)\n\n  if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x)\n    const yDelta = distance1D(a.y, b.y)\n\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2)\n  }\n\n  return 0\n}\n\nconst panEvent = (\n  ev: AnyPointerEvent,\n  handlers: Partial<PanEventHandlers>,\n  threshold: number = 3,\n) => {\n  if (isMultiTouchEvent(ev)) return\n\n  const win = ev.view ?? window\n  const info = { point: getEventPoint(ev) }\n  const { timestamp } = getFrameData()\n  const { onSessionStart, onStart, onMove, onEnd, onSessionEnd } = handlers\n\n  const history: PanEventHistory = [{ ...info.point, timestamp }]\n\n  let startEvent: AnyPointerEvent | null = null\n  let lastEvent: AnyPointerEvent | null = null\n  let lastEventInfo: PointerEventInfo | null = null\n\n  ev.stopPropagation()\n  ev.preventDefault()\n\n  onSessionStart?.(ev, getPanInfo(info, history))\n\n  const updatePoint = () => {\n    if (!(lastEvent && lastEventInfo)) return\n\n    const info = getPanInfo(lastEventInfo, history)\n\n    const isPanStarted = startEvent !== null\n\n    const isDistancePastThreshold =\n      distance(info.offset, { x: 0, y: 0 }) >= threshold\n\n    if (!isPanStarted && !isDistancePastThreshold) return\n\n    const { timestamp } = getFrameData()\n\n    history.push({ ...info.point, timestamp })\n\n    if (!isPanStarted) {\n      onStart?.(lastEvent, info)\n\n      startEvent = lastEvent\n    }\n\n    onMove?.(lastEvent, info)\n  }\n\n  const onPointerMove = (ev: AnyPointerEvent, info: PointerEventInfo) => {\n    lastEvent = ev\n    lastEventInfo = info\n\n    sync.update(updatePoint, true)\n  }\n\n  const onPointerUp = (ev: AnyPointerEvent, info: PointerEventInfo) => {\n    const panInfo = getPanInfo(info, history)\n\n    onSessionEnd?.(ev, panInfo)\n\n    end()\n\n    if (!onEnd || !startEvent) return\n\n    onEnd?.(ev, panInfo)\n  }\n\n  const updateHandlers = (newHandlers: Partial<PanEventHandlers>) => {\n    handlers = newHandlers\n  }\n\n  let removeListeners = pipe(\n    addPointerEvent(win, \"pointermove\", onPointerMove),\n    addPointerEvent(win, \"pointerup\", onPointerUp),\n    addPointerEvent(win, \"pointercancel\", onPointerUp),\n  )\n\n  const end = () => {\n    removeListeners?.()\n\n    cancelSync.update(updatePoint)\n  }\n\n  return {\n    updateHandlers,\n    end,\n  }\n}\n\ntype ReturnPanEvent = ReturnType<typeof panEvent>\n\nexport type UsePanEventProps = {\n  onMove?: PanEventHandler\n  onStart?: PanEventHandler\n  onEnd?: PanEventHandler\n  onSessionStart?: PanEventHandler\n  onSessionEnd?: PanEventHandler\n  threshold?: number\n}\n\nexport const usePanEvent = (\n  ref: RefObject<HTMLElement>,\n  {\n    onMove,\n    onStart,\n    onEnd,\n    onSessionStart,\n    onSessionEnd,\n    threshold,\n  }: UsePanEventProps,\n) => {\n  const hasPanEvents =\n    !!onMove || !!onStart || !!onEnd || !!onSessionStart || !!onSessionEnd\n\n  const panSession = useRef<ReturnPanEvent | null>(null)\n\n  const handlersRef = useLatestRef<Partial<PanEventHandlers>>({\n    onSessionStart,\n    onSessionEnd,\n    onStart,\n    onMove,\n    onEnd: (ev, info) => {\n      panSession.current = null\n\n      onEnd?.(ev, info)\n    },\n  })\n\n  useEffect(() => {\n    panSession.current?.updateHandlers(handlersRef.current)\n  })\n\n  useEffect(() => {\n    const node = ref.current\n\n    if (!node || !hasPanEvents) return\n\n    const onPointerDown = (ev: AnyPointerEvent) => {\n      panSession.current = panEvent(ev, handlersRef.current, threshold)\n    }\n\n    return addPointerEvent(node, \"pointerdown\", onPointerDown)\n  }, [ref, hasPanEvents, handlersRef, threshold])\n\n  useEffect(() => {\n    return () => {\n      panSession.current?.end()\n      panSession.current = null\n    }\n  }, [])\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}