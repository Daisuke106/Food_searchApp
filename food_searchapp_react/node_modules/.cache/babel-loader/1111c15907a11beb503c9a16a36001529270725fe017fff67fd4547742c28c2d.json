{"ast":null,"code":"\"use client\";\n\n// src/pin-input.tsx\nimport { ui, forwardRef, useMultiComponentStyle, omitThemeProps } from \"@yamada-ui/core\";\nimport { formControlProperties, useFormControlProps } from \"@yamada-ui/form-control\";\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\";\nimport { createDescendant } from \"@yamada-ui/use-descendant\";\nimport { createContext, cx, handlerAll, mergeRefs, pickObject, filterUndefined, getValidChildren } from \"@yamada-ui/utils\";\nimport { useCallback, useEffect, useId, useMemo, useState } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar toArray = value => value == null ? void 0 : value.split(\"\");\nvar validate = (value, type) => {\n  const NUMERIC_REGEX = /^[0-9]+$/;\n  const ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i;\n  const regex = type === \"alphanumeric\" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX;\n  return regex.test(value);\n};\nvar [PinInputProvider, usePinInputContext] = createContext({\n  strict: false,\n  name: \"PinInputContext\"\n});\nvar {\n  DescendantsContextProvider,\n  useDescendants,\n  useDescendant\n} = createDescendant();\nvar PinInput = forwardRef((_ref, ref) => {\n  let {\n    focusBorderColor,\n    errorBorderColor,\n    ...props\n  } = _ref;\n  const [styles, mergedProps] = useMultiComponentStyle(\"PinInput\", {\n    focusBorderColor,\n    errorBorderColor,\n    ...props\n  });\n  let {\n    id,\n    className,\n    type = \"number\",\n    placeholder = \"\\u25CB\",\n    value,\n    defaultValue,\n    autoFocus,\n    manageFocus = true,\n    otp = false,\n    mask,\n    readOnly,\n    \"aria-readonly\": ariaReadonly,\n    onChange: onChangeProp,\n    onComplete,\n    items = 4,\n    children,\n    ...rest\n  } = useFormControlProps(omitThemeProps(mergedProps));\n  const formControlProps = useMemo(() => ({\n    ...pickObject(rest, formControlProperties),\n    readOnly,\n    \"aria-readonly\": ariaReadonly\n  }), [ariaReadonly, readOnly, rest]);\n  id != null ? id : id = useId();\n  const descendants = useDescendants();\n  const [moveFocus, setMoveFocus] = useState(true);\n  const [focusedIndex, setFocusedIndex] = useState(-1);\n  useEffect(() => {\n    if (!autoFocus) return;\n    const firstValue = descendants.firstValue();\n    if (!firstValue) return;\n    requestAnimationFrame(() => firstValue.node.focus());\n  }, [autoFocus, descendants]);\n  const [values, setValues] = useControllableState({\n    value: toArray(value),\n    defaultValue: toArray(defaultValue) || [],\n    onChange: values2 => onChangeProp == null ? void 0 : onChangeProp(values2.join(\"\"))\n  });\n  const focusNext = useCallback(index => {\n    if (!moveFocus || !manageFocus) return;\n    const next = descendants.nextValue(index, void 0, false);\n    if (!next) return;\n    requestAnimationFrame(() => next.node.focus());\n  }, [descendants, moveFocus, manageFocus]);\n  const setValue = useCallback(function (value2, index) {\n    let isFocus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var _a;\n    let nextValues = [...values];\n    nextValues[index] = value2;\n    setValues(nextValues);\n    nextValues = nextValues.filter(Boolean);\n    const isComplete = value2 !== \"\" && nextValues.length === descendants.count() && nextValues.every(value3 => value3 != null && value3 !== \"\");\n    if (isComplete) {\n      onComplete == null ? void 0 : onComplete(nextValues.join(\"\"));\n      (_a = descendants.value(index)) == null ? void 0 : _a.node.blur();\n    } else if (isFocus) {\n      focusNext(index);\n    }\n  }, [values, setValues, descendants, onComplete, focusNext]);\n  const getNextValue = useCallback((value2, eventValue) => {\n    let nextValue = eventValue;\n    if (!(value2 == null ? void 0 : value2.length)) return nextValue;\n    if (value2[0] === eventValue.charAt(0)) {\n      nextValue = eventValue.charAt(1);\n    } else if (value2[0] === eventValue.charAt(1)) {\n      nextValue = eventValue.charAt(0);\n    }\n    return nextValue;\n  }, []);\n  const onChange = useCallback(index => _ref2 => {\n    let {\n      target\n    } = _ref2;\n    var _a;\n    const eventValue = target.value;\n    const currentValue = values[index];\n    const nextValue = getNextValue(currentValue, eventValue);\n    if (nextValue === \"\") {\n      setValue(\"\", index);\n      return;\n    }\n    if (eventValue.length > 2) {\n      if (!validate(eventValue, type)) return;\n      const nextValue2 = eventValue.split(\"\").filter((_, index2) => index2 < descendants.count());\n      setValues(nextValue2);\n      if (nextValue2.length === descendants.count()) {\n        onComplete == null ? void 0 : onComplete(nextValue2.join(\"\"));\n        (_a = descendants.value(index)) == null ? void 0 : _a.node.blur();\n      }\n    } else {\n      if (validate(nextValue, type)) setValue(nextValue, index);\n      setMoveFocus(true);\n    }\n  }, [descendants, getNextValue, onComplete, setValue, setValues, type, values]);\n  const onKeyDown = useCallback(index => _ref3 => {\n    let {\n      key,\n      target\n    } = _ref3;\n    var _a;\n    if (key !== \"Backspace\" || !manageFocus) return;\n    if (target.value === \"\") {\n      const prevInput = descendants.prevValue(index, void 0, false);\n      if (!prevInput) return;\n      setValue(\"\", index - 1, false);\n      (_a = prevInput.node) == null ? void 0 : _a.focus();\n      setMoveFocus(true);\n    } else {\n      setMoveFocus(false);\n    }\n  }, [descendants, manageFocus, setValue]);\n  const onFocus = useCallback(index => () => setFocusedIndex(index), []);\n  const onBlur = useCallback(() => setFocusedIndex(-1), []);\n  const getInputProps = useCallback(_ref4 => {\n    let {\n      index,\n      ...props2\n    } = _ref4;\n    return {\n      inputMode: type === \"number\" ? \"numeric\" : \"text\",\n      type: mask ? \"password\" : type === \"number\" ? \"tel\" : \"text\",\n      ...formControlProps,\n      ...filterUndefined(props2),\n      id: \"\".concat(id, \"-\").concat(index),\n      value: values[index] || \"\",\n      onChange: handlerAll(props2.onChange, onChange(index)),\n      onKeyDown: handlerAll(props2.onKeyDown, onKeyDown(index)),\n      onFocus: handlerAll(props2.onFocus, onFocus(index)),\n      onBlur: handlerAll(props2.onBlur, onBlur),\n      autoComplete: otp ? \"one-time-code\" : \"off\",\n      placeholder: focusedIndex === index && !readOnly && !props2.readOnly ? \"\" : placeholder\n    };\n  }, [type, mask, formControlProps, id, values, onChange, onKeyDown, onFocus, onBlur, otp, focusedIndex, readOnly, placeholder]);\n  const css = {\n    display: \"flex\",\n    alignItems: \"center\",\n    ...styles.container\n  };\n  let cloneChildren = getValidChildren(children);\n  if (!cloneChildren.length) for (let i = 0; i < items; i++) {\n    cloneChildren.push( /* @__PURE__ */jsx(PinInputField, {}, i));\n  }\n  return /* @__PURE__ */jsx(DescendantsContextProvider, {\n    value: descendants,\n    children: /* @__PURE__ */jsx(PinInputProvider, {\n      value: {\n        getInputProps,\n        styles\n      },\n      children: /* @__PURE__ */jsx(ui.div, {\n        ref,\n        className: cx(\"ui-pin-input\", className),\n        __css: css,\n        ...rest,\n        children: cloneChildren\n      })\n    })\n  });\n});\nvar PinInputField = forwardRef((_ref5, ref) => {\n  let {\n    className,\n    ...rest\n  } = _ref5;\n  const {\n    getInputProps,\n    styles\n  } = usePinInputContext();\n  const {\n    index,\n    register\n  } = useDescendant();\n  rest = useFormControlProps(rest);\n  const css = {\n    ...styles.field\n  };\n  return /* @__PURE__ */jsx(ui.input, {\n    className: cx(\"ui-pin-input__field\", className),\n    ...getInputProps({\n      ...rest,\n      ref: mergeRefs(register, ref),\n      index\n    }),\n    __css: css\n  });\n});\nexport { PinInput, PinInputField };","map":{"version":3,"names":["ui","forwardRef","useMultiComponentStyle","omitThemeProps","formControlProperties","useFormControlProps","useControllableState","createDescendant","createContext","cx","handlerAll","mergeRefs","pickObject","filterUndefined","getValidChildren","useCallback","useEffect","useId","useMemo","useState","jsx","toArray","value","split","validate","type","NUMERIC_REGEX","ALPHA_NUMERIC_REGEX","regex","test","PinInputProvider","usePinInputContext","strict","name","DescendantsContextProvider","useDescendants","useDescendant","PinInput","_ref","ref","focusBorderColor","errorBorderColor","props","styles","mergedProps","id","className","placeholder","defaultValue","autoFocus","manageFocus","otp","mask","readOnly","ariaReadonly","onChange","onChangeProp","onComplete","items","children","rest","formControlProps","descendants","moveFocus","setMoveFocus","focusedIndex","setFocusedIndex","firstValue","requestAnimationFrame","node","focus","values","setValues","values2","join","focusNext","index","next","nextValue","setValue","value2","isFocus","arguments","length","undefined","_a","nextValues","filter","Boolean","isComplete","count","every","value3","blur","getNextValue","eventValue","charAt","_ref2","target","currentValue","nextValue2","_","index2","onKeyDown","_ref3","key","prevInput","prevValue","onFocus","onBlur","getInputProps","_ref4","props2","inputMode","concat","autoComplete","css","display","alignItems","container","cloneChildren","i","push","PinInputField","div","__css","_ref5","register","field","input"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\pin-input\\src\\pin-input.tsx"],"sourcesContent":["import type {\n  CSSUIObject,\n  HTMLUIProps,\n  ThemeProps,\n  ColorModeToken,\n  CSS,\n} from \"@yamada-ui/core\"\nimport {\n  ui,\n  forwardRef,\n  useMultiComponentStyle,\n  omitThemeProps,\n} from \"@yamada-ui/core\"\nimport type { FormControlOptions } from \"@yamada-ui/form-control\"\nimport {\n  formControlProperties,\n  useFormControlProps,\n} from \"@yamada-ui/form-control\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { createDescendant } from \"@yamada-ui/use-descendant\"\nimport {\n  createContext,\n  cx,\n  handlerAll,\n  mergeRefs,\n  pickObject,\n  filterUndefined,\n  getValidChildren,\n} from \"@yamada-ui/utils\"\nimport type { ChangeEvent, KeyboardEvent, Ref } from \"react\"\nimport { useCallback, useEffect, useId, useMemo, useState } from \"react\"\n\nconst toArray = (value?: string) => value?.split(\"\")\n\nconst validate = (value: string, type: PinInputProps[\"type\"]) => {\n  const NUMERIC_REGEX = /^[0-9]+$/\n  const ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i\n\n  const regex = type === \"alphanumeric\" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX\n\n  return regex.test(value)\n}\n\ntype PinInputContext = {\n  getInputProps: (\n    props: PinInputFieldProps & {\n      index: number\n      ref?: Ref<HTMLInputElement>\n    },\n  ) => PinInputFieldProps\n  styles: Record<string, CSSUIObject>\n}\n\nconst [PinInputProvider, usePinInputContext] = createContext<PinInputContext>({\n  strict: false,\n  name: \"PinInputContext\",\n})\n\nconst { DescendantsContextProvider, useDescendants, useDescendant } =\n  createDescendant<HTMLInputElement>()\n\ntype PinInputOptions = {\n  /**\n   * The top-level id string that will be applied to the input fields.\n   * The index of the input will be appended to this top-level id.\n   */\n  id?: string\n  /**\n   * The type of values the pin-input should allow.\n   *\n   * @default 'number'\n   */\n  type?: \"alphanumeric\" | \"number\"\n  /**\n   * The placeholder for the pin input.\n   *\n   * @default '○'\n   */\n  placeholder?: string\n  /**\n   * The value of the pin input.\n   */\n  value?: string\n  /**\n   * The initial value of the pin input.\n   */\n  defaultValue?: string\n  /**\n   * If `true`, the pin input receives focus on mount.\n   *\n   * @default false\n   */\n  autoFocus?: boolean\n  /**\n   * If `true`, focus will move automatically to the next input once filled.\n   *\n   * @default true\n   */\n  manageFocus?: boolean\n  /**\n   * If `true`, the pin input component signals to its fields that they should.\n   */\n  otp?: boolean\n  /**\n   * If `true`, the input's value will be masked just like `type=password`.\n   */\n  mask?: boolean\n  /**\n   * Function called on input change.\n   */\n  onChange?: (value: string) => void\n  /**\n   * Function called when all inputs have valid values.\n   */\n  onComplete?: (value: string) => void\n  /**\n   * The number of inputs to display.\n   *\n   * @default 4\n   */\n  items?: number\n  /**\n   * The border color when the input is focused.\n   */\n  focusBorderColor?: ColorModeToken<CSS.Property.BorderColor, \"colors\">\n  /**\n   * The border color when the input is invalid.\n   */\n  errorBorderColor?: ColorModeToken<CSS.Property.BorderColor, \"colors\">\n}\n\nexport type PinInputProps = Omit<HTMLUIProps<\"div\">, \"onChange\" | \"mask\"> &\n  ThemeProps<\"PinInput\"> &\n  FormControlOptions &\n  PinInputOptions\n\n/**\n * `PinInput` is a component used to capture pin codes or OTP (One-Time Password) inputs.\n *\n * @see Docs https://yamada-ui.com/components/forms/pin-input\n */\nexport const PinInput = forwardRef<PinInputProps, \"div\">(\n  ({ focusBorderColor, errorBorderColor, ...props }, ref) => {\n    const [styles, mergedProps] = useMultiComponentStyle(\"PinInput\", {\n      focusBorderColor,\n      errorBorderColor,\n      ...props,\n    })\n    let {\n      id,\n      className,\n      type = \"number\",\n      placeholder = \"○\",\n      value,\n      defaultValue,\n      autoFocus,\n      manageFocus = true,\n      otp = false,\n      mask,\n      readOnly,\n      \"aria-readonly\": ariaReadonly,\n      onChange: onChangeProp,\n      onComplete,\n      items = 4,\n      children,\n      ...rest\n    } = useFormControlProps(omitThemeProps(mergedProps))\n    const formControlProps = useMemo(\n      () => ({\n        ...pickObject(rest, formControlProperties),\n        readOnly,\n        \"aria-readonly\": ariaReadonly,\n      }),\n      [ariaReadonly, readOnly, rest],\n    )\n\n    id ??= useId()\n\n    const descendants = useDescendants()\n\n    const [moveFocus, setMoveFocus] = useState<boolean>(true)\n    const [focusedIndex, setFocusedIndex] = useState<number>(-1)\n\n    useEffect(() => {\n      if (!autoFocus) return\n\n      const firstValue = descendants.firstValue()\n\n      if (!firstValue) return\n\n      requestAnimationFrame(() => firstValue.node.focus())\n    }, [autoFocus, descendants])\n\n    const [values, setValues] = useControllableState<string[]>({\n      value: toArray(value),\n      defaultValue: toArray(defaultValue) || [],\n      onChange: (values) => onChangeProp?.(values.join(\"\")),\n    })\n\n    const focusNext = useCallback(\n      (index: number) => {\n        if (!moveFocus || !manageFocus) return\n\n        const next = descendants.nextValue(index, undefined, false)\n\n        if (!next) return\n\n        requestAnimationFrame(() => next.node.focus())\n      },\n      [descendants, moveFocus, manageFocus],\n    )\n\n    const setValue = useCallback(\n      (value: string, index: number, isFocus: boolean = true) => {\n        let nextValues = [...values]\n\n        nextValues[index] = value\n\n        setValues(nextValues)\n\n        nextValues = nextValues.filter(Boolean)\n\n        const isComplete =\n          value !== \"\" &&\n          nextValues.length === descendants.count() &&\n          nextValues.every((value) => value != null && value !== \"\")\n\n        if (isComplete) {\n          onComplete?.(nextValues.join(\"\"))\n          descendants.value(index)?.node.blur()\n        } else if (isFocus) {\n          focusNext(index)\n        }\n      },\n      [values, setValues, descendants, onComplete, focusNext],\n    )\n\n    const getNextValue = useCallback(\n      (value: string | undefined, eventValue: string) => {\n        let nextValue = eventValue\n\n        if (!value?.length) return nextValue\n\n        if (value[0] === eventValue.charAt(0)) {\n          nextValue = eventValue.charAt(1)\n        } else if (value[0] === eventValue.charAt(1)) {\n          nextValue = eventValue.charAt(0)\n        }\n\n        return nextValue\n      },\n      [],\n    )\n\n    const onChange = useCallback(\n      (index: number) =>\n        ({ target }: ChangeEvent<HTMLInputElement>) => {\n          const eventValue = target.value\n          const currentValue = values[index]\n          const nextValue = getNextValue(currentValue, eventValue)\n\n          if (nextValue === \"\") {\n            setValue(\"\", index)\n\n            return\n          }\n\n          if (eventValue.length > 2) {\n            if (!validate(eventValue, type)) return\n\n            const nextValue = eventValue\n              .split(\"\")\n              .filter((_, index) => index < descendants.count())\n\n            setValues(nextValue)\n\n            if (nextValue.length === descendants.count()) {\n              onComplete?.(nextValue.join(\"\"))\n              descendants.value(index)?.node.blur()\n            }\n          } else {\n            if (validate(nextValue, type)) setValue(nextValue, index)\n\n            setMoveFocus(true)\n          }\n        },\n      [\n        descendants,\n        getNextValue,\n        onComplete,\n        setValue,\n        setValues,\n        type,\n        values,\n      ],\n    )\n\n    const onKeyDown = useCallback(\n      (index: number) =>\n        ({ key, target }: KeyboardEvent<HTMLInputElement>) => {\n          if (key !== \"Backspace\" || !manageFocus) return\n\n          if ((target as HTMLInputElement).value === \"\") {\n            const prevInput = descendants.prevValue(index, undefined, false)\n\n            if (!prevInput) return\n\n            setValue(\"\", index - 1, false)\n            prevInput.node?.focus()\n            setMoveFocus(true)\n          } else {\n            setMoveFocus(false)\n          }\n        },\n      [descendants, manageFocus, setValue],\n    )\n\n    const onFocus = useCallback(\n      (index: number) => () => setFocusedIndex(index),\n      [],\n    )\n\n    const onBlur = useCallback(() => setFocusedIndex(-1), [])\n\n    const getInputProps = useCallback(\n      ({\n        index,\n        ...props\n      }: PinInputFieldProps & {\n        index: number\n        ref?: Ref<HTMLInputElement>\n      }): PinInputFieldProps => ({\n        inputMode: type === \"number\" ? \"numeric\" : \"text\",\n        type: mask ? \"password\" : type === \"number\" ? \"tel\" : \"text\",\n        ...formControlProps,\n        ...filterUndefined(props),\n        id: `${id}-${index}`,\n        value: values[index] || \"\",\n        onChange: handlerAll(props.onChange, onChange(index)),\n        onKeyDown: handlerAll(props.onKeyDown, onKeyDown(index)),\n        onFocus: handlerAll(props.onFocus, onFocus(index)),\n        onBlur: handlerAll(props.onBlur, onBlur),\n        autoComplete: otp ? \"one-time-code\" : \"off\",\n        placeholder:\n          focusedIndex === index && !readOnly && !props.readOnly\n            ? \"\"\n            : placeholder,\n      }),\n      [\n        type,\n        mask,\n        formControlProps,\n        id,\n        values,\n        onChange,\n        onKeyDown,\n        onFocus,\n        onBlur,\n        otp,\n        focusedIndex,\n        readOnly,\n        placeholder,\n      ],\n    )\n\n    const css: CSSUIObject = {\n      display: \"flex\",\n      alignItems: \"center\",\n      ...styles.container,\n    }\n\n    let cloneChildren = getValidChildren(children)\n\n    if (!cloneChildren.length)\n      for (let i = 0; i < items; i++) {\n        cloneChildren.push(<PinInputField key={i} />)\n      }\n\n    return (\n      <DescendantsContextProvider value={descendants}>\n        <PinInputProvider value={{ getInputProps, styles }}>\n          <ui.div\n            ref={ref}\n            className={cx(\"ui-pin-input\", className)}\n            __css={css}\n            {...rest}\n          >\n            {cloneChildren}\n          </ui.div>\n        </PinInputProvider>\n      </DescendantsContextProvider>\n    )\n  },\n)\n\nexport type PinInputFieldProps = HTMLUIProps<\"input\"> & FormControlOptions\n\nexport const PinInputField = forwardRef<PinInputFieldProps, \"input\">(\n  ({ className, ...rest }, ref) => {\n    const { getInputProps, styles } = usePinInputContext()\n    const { index, register } = useDescendant()\n\n    rest = useFormControlProps(rest)\n\n    const css: CSSUIObject = { ...styles.field }\n\n    return (\n      <ui.input\n        className={cx(\"ui-pin-input__field\", className)}\n        {...getInputProps({ ...rest, ref: mergeRefs(register, ref), index })}\n        __css={css}\n      />\n    )\n  },\n)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}