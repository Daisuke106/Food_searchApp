{"ast":null,"code":"\"use client\";\n\n// src/segmented-control.tsx\nimport { ui, forwardRef, useMultiComponentStyle, omitThemeProps } from \"@yamada-ui/core\";\nimport { LayoutGroup, Motion } from \"@yamada-ui/motion\";\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\";\nimport { createDescendant } from \"@yamada-ui/use-descendant\";\nimport { trackFocusVisible } from \"@yamada-ui/use-focus-visible\";\nimport { ariaAttr, createContext, cx, dataAttr, getValidChildren, handlerAll, mergeRefs, useCallbackRef, useIsMounted } from \"@yamada-ui/utils\";\nimport { useCallback, useEffect, useId, useRef, useState } from \"react\";\nimport { jsx, jsxs } from \"react/jsx-runtime\";\nvar {\n  DescendantsContextProvider,\n  useDescendants,\n  useDescendant\n} = createDescendant();\nvar [SegmentedControlProvider, useSegmentedControl] = createContext({\n  strict: false,\n  name: \"SegmentedControlContext\"\n});\nvar SegmentedControl = forwardRef((props, ref) => {\n  const [styles, mergedProps] = useMultiComponentStyle(\"SegmentedControl\", props);\n  let {\n    className,\n    id,\n    name,\n    isReadOnly,\n    isDisabled,\n    children,\n    items = [],\n    value,\n    defaultValue,\n    onChange: onChangeProp,\n    ...rest\n  } = omitThemeProps(mergedProps);\n  id != null ? id : id = useId();\n  name != null ? name : name = `segmented-control-${useId()}`;\n  const onChangeRef = useCallbackRef(onChangeProp);\n  const descendants = useDescendants();\n  const [focusedIndex, setFocusedIndex] = useState(-1);\n  const [isFocusVisible, setIsFocusVisible] = useState(false);\n  const containerRef = useRef(null);\n  const [selectedValue, setSelectedValue] = useControllableState({\n    value,\n    defaultValue,\n    onChange: onChangeRef\n  });\n  const onChange = useCallback(ev => {\n    if (isDisabled || isReadOnly) {\n      ev.preventDefault();\n      return;\n    }\n    setSelectedValue(ev.target.value);\n  }, [isDisabled, isReadOnly, setSelectedValue]);\n  const onFocus = useCallback((index, skip) => {\n    if (isDisabled) return;\n    if (skip) {\n      const next = descendants.enabledNextValue(index);\n      if (next) setFocusedIndex(next.index);\n    } else {\n      setFocusedIndex(index);\n    }\n  }, [descendants, isDisabled]);\n  const onBlur = useCallback(() => setFocusedIndex(-1), []);\n  const getContainerProps = useCallback((props2 = {}, ref2 = null) => ({\n    ...rest,\n    ...props2,\n    ref: mergeRefs(containerRef, ref2),\n    id,\n    \"aria-disabled\": ariaAttr(isDisabled),\n    \"data-readonly\": dataAttr(isReadOnly),\n    onBlur: handlerAll(props2.onBlur, onBlur)\n  }), [id, isDisabled, isReadOnly, onBlur, rest]);\n  const getInputProps = useCallback(({\n    index,\n    isDisabled: isDisabledProp,\n    isReadOnly: isReadOnlyProp,\n    ...props2\n  }, ref2 = null) => {\n    var _a, _b, _c, _d;\n    const disabled = (_b = (_a = props2.disabled) != null ? _a : isDisabledProp) != null ? _b : isDisabled;\n    const readOnly = (_d = (_c = props2.readOnly) != null ? _c : isReadOnlyProp) != null ? _d : isReadOnly;\n    const checked = props2.value === selectedValue;\n    return {\n      ...props2,\n      ref: ref2,\n      id: `${id}-${index}`,\n      type: \"radio\",\n      name,\n      disabled: disabled || readOnly,\n      readOnly,\n      checked,\n      \"aria-disabled\": ariaAttr(disabled),\n      \"data-readonly\": dataAttr(readOnly),\n      \"data-checked\": dataAttr(checked),\n      \"data-focus\": dataAttr(index === focusedIndex),\n      style: {\n        border: \"0px\",\n        clip: \"rect(0px, 0px, 0px, 0px)\",\n        height: \"1px\",\n        width: \"1px\",\n        margin: \"-1px\",\n        padding: \"0px\",\n        overflow: \"hidden\",\n        whiteSpace: \"nowrap\",\n        position: \"absolute\"\n      },\n      onChange: handlerAll(props2.onChange, ev => !disabled && !readOnly ? onChange(ev) : {})\n    };\n  }, [isDisabled, isReadOnly, selectedValue, id, name, focusedIndex, onChange]);\n  const getLabelProps = useCallback(({\n    index,\n    isDisabled: isDisabledProp,\n    isReadOnly: isReadOnlyProp,\n    ...props2\n  }, ref2 = null) => {\n    var _a, _b, _c, _d;\n    const disabled = (_b = (_a = props2.disabled) != null ? _a : isDisabledProp) != null ? _b : isDisabled;\n    const readOnly = (_d = (_c = props2.readOnly) != null ? _c : isReadOnlyProp) != null ? _d : isReadOnly;\n    const checked = props2.value === selectedValue;\n    const focused = index === focusedIndex;\n    return {\n      ...props2,\n      ref: ref2,\n      \"aria-disabled\": ariaAttr(disabled),\n      \"data-readonly\": dataAttr(readOnly),\n      \"data-checked\": dataAttr(checked),\n      \"data-focus\": dataAttr(focused),\n      \"data-focus-visible\": dataAttr(focused && isFocusVisible),\n      onFocus: handlerAll(props2.onFocus, () => onFocus(index, disabled || readOnly || false)),\n      ...(disabled || readOnly ? {\n        _hover: {},\n        _active: {},\n        _focus: {},\n        _invalid: {},\n        _focusVisible: {}\n      } : {})\n    };\n  }, [focusedIndex, isDisabled, isFocusVisible, isReadOnly, onFocus, selectedValue]);\n  useEffect(() => {\n    return trackFocusVisible(setIsFocusVisible);\n  }, []);\n  const css = {\n    display: \"inline-flex\",\n    alignItems: \"center\",\n    ...styles.container\n  };\n  const validChildren = getValidChildren(children);\n  let computedChildren = [];\n  if (!validChildren.length && items.length) {\n    computedChildren = items.map(({\n      label,\n      value: value2,\n      ...props2\n    }, i) => /* @__PURE__ */jsx(SegmentedControlButton, {\n      value: value2,\n      ...props2,\n      children: label\n    }, i));\n  } else {\n    computedChildren = validChildren;\n  }\n  if (selectedValue == null && defaultValue == null) {\n    for (const child of computedChildren) {\n      if (child.type !== SegmentedControlButton) {\n        if (child.type.displayName !== SegmentedControlButton.displayName) continue;\n      }\n      const value2 = child.props.value;\n      setSelectedValue(value2);\n      break;\n    }\n  }\n  return /* @__PURE__ */jsx(DescendantsContextProvider, {\n    value: descendants,\n    children: /* @__PURE__ */jsx(SegmentedControlProvider, {\n      value: {\n        getInputProps,\n        getLabelProps,\n        styles,\n        selectedValue\n      },\n      children: /* @__PURE__ */jsx(LayoutGroup, {\n        id,\n        children: /* @__PURE__ */jsx(ui.div, {\n          ...getContainerProps({}, ref),\n          className: cx(\"ui-segmented-control\", className),\n          __css: css,\n          children: computedChildren\n        })\n      })\n    })\n  });\n});\nvar SegmentedControlButton = forwardRef(({\n  className,\n  disabled,\n  readOnly,\n  isDisabled,\n  isReadOnly,\n  value,\n  onChange,\n  children,\n  motionProps,\n  ...rest\n}, ref) => {\n  const [, isMounted] = useIsMounted({\n    rerender: true\n  });\n  const {\n    selectedValue,\n    getInputProps,\n    getLabelProps,\n    styles\n  } = useSegmentedControl();\n  const {\n    index,\n    register\n  } = useDescendant({\n    disabled: isDisabled || isReadOnly\n  });\n  const props = {\n    index,\n    value,\n    disabled,\n    readOnly,\n    isDisabled,\n    isReadOnly\n  };\n  const css = {\n    position: \"relative\",\n    cursor: \"pointer\",\n    flex: \"1 1 0%\",\n    display: \"inline-flex\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    ...styles.button\n  };\n  const isSelected = selectedValue === value;\n  return /* @__PURE__ */jsxs(ui.label, {\n    ...getLabelProps(props),\n    className: cx(\"ui-segmented-control__button\", className),\n    __css: css,\n    ...rest,\n    children: [/* @__PURE__ */jsx(ui.input, {\n      ...getInputProps({\n        onChange,\n        ...props\n      }, mergeRefs(register, ref))\n    }), isSelected && isMounted ? /* @__PURE__ */jsx(SegmentedControlCursor, {\n      ...motionProps\n    }) : null, /* @__PURE__ */jsx(ui.span, {\n      zIndex: \"1\",\n      children\n    })]\n  });\n});\nSegmentedControlButton.displayName = \"SegmentedControlButton\";\nvar SegmentedControlCursor = ({\n  className,\n  transition,\n  ...rest\n}) => {\n  const {\n    styles\n  } = useSegmentedControl();\n  const css = {\n    position: \"absolute\",\n    w: \"100%\",\n    h: \"100%\",\n    ...styles.cursor\n  };\n  return /* @__PURE__ */jsx(Motion, {\n    className: cx(\"ui-segmented-control__cursor\", className),\n    layoutDependency: false,\n    layoutId: \"cursor\",\n    transition: {\n      type: \"spring\",\n      bounce: 0.15,\n      duration: 0.4,\n      ...transition\n    },\n    __css: css,\n    ...rest\n  });\n};\nexport { SegmentedControl, SegmentedControlButton };","map":{"version":3,"names":["ui","forwardRef","useMultiComponentStyle","omitThemeProps","LayoutGroup","Motion","useControllableState","createDescendant","trackFocusVisible","ariaAttr","createContext","cx","dataAttr","getValidChildren","handlerAll","mergeRefs","useCallbackRef","useIsMounted","useCallback","useEffect","useId","useRef","useState","jsx","jsxs","DescendantsContextProvider","useDescendants","useDescendant","SegmentedControlProvider","useSegmentedControl","strict","name","SegmentedControl","props","ref","styles","mergedProps","className","id","isReadOnly","isDisabled","children","items","value","defaultValue","onChange","onChangeProp","rest","onChangeRef","descendants","focusedIndex","setFocusedIndex","isFocusVisible","setIsFocusVisible","containerRef","selectedValue","setSelectedValue","ev","preventDefault","target","onFocus","index","skip","next","enabledNextValue","onBlur","getContainerProps","props2","ref2","getInputProps","isDisabledProp","isReadOnlyProp","_a","_b","_c","_d","disabled","readOnly","checked","type","style","border","clip","height","width","margin","padding","overflow","whiteSpace","position","getLabelProps","focused","_hover","_active","_focus","_invalid","_focusVisible","css","display","alignItems","container","validChildren","computedChildren","length","map","label","value2","i","SegmentedControlButton","child","displayName","div","__css","motionProps","isMounted","rerender","register","cursor","flex","justifyContent","button","isSelected","input","SegmentedControlCursor","span","zIndex","transition","w","h","layoutDependency","layoutId","bounce","duration"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\segmented-control\\src\\segmented-control.tsx"],"sourcesContent":["import type {\n  CSSUIObject,\n  HTMLUIProps,\n  ThemeProps,\n  UIPropGetter,\n  RequiredUIPropGetter,\n} from \"@yamada-ui/core\"\nimport {\n  ui,\n  forwardRef,\n  useMultiComponentStyle,\n  omitThemeProps,\n} from \"@yamada-ui/core\"\nimport type { MotionProps } from \"@yamada-ui/motion\"\nimport { LayoutGroup, Motion } from \"@yamada-ui/motion\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { createDescendant } from \"@yamada-ui/use-descendant\"\nimport { trackFocusVisible } from \"@yamada-ui/use-focus-visible\"\nimport {\n  ariaAttr,\n  createContext,\n  cx,\n  dataAttr,\n  getValidChildren,\n  handlerAll,\n  mergeRefs,\n  useCallbackRef,\n  useIsMounted,\n} from \"@yamada-ui/utils\"\nimport type {\n  ChangeEvent,\n  ChangeEventHandler,\n  FC,\n  FocusEventHandler,\n  ReactElement,\n} from \"react\"\nimport { useCallback, useEffect, useId, useRef, useState } from \"react\"\n\nexport type SegmentedControlItem = SegmentedControlButtonProps & {\n  label?: string\n}\n\nconst { DescendantsContextProvider, useDescendants, useDescendant } =\n  createDescendant<HTMLButtonElement>()\n\ntype SegmentedControlContext = {\n  selectedValue: string\n  getInputProps: RequiredUIPropGetter<\n    \"input\",\n    { index: number; isDisabled?: boolean; isReadOnly?: boolean }\n  >\n  getLabelProps: RequiredUIPropGetter<\n    \"label\",\n    {\n      value: string\n      index: number\n      isDisabled?: boolean\n      isReadOnly?: boolean\n      disabled?: boolean\n      readOnly?: boolean\n    }\n  >\n  styles: Record<string, CSSUIObject>\n}\n\nconst [SegmentedControlProvider, useSegmentedControl] =\n  createContext<SegmentedControlContext>({\n    strict: false,\n    name: \"SegmentedControlContext\",\n  })\n\ntype SegmentedControlOptions = {\n  /**\n   * The HTML `name` attribute used for forms.\n   */\n  name?: string\n  /**\n   * The value of the segmented control.\n   */\n  value?: string\n  /**\n   * The initial value of the segmented control.\n   */\n  defaultValue?: string\n  /**\n   * The callback fired when any children radio is checked or unchecked.\n   */\n  onChange?: (value: string) => void\n  /**\n   * If `true`, the segmented control will be readonly.\n   *\n   * @default false\n   */\n  isReadOnly?: boolean\n  /**\n   * If `true`, the segmented control will be disabled.\n   *\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If provided, generate segmented control buttons but based on items.\n   *\n   * @default '[]'\n   */\n  items?: SegmentedControlItem[]\n}\n\nexport type SegmentedControlProps = Omit<\n  HTMLUIProps<\"div\">,\n  \"value\" | \"defaultValue\" | \"onChange\"\n> &\n  ThemeProps<\"SegmentedControl\"> &\n  SegmentedControlOptions\n\n/**\n * `SegmentedControl` is a component used for allowing users to select one option from multiple choices.\n *\n * @see Docs https://yamada-ui.com/components/forms/segmented-control\n */\nexport const SegmentedControl = forwardRef<SegmentedControlProps, \"div\">(\n  (props, ref) => {\n    const [styles, mergedProps] = useMultiComponentStyle(\n      \"SegmentedControl\",\n      props,\n    )\n    let {\n      className,\n      id,\n      name,\n      isReadOnly,\n      isDisabled,\n      children,\n      items = [],\n      value,\n      defaultValue,\n      onChange: onChangeProp,\n      ...rest\n    } = omitThemeProps(mergedProps)\n\n    id ??= useId()\n    name ??= `segmented-control-${useId()}`\n\n    const onChangeRef = useCallbackRef(onChangeProp)\n\n    const descendants = useDescendants()\n\n    const [focusedIndex, setFocusedIndex] = useState<number>(-1)\n    const [isFocusVisible, setIsFocusVisible] = useState<boolean>(false)\n    const containerRef = useRef<HTMLDivElement>(null)\n\n    const [selectedValue, setSelectedValue] = useControllableState({\n      value,\n      defaultValue,\n      onChange: onChangeRef,\n    })\n\n    const onChange = useCallback(\n      (ev: ChangeEvent<HTMLInputElement>) => {\n        if (isDisabled || isReadOnly) {\n          ev.preventDefault()\n\n          return\n        }\n\n        setSelectedValue(ev.target.value)\n      },\n      [isDisabled, isReadOnly, setSelectedValue],\n    )\n\n    const onFocus = useCallback(\n      (index: number, skip: boolean) => {\n        if (isDisabled) return\n\n        if (skip) {\n          const next = descendants.enabledNextValue(index)\n\n          if (next) setFocusedIndex(next.index)\n        } else {\n          setFocusedIndex(index)\n        }\n      },\n      [descendants, isDisabled],\n    )\n\n    const onBlur = useCallback(() => setFocusedIndex(-1), [])\n\n    const getContainerProps: UIPropGetter = useCallback(\n      (props = {}, ref = null) => ({\n        ...rest,\n        ...props,\n        ref: mergeRefs(containerRef, ref),\n        id,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"data-readonly\": dataAttr(isReadOnly),\n        onBlur: handlerAll(props.onBlur, onBlur),\n      }),\n      [id, isDisabled, isReadOnly, onBlur, rest],\n    )\n\n    const getInputProps: RequiredUIPropGetter<\n      \"input\",\n      { isDisabled?: boolean; isReadOnly?: boolean; index: number }\n    > = useCallback(\n      (\n        {\n          index,\n          isDisabled: isDisabledProp,\n          isReadOnly: isReadOnlyProp,\n          ...props\n        },\n        ref = null,\n      ) => {\n        const disabled = props.disabled ?? isDisabledProp ?? isDisabled\n        const readOnly = props.readOnly ?? isReadOnlyProp ?? isReadOnly\n        const checked = props.value === selectedValue\n\n        return {\n          ...props,\n          ref,\n          id: `${id}-${index}`,\n          type: \"radio\",\n          name,\n          disabled: disabled || readOnly,\n          readOnly,\n          checked,\n          \"aria-disabled\": ariaAttr(disabled),\n          \"data-readonly\": dataAttr(readOnly),\n          \"data-checked\": dataAttr(checked),\n          \"data-focus\": dataAttr(index === focusedIndex),\n          style: {\n            border: \"0px\",\n            clip: \"rect(0px, 0px, 0px, 0px)\",\n            height: \"1px\",\n            width: \"1px\",\n            margin: \"-1px\",\n            padding: \"0px\",\n            overflow: \"hidden\",\n            whiteSpace: \"nowrap\",\n            position: \"absolute\",\n          },\n          onChange: handlerAll(props.onChange, (ev) =>\n            !disabled && !readOnly\n              ? onChange(ev as ChangeEvent<HTMLInputElement>)\n              : {},\n          ),\n        }\n      },\n      [isDisabled, isReadOnly, selectedValue, id, name, focusedIndex, onChange],\n    )\n\n    const getLabelProps: RequiredUIPropGetter<\n      \"label\",\n      {\n        value: string\n        index: number\n        isDisabled?: boolean\n        isReadOnly?: boolean\n        disabled?: boolean\n        readOnly?: boolean\n      }\n    > = useCallback(\n      (\n        {\n          index,\n          isDisabled: isDisabledProp,\n          isReadOnly: isReadOnlyProp,\n          ...props\n        },\n        ref = null,\n      ) => {\n        const disabled = props.disabled ?? isDisabledProp ?? isDisabled\n        const readOnly = props.readOnly ?? isReadOnlyProp ?? isReadOnly\n        const checked = props.value === selectedValue\n        const focused = index === focusedIndex\n\n        return {\n          ...props,\n          ref,\n          \"aria-disabled\": ariaAttr(disabled),\n          \"data-readonly\": dataAttr(readOnly),\n          \"data-checked\": dataAttr(checked),\n          \"data-focus\": dataAttr(focused),\n          \"data-focus-visible\": dataAttr(focused && isFocusVisible),\n          onFocus: handlerAll(\n            props.onFocus as unknown as FocusEventHandler<HTMLLabelElement>,\n            () => onFocus(index, disabled || readOnly || false),\n          ),\n          ...(disabled || readOnly\n            ? {\n                _hover: {},\n                _active: {},\n                _focus: {},\n                _invalid: {},\n                _focusVisible: {},\n              }\n            : {}),\n        }\n      },\n      [\n        focusedIndex,\n        isDisabled,\n        isFocusVisible,\n        isReadOnly,\n        onFocus,\n        selectedValue,\n      ],\n    )\n\n    useEffect(() => {\n      return trackFocusVisible(setIsFocusVisible)\n    }, [])\n\n    const css: CSSUIObject = {\n      display: \"inline-flex\",\n      alignItems: \"center\",\n      ...styles.container,\n    }\n\n    const validChildren = getValidChildren(children)\n    let computedChildren: ReactElement[] = []\n\n    if (!validChildren.length && items.length) {\n      computedChildren = items.map(({ label, value, ...props }, i) => (\n        <SegmentedControlButton key={i} value={value} {...props}>\n          {label}\n        </SegmentedControlButton>\n      ))\n    } else {\n      computedChildren = validChildren\n    }\n\n    if (selectedValue == null && defaultValue == null) {\n      for (const child of computedChildren) {\n        if (child.type !== SegmentedControlButton)\n          if (\n            (child.type as any).displayName !==\n            SegmentedControlButton.displayName\n          )\n            continue\n\n        const value = child.props.value\n\n        setSelectedValue(value)\n\n        break\n      }\n    }\n\n    return (\n      <DescendantsContextProvider value={descendants}>\n        <SegmentedControlProvider\n          value={{ getInputProps, getLabelProps, styles, selectedValue }}\n        >\n          <LayoutGroup id={id}>\n            <ui.div\n              {...getContainerProps({}, ref)}\n              className={cx(\"ui-segmented-control\", className)}\n              __css={css}\n            >\n              {computedChildren}\n            </ui.div>\n          </LayoutGroup>\n        </SegmentedControlProvider>\n      </DescendantsContextProvider>\n    )\n  },\n)\n\ntype SegmentedControlButtonOptions = {\n  /**\n   * The value of the segmented control button.\n   */\n  value: string\n  /**\n   * The callback fired when any children radio is checked or unchecked.\n   */\n  onChange?: ChangeEventHandler<HTMLInputElement>\n  /**\n   * Props for motion component.\n   */\n  motionProps?: MotionProps\n}\n\nexport type SegmentedControlButtonProps = Omit<\n  HTMLUIProps<\"label\">,\n  \"onChange\"\n> &\n  Pick<SegmentedControlProps, \"isDisabled\" | \"isReadOnly\"> &\n  SegmentedControlButtonOptions\n\nexport const SegmentedControlButton = forwardRef<\n  SegmentedControlButtonProps,\n  \"input\"\n>(\n  (\n    {\n      className,\n      disabled,\n      readOnly,\n      isDisabled,\n      isReadOnly,\n      value,\n      onChange,\n      children,\n      motionProps,\n      ...rest\n    },\n    ref,\n  ) => {\n    const [, isMounted] = useIsMounted({ rerender: true })\n    const { selectedValue, getInputProps, getLabelProps, styles } =\n      useSegmentedControl()\n\n    const { index, register } = useDescendant({\n      disabled: isDisabled || isReadOnly,\n    })\n\n    const props = {\n      index,\n      value,\n      disabled,\n      readOnly,\n      isDisabled,\n      isReadOnly,\n    }\n\n    const css: CSSUIObject = {\n      position: \"relative\",\n      cursor: \"pointer\",\n      flex: \"1 1 0%\",\n      display: \"inline-flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      ...styles.button,\n    }\n\n    const isSelected = selectedValue === value\n\n    return (\n      <ui.label\n        {...getLabelProps(props)}\n        className={cx(\"ui-segmented-control__button\", className)}\n        __css={css}\n        {...rest}\n      >\n        <ui.input\n          {...getInputProps({ onChange, ...props }, mergeRefs(register, ref))}\n        />\n        {isSelected && isMounted ? (\n          <SegmentedControlCursor {...motionProps} />\n        ) : null}\n        <ui.span zIndex=\"1\">{children}</ui.span>\n      </ui.label>\n    )\n  },\n)\n\nSegmentedControlButton.displayName = \"SegmentedControlButton\"\n\ntype SegmentedControlCursorProps = MotionProps & { className?: string }\n\nconst SegmentedControlCursor: FC<SegmentedControlCursorProps> = ({\n  className,\n  transition,\n  ...rest\n}) => {\n  const { styles } = useSegmentedControl()\n\n  const css: CSSUIObject = {\n    position: \"absolute\",\n    w: \"100%\",\n    h: \"100%\",\n    ...styles.cursor,\n  }\n\n  return (\n    <Motion\n      className={cx(\"ui-segmented-control__cursor\", className)}\n      layoutDependency={false}\n      layoutId=\"cursor\"\n      transition={{\n        type: \"spring\",\n        bounce: 0.15,\n        duration: 0.4,\n        ...transition,\n      }}\n      __css={css}\n      {...rest}\n    />\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}