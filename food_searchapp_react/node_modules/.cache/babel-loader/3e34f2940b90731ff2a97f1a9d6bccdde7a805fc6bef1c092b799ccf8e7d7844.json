{"ast":null,"code":"\"use client\";\n\n// src/pin-input.tsx\nimport { ui, forwardRef, useMultiComponentStyle, omitThemeProps } from \"@yamada-ui/core\";\nimport { formControlProperties, useFormControlProps } from \"@yamada-ui/form-control\";\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\";\nimport { createDescendant } from \"@yamada-ui/use-descendant\";\nimport { createContext, cx, handlerAll, mergeRefs, pickObject, filterUndefined, getValidChildren } from \"@yamada-ui/utils\";\nimport { useCallback, useEffect, useId, useMemo, useState } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar toArray = value => value == null ? void 0 : value.split(\"\");\nvar validate = (value, type) => {\n  const NUMERIC_REGEX = /^[0-9]+$/;\n  const ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i;\n  const regex = type === \"alphanumeric\" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX;\n  return regex.test(value);\n};\nvar [PinInputProvider, usePinInputContext] = createContext({\n  strict: false,\n  name: \"PinInputContext\"\n});\nvar {\n  DescendantsContextProvider,\n  useDescendants,\n  useDescendant\n} = createDescendant();\nvar PinInput = forwardRef(({\n  focusBorderColor,\n  errorBorderColor,\n  ...props\n}, ref) => {\n  const [styles, mergedProps] = useMultiComponentStyle(\"PinInput\", {\n    focusBorderColor,\n    errorBorderColor,\n    ...props\n  });\n  let {\n    id,\n    className,\n    type = \"number\",\n    placeholder = \"\\u25CB\",\n    value,\n    defaultValue,\n    autoFocus,\n    manageFocus = true,\n    otp = false,\n    mask,\n    readOnly,\n    \"aria-readonly\": ariaReadonly,\n    onChange: onChangeProp,\n    onComplete,\n    items = 4,\n    children,\n    ...rest\n  } = useFormControlProps(omitThemeProps(mergedProps));\n  const formControlProps = useMemo(() => ({\n    ...pickObject(rest, formControlProperties),\n    readOnly,\n    \"aria-readonly\": ariaReadonly\n  }), [ariaReadonly, readOnly, rest]);\n  id != null ? id : id = useId();\n  const descendants = useDescendants();\n  const [moveFocus, setMoveFocus] = useState(true);\n  const [focusedIndex, setFocusedIndex] = useState(-1);\n  useEffect(() => {\n    if (!autoFocus) return;\n    const firstValue = descendants.firstValue();\n    if (!firstValue) return;\n    requestAnimationFrame(() => firstValue.node.focus());\n  }, [autoFocus, descendants]);\n  const [values, setValues] = useControllableState({\n    value: toArray(value),\n    defaultValue: toArray(defaultValue) || [],\n    onChange: values2 => onChangeProp == null ? void 0 : onChangeProp(values2.join(\"\"))\n  });\n  const focusNext = useCallback(index => {\n    if (!moveFocus || !manageFocus) return;\n    const next = descendants.nextValue(index, void 0, false);\n    if (!next) return;\n    requestAnimationFrame(() => next.node.focus());\n  }, [descendants, moveFocus, manageFocus]);\n  const setValue = useCallback((value2, index, isFocus = true) => {\n    var _a;\n    let nextValues = [...values];\n    nextValues[index] = value2;\n    setValues(nextValues);\n    nextValues = nextValues.filter(Boolean);\n    const isComplete = value2 !== \"\" && nextValues.length === descendants.count() && nextValues.every(value3 => value3 != null && value3 !== \"\");\n    if (isComplete) {\n      onComplete == null ? void 0 : onComplete(nextValues.join(\"\"));\n      (_a = descendants.value(index)) == null ? void 0 : _a.node.blur();\n    } else if (isFocus) {\n      focusNext(index);\n    }\n  }, [values, setValues, descendants, onComplete, focusNext]);\n  const getNextValue = useCallback((value2, eventValue) => {\n    let nextValue = eventValue;\n    if (!(value2 == null ? void 0 : value2.length)) return nextValue;\n    if (value2[0] === eventValue.charAt(0)) {\n      nextValue = eventValue.charAt(1);\n    } else if (value2[0] === eventValue.charAt(1)) {\n      nextValue = eventValue.charAt(0);\n    }\n    return nextValue;\n  }, []);\n  const onChange = useCallback(index => ({\n    target\n  }) => {\n    var _a;\n    const eventValue = target.value;\n    const currentValue = values[index];\n    const nextValue = getNextValue(currentValue, eventValue);\n    if (nextValue === \"\") {\n      setValue(\"\", index);\n      return;\n    }\n    if (eventValue.length > 2) {\n      if (!validate(eventValue, type)) return;\n      const nextValue2 = eventValue.split(\"\").filter((_, index2) => index2 < descendants.count());\n      setValues(nextValue2);\n      if (nextValue2.length === descendants.count()) {\n        onComplete == null ? void 0 : onComplete(nextValue2.join(\"\"));\n        (_a = descendants.value(index)) == null ? void 0 : _a.node.blur();\n      }\n    } else {\n      if (validate(nextValue, type)) setValue(nextValue, index);\n      setMoveFocus(true);\n    }\n  }, [descendants, getNextValue, onComplete, setValue, setValues, type, values]);\n  const onKeyDown = useCallback(index => ({\n    key,\n    target\n  }) => {\n    var _a;\n    if (key !== \"Backspace\" || !manageFocus) return;\n    if (target.value === \"\") {\n      const prevInput = descendants.prevValue(index, void 0, false);\n      if (!prevInput) return;\n      setValue(\"\", index - 1, false);\n      (_a = prevInput.node) == null ? void 0 : _a.focus();\n      setMoveFocus(true);\n    } else {\n      setMoveFocus(false);\n    }\n  }, [descendants, manageFocus, setValue]);\n  const onFocus = useCallback(index => () => setFocusedIndex(index), []);\n  const onBlur = useCallback(() => setFocusedIndex(-1), []);\n  const getInputProps = useCallback(({\n    index,\n    ...props2\n  }) => ({\n    inputMode: type === \"number\" ? \"numeric\" : \"text\",\n    type: mask ? \"password\" : type === \"number\" ? \"tel\" : \"text\",\n    ...formControlProps,\n    ...filterUndefined(props2),\n    id: `${id}-${index}`,\n    value: values[index] || \"\",\n    onChange: handlerAll(props2.onChange, onChange(index)),\n    onKeyDown: handlerAll(props2.onKeyDown, onKeyDown(index)),\n    onFocus: handlerAll(props2.onFocus, onFocus(index)),\n    onBlur: handlerAll(props2.onBlur, onBlur),\n    autoComplete: otp ? \"one-time-code\" : \"off\",\n    placeholder: focusedIndex === index && !readOnly && !props2.readOnly ? \"\" : placeholder\n  }), [type, mask, formControlProps, id, values, onChange, onKeyDown, onFocus, onBlur, otp, focusedIndex, readOnly, placeholder]);\n  const css = {\n    display: \"flex\",\n    alignItems: \"center\",\n    ...styles.container\n  };\n  let cloneChildren = getValidChildren(children);\n  if (!cloneChildren.length) for (let i = 0; i < items; i++) {\n    cloneChildren.push( /* @__PURE__ */jsx(PinInputField, {}, i));\n  }\n  return /* @__PURE__ */jsx(DescendantsContextProvider, {\n    value: descendants,\n    children: /* @__PURE__ */jsx(PinInputProvider, {\n      value: {\n        getInputProps,\n        styles\n      },\n      children: /* @__PURE__ */jsx(ui.div, {\n        ref,\n        className: cx(\"ui-pin-input\", className),\n        __css: css,\n        ...rest,\n        children: cloneChildren\n      })\n    })\n  });\n});\nvar PinInputField = forwardRef(({\n  className,\n  ...rest\n}, ref) => {\n  const {\n    getInputProps,\n    styles\n  } = usePinInputContext();\n  const {\n    index,\n    register\n  } = useDescendant();\n  rest = useFormControlProps(rest);\n  const css = {\n    ...styles.field\n  };\n  return /* @__PURE__ */jsx(ui.input, {\n    className: cx(\"ui-pin-input__field\", className),\n    ...getInputProps({\n      ...rest,\n      ref: mergeRefs(register, ref),\n      index\n    }),\n    __css: css\n  });\n});\nexport { PinInput, PinInputField };","map":{"version":3,"names":["ui","forwardRef","useMultiComponentStyle","omitThemeProps","formControlProperties","useFormControlProps","useControllableState","createDescendant","createContext","cx","handlerAll","mergeRefs","pickObject","filterUndefined","getValidChildren","useCallback","useEffect","useId","useMemo","useState","jsx","toArray","value","split","validate","type","NUMERIC_REGEX","ALPHA_NUMERIC_REGEX","regex","test","PinInputProvider","usePinInputContext","strict","name","DescendantsContextProvider","useDescendants","useDescendant","PinInput","focusBorderColor","errorBorderColor","props","ref","styles","mergedProps","id","className","placeholder","defaultValue","autoFocus","manageFocus","otp","mask","readOnly","ariaReadonly","onChange","onChangeProp","onComplete","items","children","rest","formControlProps","descendants","moveFocus","setMoveFocus","focusedIndex","setFocusedIndex","firstValue","requestAnimationFrame","node","focus","values","setValues","values2","join","focusNext","index","next","nextValue","setValue","value2","isFocus","_a","nextValues","filter","Boolean","isComplete","length","count","every","value3","blur","getNextValue","eventValue","charAt","target","currentValue","nextValue2","_","index2","onKeyDown","key","prevInput","prevValue","onFocus","onBlur","getInputProps","props2","inputMode","autoComplete","css","display","alignItems","container","cloneChildren","i","push","PinInputField","div","__css","register","field","input"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\pin-input\\src\\pin-input.tsx"],"sourcesContent":["import type {\n  CSSUIObject,\n  HTMLUIProps,\n  ThemeProps,\n  ColorModeToken,\n  CSS,\n} from \"@yamada-ui/core\"\nimport {\n  ui,\n  forwardRef,\n  useMultiComponentStyle,\n  omitThemeProps,\n} from \"@yamada-ui/core\"\nimport type { FormControlOptions } from \"@yamada-ui/form-control\"\nimport {\n  formControlProperties,\n  useFormControlProps,\n} from \"@yamada-ui/form-control\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { createDescendant } from \"@yamada-ui/use-descendant\"\nimport {\n  createContext,\n  cx,\n  handlerAll,\n  mergeRefs,\n  pickObject,\n  filterUndefined,\n  getValidChildren,\n} from \"@yamada-ui/utils\"\nimport type { ChangeEvent, KeyboardEvent, Ref } from \"react\"\nimport { useCallback, useEffect, useId, useMemo, useState } from \"react\"\n\nconst toArray = (value?: string) => value?.split(\"\")\n\nconst validate = (value: string, type: PinInputProps[\"type\"]) => {\n  const NUMERIC_REGEX = /^[0-9]+$/\n  const ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i\n\n  const regex = type === \"alphanumeric\" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX\n\n  return regex.test(value)\n}\n\ntype PinInputContext = {\n  getInputProps: (\n    props: PinInputFieldProps & {\n      index: number\n      ref?: Ref<HTMLInputElement>\n    },\n  ) => PinInputFieldProps\n  styles: Record<string, CSSUIObject>\n}\n\nconst [PinInputProvider, usePinInputContext] = createContext<PinInputContext>({\n  strict: false,\n  name: \"PinInputContext\",\n})\n\nconst { DescendantsContextProvider, useDescendants, useDescendant } =\n  createDescendant<HTMLInputElement>()\n\ntype PinInputOptions = {\n  /**\n   * The top-level id string that will be applied to the input fields.\n   * The index of the input will be appended to this top-level id.\n   */\n  id?: string\n  /**\n   * The type of values the pin-input should allow.\n   *\n   * @default 'number'\n   */\n  type?: \"alphanumeric\" | \"number\"\n  /**\n   * The placeholder for the pin input.\n   *\n   * @default '○'\n   */\n  placeholder?: string\n  /**\n   * The value of the pin input.\n   */\n  value?: string\n  /**\n   * The initial value of the pin input.\n   */\n  defaultValue?: string\n  /**\n   * If `true`, the pin input receives focus on mount.\n   *\n   * @default false\n   */\n  autoFocus?: boolean\n  /**\n   * If `true`, focus will move automatically to the next input once filled.\n   *\n   * @default true\n   */\n  manageFocus?: boolean\n  /**\n   * If `true`, the pin input component signals to its fields that they should.\n   */\n  otp?: boolean\n  /**\n   * If `true`, the input's value will be masked just like `type=password`.\n   */\n  mask?: boolean\n  /**\n   * Function called on input change.\n   */\n  onChange?: (value: string) => void\n  /**\n   * Function called when all inputs have valid values.\n   */\n  onComplete?: (value: string) => void\n  /**\n   * The number of inputs to display.\n   *\n   * @default 4\n   */\n  items?: number\n  /**\n   * The border color when the input is focused.\n   */\n  focusBorderColor?: ColorModeToken<CSS.Property.BorderColor, \"colors\">\n  /**\n   * The border color when the input is invalid.\n   */\n  errorBorderColor?: ColorModeToken<CSS.Property.BorderColor, \"colors\">\n}\n\nexport type PinInputProps = Omit<HTMLUIProps<\"div\">, \"onChange\" | \"mask\"> &\n  ThemeProps<\"PinInput\"> &\n  FormControlOptions &\n  PinInputOptions\n\n/**\n * `PinInput` is a component used to capture pin codes or OTP (One-Time Password) inputs.\n *\n * @see Docs https://yamada-ui.com/components/forms/pin-input\n */\nexport const PinInput = forwardRef<PinInputProps, \"div\">(\n  ({ focusBorderColor, errorBorderColor, ...props }, ref) => {\n    const [styles, mergedProps] = useMultiComponentStyle(\"PinInput\", {\n      focusBorderColor,\n      errorBorderColor,\n      ...props,\n    })\n    let {\n      id,\n      className,\n      type = \"number\",\n      placeholder = \"○\",\n      value,\n      defaultValue,\n      autoFocus,\n      manageFocus = true,\n      otp = false,\n      mask,\n      readOnly,\n      \"aria-readonly\": ariaReadonly,\n      onChange: onChangeProp,\n      onComplete,\n      items = 4,\n      children,\n      ...rest\n    } = useFormControlProps(omitThemeProps(mergedProps))\n    const formControlProps = useMemo(\n      () => ({\n        ...pickObject(rest, formControlProperties),\n        readOnly,\n        \"aria-readonly\": ariaReadonly,\n      }),\n      [ariaReadonly, readOnly, rest],\n    )\n\n    id ??= useId()\n\n    const descendants = useDescendants()\n\n    const [moveFocus, setMoveFocus] = useState<boolean>(true)\n    const [focusedIndex, setFocusedIndex] = useState<number>(-1)\n\n    useEffect(() => {\n      if (!autoFocus) return\n\n      const firstValue = descendants.firstValue()\n\n      if (!firstValue) return\n\n      requestAnimationFrame(() => firstValue.node.focus())\n    }, [autoFocus, descendants])\n\n    const [values, setValues] = useControllableState<string[]>({\n      value: toArray(value),\n      defaultValue: toArray(defaultValue) || [],\n      onChange: (values) => onChangeProp?.(values.join(\"\")),\n    })\n\n    const focusNext = useCallback(\n      (index: number) => {\n        if (!moveFocus || !manageFocus) return\n\n        const next = descendants.nextValue(index, undefined, false)\n\n        if (!next) return\n\n        requestAnimationFrame(() => next.node.focus())\n      },\n      [descendants, moveFocus, manageFocus],\n    )\n\n    const setValue = useCallback(\n      (value: string, index: number, isFocus: boolean = true) => {\n        let nextValues = [...values]\n\n        nextValues[index] = value\n\n        setValues(nextValues)\n\n        nextValues = nextValues.filter(Boolean)\n\n        const isComplete =\n          value !== \"\" &&\n          nextValues.length === descendants.count() &&\n          nextValues.every((value) => value != null && value !== \"\")\n\n        if (isComplete) {\n          onComplete?.(nextValues.join(\"\"))\n          descendants.value(index)?.node.blur()\n        } else if (isFocus) {\n          focusNext(index)\n        }\n      },\n      [values, setValues, descendants, onComplete, focusNext],\n    )\n\n    const getNextValue = useCallback(\n      (value: string | undefined, eventValue: string) => {\n        let nextValue = eventValue\n\n        if (!value?.length) return nextValue\n\n        if (value[0] === eventValue.charAt(0)) {\n          nextValue = eventValue.charAt(1)\n        } else if (value[0] === eventValue.charAt(1)) {\n          nextValue = eventValue.charAt(0)\n        }\n\n        return nextValue\n      },\n      [],\n    )\n\n    const onChange = useCallback(\n      (index: number) =>\n        ({ target }: ChangeEvent<HTMLInputElement>) => {\n          const eventValue = target.value\n          const currentValue = values[index]\n          const nextValue = getNextValue(currentValue, eventValue)\n\n          if (nextValue === \"\") {\n            setValue(\"\", index)\n\n            return\n          }\n\n          if (eventValue.length > 2) {\n            if (!validate(eventValue, type)) return\n\n            const nextValue = eventValue\n              .split(\"\")\n              .filter((_, index) => index < descendants.count())\n\n            setValues(nextValue)\n\n            if (nextValue.length === descendants.count()) {\n              onComplete?.(nextValue.join(\"\"))\n              descendants.value(index)?.node.blur()\n            }\n          } else {\n            if (validate(nextValue, type)) setValue(nextValue, index)\n\n            setMoveFocus(true)\n          }\n        },\n      [\n        descendants,\n        getNextValue,\n        onComplete,\n        setValue,\n        setValues,\n        type,\n        values,\n      ],\n    )\n\n    const onKeyDown = useCallback(\n      (index: number) =>\n        ({ key, target }: KeyboardEvent<HTMLInputElement>) => {\n          if (key !== \"Backspace\" || !manageFocus) return\n\n          if ((target as HTMLInputElement).value === \"\") {\n            const prevInput = descendants.prevValue(index, undefined, false)\n\n            if (!prevInput) return\n\n            setValue(\"\", index - 1, false)\n            prevInput.node?.focus()\n            setMoveFocus(true)\n          } else {\n            setMoveFocus(false)\n          }\n        },\n      [descendants, manageFocus, setValue],\n    )\n\n    const onFocus = useCallback(\n      (index: number) => () => setFocusedIndex(index),\n      [],\n    )\n\n    const onBlur = useCallback(() => setFocusedIndex(-1), [])\n\n    const getInputProps = useCallback(\n      ({\n        index,\n        ...props\n      }: PinInputFieldProps & {\n        index: number\n        ref?: Ref<HTMLInputElement>\n      }): PinInputFieldProps => ({\n        inputMode: type === \"number\" ? \"numeric\" : \"text\",\n        type: mask ? \"password\" : type === \"number\" ? \"tel\" : \"text\",\n        ...formControlProps,\n        ...filterUndefined(props),\n        id: `${id}-${index}`,\n        value: values[index] || \"\",\n        onChange: handlerAll(props.onChange, onChange(index)),\n        onKeyDown: handlerAll(props.onKeyDown, onKeyDown(index)),\n        onFocus: handlerAll(props.onFocus, onFocus(index)),\n        onBlur: handlerAll(props.onBlur, onBlur),\n        autoComplete: otp ? \"one-time-code\" : \"off\",\n        placeholder:\n          focusedIndex === index && !readOnly && !props.readOnly\n            ? \"\"\n            : placeholder,\n      }),\n      [\n        type,\n        mask,\n        formControlProps,\n        id,\n        values,\n        onChange,\n        onKeyDown,\n        onFocus,\n        onBlur,\n        otp,\n        focusedIndex,\n        readOnly,\n        placeholder,\n      ],\n    )\n\n    const css: CSSUIObject = {\n      display: \"flex\",\n      alignItems: \"center\",\n      ...styles.container,\n    }\n\n    let cloneChildren = getValidChildren(children)\n\n    if (!cloneChildren.length)\n      for (let i = 0; i < items; i++) {\n        cloneChildren.push(<PinInputField key={i} />)\n      }\n\n    return (\n      <DescendantsContextProvider value={descendants}>\n        <PinInputProvider value={{ getInputProps, styles }}>\n          <ui.div\n            ref={ref}\n            className={cx(\"ui-pin-input\", className)}\n            __css={css}\n            {...rest}\n          >\n            {cloneChildren}\n          </ui.div>\n        </PinInputProvider>\n      </DescendantsContextProvider>\n    )\n  },\n)\n\nexport type PinInputFieldProps = HTMLUIProps<\"input\"> & FormControlOptions\n\nexport const PinInputField = forwardRef<PinInputFieldProps, \"input\">(\n  ({ className, ...rest }, ref) => {\n    const { getInputProps, styles } = usePinInputContext()\n    const { index, register } = useDescendant()\n\n    rest = useFormControlProps(rest)\n\n    const css: CSSUIObject = { ...styles.field }\n\n    return (\n      <ui.input\n        className={cx(\"ui-pin-input__field\", className)}\n        {...getInputProps({ ...rest, ref: mergeRefs(register, ref), index })}\n        __css={css}\n      />\n    )\n  },\n)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}