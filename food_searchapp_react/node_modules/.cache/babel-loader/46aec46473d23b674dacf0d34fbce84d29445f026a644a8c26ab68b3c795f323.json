{"ast":null,"code":"\"use client\";\n\n// src/use-pagination.ts\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\";\nimport { useValue } from \"@yamada-ui/use-value\";\nimport { createContext } from \"@yamada-ui/utils\";\nimport { useCallback, useMemo } from \"react\";\nvar [PaginationProvider, usePaginationContext] = createContext({\n  strict: false,\n  name: \"PaginationContext\"\n});\nvar computedRange = (start, end) => Array.from({\n  length: end - start + 1\n}, (_, index) => index + start);\nvar usePagination = ({\n  page,\n  defaultPage = 1,\n  total,\n  siblings = 1,\n  boundaries = 1,\n  isDisabled = false,\n  onChange: onChangeProp\n}) => {\n  const computedSiblings = useValue(siblings);\n  const computedBoundaries = useValue(boundaries);\n  const [currentPage, setCurrentPage] = useControllableState({\n    value: page,\n    defaultValue: defaultPage,\n    onChange: onChangeProp\n  });\n  const onFirst = useCallback(() => setCurrentPage(1), [setCurrentPage]);\n  const onLast = useCallback(() => setCurrentPage(total), [setCurrentPage, total]);\n  const onPrev = useCallback(() => setCurrentPage(prev => prev === 1 ? prev : prev - 1), [setCurrentPage]);\n  const onNext = useCallback(() => setCurrentPage(prev => prev === total ? prev : prev + 1), [setCurrentPage, total]);\n  const onChange = useCallback(page2 => setCurrentPage(page2), [setCurrentPage]);\n  const range = useMemo(() => {\n    const minimumTotal = computedSiblings * 2 + 3 + computedBoundaries * 2;\n    if (minimumTotal >= total) return computedRange(1, total);\n    const prevSiblings = Math.max(currentPage - computedSiblings, computedBoundaries);\n    const nextSiblings = Math.min(currentPage + computedSiblings, total - computedBoundaries);\n    const prevDots = prevSiblings > computedBoundaries + 2;\n    const nextDots = nextSiblings < total - (computedBoundaries + 1);\n    if (!prevDots && nextDots) {\n      const prevPages = computedSiblings * 2 + computedBoundaries + 2;\n      return [...computedRange(1, prevPages), \"dots\", ...computedRange(total - (computedBoundaries - 1), total)];\n    }\n    if (prevDots && !nextDots) {\n      const nextPages = computedBoundaries + 1 + 2 * computedSiblings;\n      return [...computedRange(1, computedBoundaries), \"dots\", ...computedRange(total - nextPages, total)];\n    }\n    return [...computedRange(1, computedBoundaries), \"dots\", ...computedRange(prevSiblings, nextSiblings), \"dots\", ...computedRange(total - computedBoundaries + 1, total)];\n  }, [computedBoundaries, computedSiblings, currentPage, total]);\n  return {\n    currentPage,\n    total,\n    isDisabled,\n    onFirst,\n    onLast,\n    onPrev,\n    onNext,\n    onChange,\n    range\n  };\n};\nexport { PaginationProvider, usePaginationContext, computedRange, usePagination };","map":{"version":3,"names":["useControllableState","useValue","createContext","useCallback","useMemo","PaginationProvider","usePaginationContext","strict","name","computedRange","start","end","Array","from","length","_","index","usePagination","page","defaultPage","total","siblings","boundaries","isDisabled","onChange","onChangeProp","computedSiblings","computedBoundaries","currentPage","setCurrentPage","value","defaultValue","onFirst","onLast","onPrev","prev","onNext","page2","range","minimumTotal","prevSiblings","Math","max","nextSiblings","min","prevDots","nextDots","prevPages","nextPages"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\pagination\\src\\use-pagination.ts"],"sourcesContent":["import type { CSSUIObject, Token } from \"@yamada-ui/core\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { useValue } from \"@yamada-ui/use-value\"\nimport { createContext } from \"@yamada-ui/utils\"\nimport { useCallback, useMemo } from \"react\"\n\ntype PaginationContext = Record<string, CSSUIObject>\n\nexport const [PaginationProvider, usePaginationContext] =\n  createContext<PaginationContext>({\n    strict: false,\n    name: \"PaginationContext\",\n  })\n\nexport type UsePaginationProps = {\n  /**\n   * The page of the pagination.\n   * Should be less than `total` and greater than `1`.\n   */\n  page?: number\n  /**\n   * The initial page of the pagination.\n   * Should be less than `total` and greater than `1`.\n   *\n   * @default 1\n   */\n  defaultPage?: number\n  /**\n   * The total number of pages in pagination.\n   */\n  total: number\n  /** Number of siblings displayed on the left/right side of selected page.\n   *\n   * @default 1\n   */\n  siblings?: Token<number>\n  /**\n   * Number of elements visible on the left/right edges.\n   *\n   * @default 1\n   */\n  boundaries?: Token<number>\n  /**\n   * If `true`, the pagination all item will be disabled.\n   *\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * The callback invoked when the page changes.\n   */\n  onChange?: (page: number) => void\n}\n\nexport const computedRange = (start: number, end: number) =>\n  Array.from({ length: end - start + 1 }, (_, index) => index + start)\n\nexport const usePagination = ({\n  page,\n  defaultPage = 1,\n  total,\n  siblings = 1,\n  boundaries = 1,\n  isDisabled = false,\n  onChange: onChangeProp,\n}: UsePaginationProps) => {\n  const computedSiblings = useValue(siblings)\n  const computedBoundaries = useValue(boundaries)\n\n  const [currentPage, setCurrentPage] = useControllableState({\n    value: page,\n    defaultValue: defaultPage,\n    onChange: onChangeProp,\n  })\n\n  const onFirst = useCallback(() => setCurrentPage(1), [setCurrentPage])\n\n  const onLast = useCallback(\n    () => setCurrentPage(total),\n    [setCurrentPage, total],\n  )\n\n  const onPrev = useCallback(\n    () => setCurrentPage((prev) => (prev === 1 ? prev : prev - 1)),\n    [setCurrentPage],\n  )\n\n  const onNext = useCallback(\n    () => setCurrentPage((prev) => (prev === total ? prev : prev + 1)),\n    [setCurrentPage, total],\n  )\n\n  const onChange = useCallback(\n    (page: number) => setCurrentPage(page),\n    [setCurrentPage],\n  )\n\n  const range = useMemo((): (number | \"dots\")[] => {\n    const minimumTotal = computedSiblings * 2 + 3 + computedBoundaries * 2\n\n    if (minimumTotal >= total) return computedRange(1, total)\n\n    const prevSiblings = Math.max(\n      currentPage - computedSiblings,\n      computedBoundaries,\n    )\n    const nextSiblings = Math.min(\n      currentPage + computedSiblings,\n      total - computedBoundaries,\n    )\n\n    const prevDots = prevSiblings > computedBoundaries + 2\n    const nextDots = nextSiblings < total - (computedBoundaries + 1)\n\n    if (!prevDots && nextDots) {\n      const prevPages = computedSiblings * 2 + computedBoundaries + 2\n\n      return [\n        ...computedRange(1, prevPages),\n        \"dots\",\n        ...computedRange(total - (computedBoundaries - 1), total),\n      ]\n    }\n\n    if (prevDots && !nextDots) {\n      const nextPages = computedBoundaries + 1 + 2 * computedSiblings\n\n      return [\n        ...computedRange(1, computedBoundaries),\n        \"dots\",\n        ...computedRange(total - nextPages, total),\n      ]\n    }\n\n    return [\n      ...computedRange(1, computedBoundaries),\n      \"dots\",\n      ...computedRange(prevSiblings, nextSiblings),\n      \"dots\",\n      ...computedRange(total - computedBoundaries + 1, total),\n    ]\n  }, [computedBoundaries, computedSiblings, currentPage, total])\n\n  return {\n    currentPage,\n    total,\n    isDisabled,\n    onFirst,\n    onLast,\n    onPrev,\n    onNext,\n    onChange,\n    range,\n  }\n}\n\nexport type UsePaginationReturn = ReturnType<typeof usePagination>\n"],"mappings":";;;AACA,SAASA,oBAAA,QAA4B;AACrC,SAASC,QAAA,QAAgB;AACzB,SAASC,aAAA,QAAqB;AAC9B,SAASC,WAAA,EAAaC,OAAA,QAAe;AAI9B,IAAM,CAACC,kBAAA,EAAoBC,oBAAoB,IACpDJ,aAAA,CAAiC;EAC/BK,MAAA,EAAQ;EACRC,IAAA,EAAM;AACR,CAAC;AA0CI,IAAMC,aAAA,GAAgBA,CAACC,KAAA,EAAeC,GAAA,KAC3CC,KAAA,CAAMC,IAAA,CAAK;EAAEC,MAAA,EAAQH,GAAA,GAAMD,KAAA,GAAQ;AAAE,GAAG,CAACK,CAAA,EAAGC,KAAA,KAAUA,KAAA,GAAQN,KAAK;AAE9D,IAAMO,aAAA,GAAgBA,CAAC;EAC5BC,IAAA;EACAC,WAAA,GAAc;EACdC,KAAA;EACAC,QAAA,GAAW;EACXC,UAAA,GAAa;EACbC,UAAA,GAAa;EACbC,QAAA,EAAUC;AACZ,MAA0B;EACxB,MAAMC,gBAAA,GAAmBzB,QAAA,CAASoB,QAAQ;EAC1C,MAAMM,kBAAA,GAAqB1B,QAAA,CAASqB,UAAU;EAE9C,MAAM,CAACM,WAAA,EAAaC,cAAc,IAAI7B,oBAAA,CAAqB;IACzD8B,KAAA,EAAOZ,IAAA;IACPa,YAAA,EAAcZ,WAAA;IACdK,QAAA,EAAUC;EACZ,CAAC;EAED,MAAMO,OAAA,GAAU7B,WAAA,CAAY,MAAM0B,cAAA,CAAe,CAAC,GAAG,CAACA,cAAc,CAAC;EAErE,MAAMI,MAAA,GAAS9B,WAAA,CACb,MAAM0B,cAAA,CAAeT,KAAK,GAC1B,CAACS,cAAA,EAAgBT,KAAK,CACxB;EAEA,MAAMc,MAAA,GAAS/B,WAAA,CACb,MAAM0B,cAAA,CAAgBM,IAAA,IAAUA,IAAA,KAAS,IAAIA,IAAA,GAAOA,IAAA,GAAO,CAAE,GAC7D,CAACN,cAAc,CACjB;EAEA,MAAMO,MAAA,GAASjC,WAAA,CACb,MAAM0B,cAAA,CAAgBM,IAAA,IAAUA,IAAA,KAASf,KAAA,GAAQe,IAAA,GAAOA,IAAA,GAAO,CAAE,GACjE,CAACN,cAAA,EAAgBT,KAAK,CACxB;EAEA,MAAMI,QAAA,GAAWrB,WAAA,CACdkC,KAAA,IAAiBR,cAAA,CAAeQ,KAAI,GACrC,CAACR,cAAc,CACjB;EAEA,MAAMS,KAAA,GAAQlC,OAAA,CAAQ,MAA2B;IAC/C,MAAMmC,YAAA,GAAeb,gBAAA,GAAmB,IAAI,IAAIC,kBAAA,GAAqB;IAErE,IAAIY,YAAA,IAAgBnB,KAAA,EAAO,OAAOX,aAAA,CAAc,GAAGW,KAAK;IAExD,MAAMoB,YAAA,GAAeC,IAAA,CAAKC,GAAA,CACxBd,WAAA,GAAcF,gBAAA,EACdC,kBACF;IACA,MAAMgB,YAAA,GAAeF,IAAA,CAAKG,GAAA,CACxBhB,WAAA,GAAcF,gBAAA,EACdN,KAAA,GAAQO,kBACV;IAEA,MAAMkB,QAAA,GAAWL,YAAA,GAAeb,kBAAA,GAAqB;IACrD,MAAMmB,QAAA,GAAWH,YAAA,GAAevB,KAAA,IAASO,kBAAA,GAAqB;IAE9D,IAAI,CAACkB,QAAA,IAAYC,QAAA,EAAU;MACzB,MAAMC,SAAA,GAAYrB,gBAAA,GAAmB,IAAIC,kBAAA,GAAqB;MAE9D,OAAO,CACL,GAAGlB,aAAA,CAAc,GAAGsC,SAAS,GAC7B,QACA,GAAGtC,aAAA,CAAcW,KAAA,IAASO,kBAAA,GAAqB,IAAIP,KAAK,EAC1D;IACF;IAEA,IAAIyB,QAAA,IAAY,CAACC,QAAA,EAAU;MACzB,MAAME,SAAA,GAAYrB,kBAAA,GAAqB,IAAI,IAAID,gBAAA;MAE/C,OAAO,CACL,GAAGjB,aAAA,CAAc,GAAGkB,kBAAkB,GACtC,QACA,GAAGlB,aAAA,CAAcW,KAAA,GAAQ4B,SAAA,EAAW5B,KAAK,EAC3C;IACF;IAEA,OAAO,CACL,GAAGX,aAAA,CAAc,GAAGkB,kBAAkB,GACtC,QACA,GAAGlB,aAAA,CAAc+B,YAAA,EAAcG,YAAY,GAC3C,QACA,GAAGlC,aAAA,CAAcW,KAAA,GAAQO,kBAAA,GAAqB,GAAGP,KAAK,EACxD;EACF,GAAG,CAACO,kBAAA,EAAoBD,gBAAA,EAAkBE,WAAA,EAAaR,KAAK,CAAC;EAE7D,OAAO;IACLQ,WAAA;IACAR,KAAA;IACAG,UAAA;IACAS,OAAA;IACAC,MAAA;IACAC,MAAA;IACAE,MAAA;IACAZ,QAAA;IACAc;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}