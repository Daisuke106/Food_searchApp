{"ast":null,"code":"\"use client\";\n\n// src/index.ts\nimport { clampNumber, countDecimal, toPrecision, useCallbackRef } from \"@yamada-ui/utils\";\nimport { useCallback, useState } from \"react\";\nvar useCounter = ({\n  min = Number.MIN_SAFE_INTEGER,\n  max = Number.MAX_SAFE_INTEGER,\n  keepWithinRange = true,\n  ...props\n} = {}) => {\n  var _a, _b;\n  const onChange = useCallbackRef(props.onChange);\n  const [defaultValue, setValue] = useState(() => {\n    var _a2, _b2;\n    if (props.defaultValue == null) return \"\";\n    return (_b2 = casting(props.defaultValue, (_a2 = props.step) != null ? _a2 : 1, props.precision)) != null ? _b2 : \"\";\n  });\n  const isControlled = typeof props.value !== \"undefined\";\n  const value = isControlled ? props.value : defaultValue;\n  const countDecimal2 = getCountDecimal(parse(value), (_a = props.step) != null ? _a : 1);\n  const precision = (_b = props.precision) != null ? _b : countDecimal2;\n  const update = useCallback(next => {\n    if (next === value) return;\n    if (!isControlled) setValue(next.toString());\n    onChange(next.toString(), parse(next));\n  }, [onChange, isControlled, value]);\n  const clamp = useCallback(value2 => {\n    let nextValue = value2;\n    if (keepWithinRange) nextValue = clampNumber(nextValue, min, max);\n    return toPrecision(nextValue, precision);\n  }, [precision, keepWithinRange, max, min]);\n  const increment = useCallback((step = (_c => (_c = props.step) != null ? _c : 1)()) => {\n    let next;\n    if (value === \"\") {\n      next = parse(step);\n    } else {\n      next = parse(value) + step;\n    }\n    next = clamp(next);\n    update(next);\n  }, [clamp, props.step, update, value]);\n  const decrement = useCallback((step = (_d => (_d = props.step) != null ? _d : 1)()) => {\n    let next;\n    if (value === \"\") {\n      next = parse(-step);\n    } else {\n      next = parse(value) - step;\n    }\n    next = clamp(next);\n    update(next);\n  }, [clamp, props.step, update, value]);\n  const reset = useCallback(() => {\n    var _a2, _b2;\n    let next;\n    if (props.defaultValue == null) {\n      next = \"\";\n    } else {\n      next = (_b2 = casting(props.defaultValue, (_a2 = props.step) != null ? _a2 : 1, props.precision)) != null ? _b2 : min;\n    }\n    update(next);\n  }, [props.defaultValue, props.precision, props.step, update, min]);\n  const cast = useCallback(value2 => {\n    var _a2, _b2;\n    const nextValue = (_b2 = casting(value2, (_a2 = props.step) != null ? _a2 : 1, precision)) != null ? _b2 : min;\n    update(nextValue);\n  }, [precision, props.step, update, min]);\n  const valueAsNumber = parse(value);\n  const isOut = valueAsNumber < min || max < valueAsNumber;\n  const isMax = valueAsNumber === max;\n  const isMin = valueAsNumber === min;\n  return {\n    isOut,\n    isMax,\n    isMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast,\n    setValue\n  };\n};\nvar parse = value => parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"));\nvar getCountDecimal = (value, step) => Math.max(countDecimal(step), countDecimal(value));\nvar casting = (value, step, precision) => {\n  value = parse(value);\n  return !Number.isNaN(value) ? toPrecision(value, precision != null ? precision : getCountDecimal(value, step)) : void 0;\n};\nexport { useCounter };","map":{"version":3,"names":["clampNumber","countDecimal","toPrecision","useCallbackRef","useCallback","useState","useCounter","min","Number","MIN_SAFE_INTEGER","max","MAX_SAFE_INTEGER","keepWithinRange","props","_a","_b","onChange","defaultValue","setValue","_a2","_b2","casting","step","precision","isControlled","value","countDecimal2","getCountDecimal","parse","update","next","toString","clamp","value2","nextValue","increment","_c","decrement","_d","reset","cast","valueAsNumber","isOut","isMax","isMin","parseFloat","replace","Math","isNaN"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\use-counter\\src\\index.ts"],"sourcesContent":["import {\n  clampNumber,\n  countDecimal,\n  toPrecision,\n  useCallbackRef,\n} from \"@yamada-ui/utils\"\nimport { useCallback, useState } from \"react\"\n\nexport type UseCounterProps = {\n  /**\n   * The value of the counter.\n   * Should be less than `max` and greater than `min`.\n   */\n  value?: string | number\n  /**\n   * The initial value of the counter.\n   * Should be less than `max` and greater than `min`.\n   */\n  defaultValue?: string | number\n  /**\n   * The step used to increment or decrement the value.\n   *\n   * @default 1\n   */\n  step?: number\n  /**\n   * The minimum value of the counter\n   *\n   * @default Number.MIN_SAFE_INTEGER\n   */\n  min?: number\n  /**\n   * The maximum value of the counter\n   *\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  max?: number\n  /**\n   * The number of decimal points used to round the value.\n   */\n  precision?: number\n  /**\n   * This controls the value update behavior in general.\n   *\n   * - If `true` and you use the stepper or up/down arrow keys,\n   * the value will not exceed the `max` or go lower than `min`.\n   *\n   * - If `false`, the value will be allowed to go out of range.\n   *\n   * @default true\n   */\n  keepWithinRange?: boolean\n  /**\n   * The callback fired when the value changes.\n   */\n  onChange?: (valueAsString: string, valueAsNumber: number) => void\n}\n\nexport const useCounter = ({\n  min = Number.MIN_SAFE_INTEGER,\n  max = Number.MAX_SAFE_INTEGER,\n  keepWithinRange = true,\n  ...props\n}: UseCounterProps = {}) => {\n  const onChange = useCallbackRef(props.onChange)\n\n  const [defaultValue, setValue] = useState<string | number>(() => {\n    if (props.defaultValue == null) return \"\"\n\n    return casting(props.defaultValue, props.step ?? 1, props.precision) ?? \"\"\n  })\n\n  const isControlled = typeof props.value !== \"undefined\"\n  const value = isControlled ? (props.value as string | number) : defaultValue\n\n  const countDecimal = getCountDecimal(parse(value), props.step ?? 1)\n\n  const precision = props.precision ?? countDecimal\n\n  const update = useCallback(\n    (next: string | number) => {\n      if (next === value) return\n\n      if (!isControlled) setValue(next.toString())\n\n      onChange(next.toString(), parse(next))\n    },\n    [onChange, isControlled, value],\n  )\n\n  const clamp = useCallback(\n    (value: number) => {\n      let nextValue = value\n\n      if (keepWithinRange) nextValue = clampNumber(nextValue, min, max)\n\n      return toPrecision(nextValue, precision)\n    },\n    [precision, keepWithinRange, max, min],\n  )\n\n  const increment = useCallback(\n    (step = props.step ?? 1) => {\n      let next: string | number\n\n      if (value === \"\") {\n        next = parse(step)\n      } else {\n        next = parse(value) + step\n      }\n\n      next = clamp(next as number)\n\n      update(next)\n    },\n    [clamp, props.step, update, value],\n  )\n\n  const decrement = useCallback(\n    (step = props.step ?? 1) => {\n      let next: string | number\n\n      if (value === \"\") {\n        next = parse(-step)\n      } else {\n        next = parse(value) - step\n      }\n\n      next = clamp(next as number)\n\n      update(next)\n    },\n    [clamp, props.step, update, value],\n  )\n\n  const reset = useCallback(() => {\n    let next: string | number\n\n    if (props.defaultValue == null) {\n      next = \"\"\n    } else {\n      next =\n        casting(props.defaultValue, props.step ?? 1, props.precision) ?? min\n    }\n\n    update(next)\n  }, [props.defaultValue, props.precision, props.step, update, min])\n\n  const cast = useCallback(\n    (value: string | number) => {\n      const nextValue = casting(value, props.step ?? 1, precision) ?? min\n\n      update(nextValue)\n    },\n    [precision, props.step, update, min],\n  )\n\n  const valueAsNumber = parse(value)\n\n  const isOut = valueAsNumber < min || max < valueAsNumber\n  const isMax = valueAsNumber === max\n  const isMin = valueAsNumber === min\n\n  return {\n    isOut,\n    isMax,\n    isMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast,\n    setValue,\n  }\n}\n\nexport type UseCounterReturn = ReturnType<typeof useCounter>\n\nconst parse = (value: string | number): number =>\n  parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"))\n\nconst getCountDecimal = (value: number, step: number): number =>\n  Math.max(countDecimal(step), countDecimal(value))\n\nconst casting = (\n  value: string | number,\n  step: number,\n  precision?: number,\n): string | undefined => {\n  value = parse(value)\n\n  return !Number.isNaN(value)\n    ? toPrecision(value, precision ?? getCountDecimal(value, step))\n    : undefined\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}