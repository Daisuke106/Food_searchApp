{"ast":null,"code":"\"use client\";\n\n// src/toggle-group.tsx\nimport { ui, forwardRef } from \"@yamada-ui/core\";\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\";\nimport { createContext, cx, isArray, isUndefined, useUpdateEffect } from \"@yamada-ui/utils\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar [ToggleGroupProvider, useToggleGroup] = createContext({\n  strict: false,\n  name: \"ToggleGroupContext\"\n});\nvar ToggleGroup = forwardRef((_ref, ref) => {\n  let {\n    value: valueProp,\n    defaultValue,\n    onChange: onChangeProp,\n    className,\n    size,\n    variant,\n    direction: flexDirection,\n    isDisabled,\n    isReadOnly,\n    ...rest\n  } = _ref;\n  const [value, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue,\n    onChange: onChangeProp\n  });\n  const isControlledRef = useRef(!isUndefined(value));\n  const onChange = useCallback(value2 => {\n    if (isUndefined(value2)) return;\n    setValue(prev => {\n      if (isArray(prev)) {\n        const isIncluded = prev.includes(value2);\n        if (isIncluded) {\n          return prev.filter(prevValue => prevValue !== value2);\n        } else {\n          return [...prev, value2];\n        }\n      } else {\n        if (value2 === prev) {\n          return void 0;\n        } else {\n          return value2;\n        }\n      }\n    });\n  }, [setValue]);\n  const css = {\n    display: \"inline-flex\",\n    gap: \"0.5rem\",\n    flexDirection\n  };\n  const values = useMemo(() => ({\n    value,\n    size,\n    variant,\n    isDisabled,\n    isReadOnly,\n    isControlled: isControlledRef.current,\n    onChange\n  }), [value, size, variant, isDisabled, isReadOnly, onChange]);\n  useUpdateEffect(() => {\n    if (isUndefined(value)) return;\n    isControlledRef.current = true;\n  }, [valueProp]);\n  return /* @__PURE__ */jsx(ToggleGroupProvider, {\n    value: values,\n    children: /* @__PURE__ */jsx(ui.div, {\n      ref,\n      role: \"group\",\n      className: cx(\"ui-toggle-group\", className),\n      __css: css,\n      ...rest\n    })\n  });\n});\nToggleGroup.displayName = \"ToggleGroup\";\nexport { useToggleGroup, ToggleGroup };","map":{"version":3,"names":["ui","forwardRef","useControllableState","createContext","cx","isArray","isUndefined","useUpdateEffect","useCallback","useMemo","useRef","jsx","ToggleGroupProvider","useToggleGroup","strict","name","ToggleGroup","_ref","ref","value","valueProp","defaultValue","onChange","onChangeProp","className","size","variant","direction","flexDirection","isDisabled","isReadOnly","rest","setValue","isControlledRef","value2","prev","isIncluded","includes","filter","prevValue","css","display","gap","values","isControlled","current","children","div","role","__css","displayName"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\toggle\\src\\toggle-group.tsx"],"sourcesContent":["import type {\n  CSSUIObject,\n  ComponentArgs,\n  HTMLUIProps,\n  ThemeProps,\n} from \"@yamada-ui/core\"\nimport { ui, forwardRef } from \"@yamada-ui/core\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport {\n  createContext,\n  cx,\n  isArray,\n  isUndefined,\n  useUpdateEffect,\n} from \"@yamada-ui/utils\"\nimport type { ForwardedRef, Ref } from \"react\"\nimport { useCallback, useMemo, useRef } from \"react\"\n\ntype ToggleGroupContext = ThemeProps<\"Button\"> & {\n  isControlled: boolean\n  value?: string | number | (string | number)[]\n  onChange?: <M extends string | number = string>(value: M | undefined) => void\n  isDisabled?: boolean\n  isReadOnly?: boolean\n}\n\nconst [ToggleGroupProvider, useToggleGroup] = createContext<ToggleGroupContext>(\n  {\n    strict: false,\n    name: \"ToggleGroupContext\",\n  },\n)\n\nexport { useToggleGroup }\n\ntype ToggleGroupOptions<\n  Y extends string | number | (string | number)[] = string,\n> = {\n  /**\n   * The value of the toggle button group.\n   */\n  value?: Y extends any[] ? Y : Y | undefined\n  /**\n   * The initial value of the toggle button group.\n   */\n  defaultValue?: Y extends any[] ? Y : Y | undefined\n  /**\n   * The callback fired when any children toggle button is selected or unselected.\n   */\n  onChange?: (value: Y extends Array<any> ? Y : Y | undefined) => void\n  /**\n   * The CSS `flex-direction` property.\n   */\n  direction?: CSSUIObject[\"flexDirection\"]\n  /**\n   * If `true`, all wrapped toggle button will be disabled.\n   *\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, all wrapped toggle button will be readonly.\n   *\n   * @default false\n   */\n  isReadOnly?: boolean\n}\n\n/**\n * `ToggleGroup` is a set of two-state buttons that can be toggled on or off.\n *\n * @see Docs https://yamada-ui.com/components/forms/toggle\n */\nexport type ToggleGroupProps<\n  Y extends string | number | (string | number)[] = string,\n> = Omit<HTMLUIProps<\"div\">, \"direction\" | \"onChange\"> &\n  ThemeProps<\"Toggle\"> &\n  ToggleGroupOptions<Y>\n\nexport const ToggleGroup = forwardRef(\n  <Y extends string | number | (string | number)[] = string>(\n    {\n      value: valueProp,\n      defaultValue,\n      onChange: onChangeProp,\n      className,\n      size,\n      variant,\n      direction: flexDirection,\n      isDisabled,\n      isReadOnly,\n      ...rest\n    }: ToggleGroupProps<Y>,\n    ref: ForwardedRef<HTMLDivElement>,\n  ) => {\n    type Value = Y extends any[] ? Y : Y | undefined\n\n    const [value, setValue] = useControllableState<Value>({\n      value: valueProp,\n      defaultValue,\n      onChange: onChangeProp,\n    })\n    const isControlledRef = useRef<boolean>(!isUndefined(value))\n\n    const onChange = useCallback(\n      <M extends string | number = Y extends Array<any> ? Y[number] : Y>(\n        value: M | undefined,\n      ) => {\n        if (isUndefined(value)) return\n\n        setValue((prev) => {\n          if (isArray(prev)) {\n            const isIncluded = prev.includes(value)\n\n            if (isIncluded) {\n              return prev.filter((prevValue) => prevValue !== value) as Value\n            } else {\n              return [...prev, value] as Value\n            }\n          } else {\n            if (value === (prev as string | number | undefined)) {\n              return undefined as Value\n            } else {\n              return value as unknown as Value\n            }\n          }\n        })\n      },\n      [setValue],\n    )\n\n    const css: CSSUIObject = {\n      display: \"inline-flex\",\n      gap: \"0.5rem\",\n      flexDirection,\n    }\n\n    const values: ToggleGroupContext = useMemo(\n      () => ({\n        value,\n        size,\n        variant,\n        isDisabled,\n        isReadOnly,\n        isControlled: isControlledRef.current,\n        onChange,\n      }),\n      [value, size, variant, isDisabled, isReadOnly, onChange],\n    )\n\n    useUpdateEffect(() => {\n      if (isUndefined(value)) return\n\n      isControlledRef.current = true\n    }, [valueProp])\n\n    return (\n      <ToggleGroupProvider value={values}>\n        <ui.div\n          ref={ref}\n          role=\"group\"\n          className={cx(\"ui-toggle-group\", className)}\n          __css={css}\n          {...rest}\n        />\n      </ToggleGroupProvider>\n    )\n  },\n) as {\n  <Y extends string | number | (string | number)[] = string>(\n    props: ToggleGroupProps<Y> & { ref?: Ref<HTMLDivElement> },\n  ): JSX.Element\n} & ComponentArgs\n\nToggleGroup.displayName = \"ToggleGroup\"\n"],"mappings":";;;AAMA,SAASA,EAAA,EAAIC,UAAA,QAAkB;AAC/B,SAASC,oBAAA,QAA4B;AACrC,SACEC,aAAA,EACAC,EAAA,EACAC,OAAA,EACAC,WAAA,EACAC,eAAA,QACK;AAEP,SAASC,WAAA,EAAaC,OAAA,EAASC,MAAA,QAAc;AA8IrC,SAAAC,GAAA;AApIR,IAAM,CAACC,mBAAA,EAAqBC,cAAc,IAAIV,aAAA,CAC5C;EACEW,MAAA,EAAQ;EACRC,IAAA,EAAM;AACR,CACF;AAgDO,IAAMC,WAAA,GAAcf,UAAA,CACzB,CAAAgB,IAAA,EAaEC,GAAA,KACG;EAAA,IAbH;IACEC,KAAA,EAAOC,SAAA;IACPC,YAAA;IACAC,QAAA,EAAUC,YAAA;IACVC,SAAA;IACAC,IAAA;IACAC,OAAA;IACAC,SAAA,EAAWC,aAAA;IACXC,UAAA;IACAC,UAAA;IACA,GAAGC;EACL,IAAAd,IAAA;EAKA,MAAM,CAACE,KAAA,EAAOa,QAAQ,IAAI9B,oBAAA,CAA4B;IACpDiB,KAAA,EAAOC,SAAA;IACPC,YAAA;IACAC,QAAA,EAAUC;EACZ,CAAC;EACD,MAAMU,eAAA,GAAkBvB,MAAA,CAAgB,CAACJ,WAAA,CAAYa,KAAK,CAAC;EAE3D,MAAMG,QAAA,GAAWd,WAAA,CAEb0B,MAAA,IACG;IACH,IAAI5B,WAAA,CAAY4B,MAAK,GAAG;IAExBF,QAAA,CAAUG,IAAA,IAAS;MACjB,IAAI9B,OAAA,CAAQ8B,IAAI,GAAG;QACjB,MAAMC,UAAA,GAAaD,IAAA,CAAKE,QAAA,CAASH,MAAK;QAEtC,IAAIE,UAAA,EAAY;UACd,OAAOD,IAAA,CAAKG,MAAA,CAAQC,SAAA,IAAcA,SAAA,KAAcL,MAAK;QACvD,OAAO;UACL,OAAO,CAAC,GAAGC,IAAA,EAAMD,MAAK;QACxB;MACF,OAAO;QACL,IAAIA,MAAA,KAAWC,IAAA,EAAsC;UACnD,OAAO;QACT,OAAO;UACL,OAAOD,MAAA;QACT;MACF;IACF,CAAC;EACH,GACA,CAACF,QAAQ,CACX;EAEA,MAAMQ,GAAA,GAAmB;IACvBC,OAAA,EAAS;IACTC,GAAA,EAAK;IACLd;EACF;EAEA,MAAMe,MAAA,GAA6BlC,OAAA,CACjC,OAAO;IACLU,KAAA;IACAM,IAAA;IACAC,OAAA;IACAG,UAAA;IACAC,UAAA;IACAc,YAAA,EAAcX,eAAA,CAAgBY,OAAA;IAC9BvB;EACF,IACA,CAACH,KAAA,EAAOM,IAAA,EAAMC,OAAA,EAASG,UAAA,EAAYC,UAAA,EAAYR,QAAQ,CACzD;EAEAf,eAAA,CAAgB,MAAM;IACpB,IAAID,WAAA,CAAYa,KAAK,GAAG;IAExBc,eAAA,CAAgBY,OAAA,GAAU;EAC5B,GAAG,CAACzB,SAAS,CAAC;EAEd,OACE,eAAAT,GAAA,CAACC,mBAAA;IAAoBO,KAAA,EAAOwB,MAAA;IAC1BG,QAAA,iBAAAnC,GAAA,CAACX,EAAA,CAAG+C,GAAA,EAAH;MACC7B,GAAA;MACA8B,IAAA,EAAK;MACLxB,SAAA,EAAWpB,EAAA,CAAG,mBAAmBoB,SAAS;MAC1CyB,KAAA,EAAOT,GAAA;MACN,GAAGT;IAAA,CACN;EAAA,CACF;AAEJ,CACF;AAMAf,WAAA,CAAYkC,WAAA,GAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}