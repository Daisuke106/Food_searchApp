{"ast":null,"code":"\"use client\";\n\n// src/highlight.tsx\nimport { ui, forwardRef, useComponentStyle, omitThemeProps } from \"@yamada-ui/core\";\nimport { Text } from \"@yamada-ui/typography\";\nimport { cx, isArray } from \"@yamada-ui/utils\";\nimport { Fragment, useMemo } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar escapeRegexp = term => term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, char => `\\\\${char}`);\nvar buildRegex = query => {\n  query = query.filter(Boolean).map(text => escapeRegexp(text.trim()));\n  if (query.length) return new RegExp(`(${query.join(\"|\")})`, \"ig\");\n};\nvar highlightWords = ({\n  text,\n  query\n}) => {\n  const regex = buildRegex(isArray(query) ? query : [query]);\n  if (!regex) return [{\n    text,\n    match: false\n  }];\n  return text.split(regex).filter(Boolean).map(text2 => ({\n    text: text2,\n    match: regex.test(text2)\n  }));\n};\nvar useHighlight = ({\n  text,\n  query\n}) => useMemo(() => highlightWords({\n  text,\n  query\n}), [text, query]);\nvar Highlight = ({\n  isFragment = false,\n  query,\n  children: text,\n  markProps,\n  lineHeight = \"tall\",\n  ...rest\n}) => {\n  if (typeof text !== \"string\") throw new Error(\"The children prop of Highlight must be a string\");\n  const chunks = useHighlight({\n    query,\n    text\n  });\n  const Component = isFragment ? Fragment : Text;\n  return /* @__PURE__ */jsx(Component, {\n    ...(!isFragment ? {\n      lineHeight\n    } : {}),\n    ...rest,\n    children: chunks.map(({\n      text: text2,\n      match\n    }, i) => match ? /* @__PURE__ */jsx(Mark, {\n      ...markProps,\n      children: text2\n    }, i) : /* @__PURE__ */jsx(Fragment, {\n      children: text2\n    }, i))\n  });\n};\nvar Mark = forwardRef((props, ref) => {\n  const [styles, mergedProps] = useComponentStyle(\"Mark\", props);\n  const {\n    className,\n    ...rest\n  } = omitThemeProps(mergedProps);\n  const css = {\n    bg: \"transparent\",\n    whiteSpace: \"nowrap\",\n    ...styles\n  };\n  return /* @__PURE__ */jsx(ui.mark, {\n    ref,\n    className: cx(\"ui-mark\", className),\n    __css: css,\n    ...rest\n  });\n});\nexport { useHighlight, Highlight, Mark };","map":{"version":3,"names":["ui","forwardRef","useComponentStyle","omitThemeProps","Text","cx","isArray","Fragment","useMemo","jsx","escapeRegexp","term","replace","char","buildRegex","query","filter","Boolean","map","text","trim","length","RegExp","join","highlightWords","regex","match","split","text2","test","useHighlight","Highlight","isFragment","children","markProps","lineHeight","rest","Error","chunks","Component","i","Mark","props","ref","styles","mergedProps","className","css","bg","whiteSpace","mark","__css"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\highlight\\src\\highlight.tsx"],"sourcesContent":["/**\n * `Highlight` is a component that highlights specified strings within text. By default, it renders a `p` element.\n *\n * @see Docs https://yamada-ui.com/components/typography/highlight\n */\nimport type { HTMLUIProps, ThemeProps, CSSUIObject } from \"@yamada-ui/core\"\nimport {\n  ui,\n  forwardRef,\n  useComponentStyle,\n  omitThemeProps,\n} from \"@yamada-ui/core\"\nimport type { TextProps } from \"@yamada-ui/typography\"\nimport { Text } from \"@yamada-ui/typography\"\nimport { cx, isArray } from \"@yamada-ui/utils\"\nimport type { FC, ReactNode } from \"react\"\nimport { Fragment, useMemo } from \"react\"\n\ntype Options = { text: string; query: string | string[] }\n\ntype Chunk = { text: string; match: boolean }\n\nconst escapeRegexp = (term: string): string =>\n  term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, (char: string) => `\\\\${char}`)\n\nconst buildRegex = (query: string[]): RegExp | undefined => {\n  query = query.filter(Boolean).map((text) => escapeRegexp(text.trim()))\n\n  if (query.length) return new RegExp(`(${query.join(\"|\")})`, \"ig\")\n}\n\nconst highlightWords = ({ text, query }: Options): Chunk[] => {\n  const regex = buildRegex(isArray(query) ? query : [query])\n\n  if (!regex) return [{ text, match: false }]\n\n  return text\n    .split(regex)\n    .filter(Boolean)\n    .map((text) => ({ text, match: regex.test(text) }))\n}\n\nexport const useHighlight = ({ text, query }: Options): Chunk[] =>\n  useMemo(() => highlightWords({ text, query }), [text, query])\n\nexport type HighlightProps = TextProps & {\n  /**\n   * If `true`, `Fragment` is used for rendering.\n   *\n   * @default false\n   */\n  isFragment?: boolean\n  /**\n   * Can be a single string or an array of strings. These are the terms that are highlighted in the text.\n   */\n  query: string | string[]\n  /**\n   * Accepts a string or a function. If it's a function, it should return a `ReactNode` and accept an array of `Chunk` objects as its argument.\n   */\n  children: string | ((props: Chunk[]) => ReactNode)\n  /**\n   * Properties passed to the Mark component which is used to highlight the matched terms.\n   */\n  markProps?: MarkProps\n}\n\nexport const Highlight: FC<HighlightProps> = ({\n  isFragment = false,\n  query,\n  children: text,\n  markProps,\n  lineHeight = \"tall\",\n  ...rest\n}) => {\n  if (typeof text !== \"string\")\n    throw new Error(\"The children prop of Highlight must be a string\")\n\n  const chunks = useHighlight({ query, text })\n\n  const Component: FC = isFragment ? Fragment : Text\n\n  return (\n    <Component {...(!isFragment ? { lineHeight } : {})} {...rest}>\n      {chunks.map(({ text, match }, i) =>\n        match ? (\n          <Mark key={i} {...markProps}>\n            {text}\n          </Mark>\n        ) : (\n          <Fragment key={i}>{text}</Fragment>\n        ),\n      )}\n    </Component>\n  )\n}\n\nexport type MarkProps = HTMLUIProps<\"mark\"> & ThemeProps<\"Mark\">\n\nexport const Mark = forwardRef<MarkProps, \"mark\">((props, ref) => {\n  const [styles, mergedProps] = useComponentStyle(\"Mark\", props)\n  const { className, ...rest } = omitThemeProps(mergedProps)\n\n  const css: CSSUIObject = {\n    bg: \"transparent\",\n    whiteSpace: \"nowrap\",\n    ...styles,\n  }\n\n  return (\n    <ui.mark\n      ref={ref}\n      className={cx(\"ui-mark\", className)}\n      __css={css}\n      {...rest}\n    />\n  )\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}