{"ast":null,"code":"\"use client\";\n\n// src/use-color-selector.ts\nimport { useFormControlProps, formControlProperties } from \"@yamada-ui/form-control\";\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\";\nimport { useEyeDropper } from \"@yamada-ui/use-eye-dropper\";\nimport { calcFormat, convertColor, createContext, handlerAll, hsvTo, isString, parseToHsv, useCallbackRef, useUpdateEffect, omitObject, parseToRgba, parseToHsla, rgbaTo, hslaTo, pickObject } from \"@yamada-ui/utils\";\nimport { useCallback, useMemo, useRef, useState } from \"react\";\nvar convertHsla = (value, fallback) => {\n  var _a;\n  let [h, s, l, a] = (_a = parseToHsla(value, fallback)) != null ? _a : [0, 0, 1, 1];\n  if (a > 1) a = 1;\n  return {\n    h,\n    s,\n    l,\n    a\n  };\n};\nvar convertRgba = (value, fallback) => {\n  var _a;\n  let [r, g, b, a] = (_a = parseToRgba(value, fallback)) != null ? _a : [255, 255, 255, 1];\n  if (r > 255) r = 255;\n  if (g > 255) g = 255;\n  if (b > 255) b = 255;\n  if (a > 1) a = 1;\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n};\nvar convertHsva = (value, fallback) => {\n  const [h, s, v, a] = parseToHsv(value, fallback);\n  return {\n    h,\n    s,\n    v,\n    a\n  };\n};\nvar [ColorSelectorProvider, useColorSelectorContext] = createContext({\n  name: \"ColorSelectorContext\",\n  errorMessage: `useColorSelectorContext returned is 'undefined'. Seems you forgot to wrap the components in \"<ColorSelector />\"`\n});\nvar useColorSelector = ({\n  isInvalid,\n  ...props\n}) => {\n  let {\n    id,\n    name,\n    value: valueProp,\n    defaultValue,\n    fallbackValue,\n    onChange: onChangeProp,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    format,\n    required,\n    disabled,\n    readOnly,\n    onSwatchClick,\n    ...rest\n  } = useFormControlProps({\n    isInvalid,\n    ...props\n  });\n  const onChangeStartRef = useCallbackRef(onChangeStartProp);\n  const onChangeEndRef = useCallbackRef(onChangeEndProp);\n  const {\n    supported: eyeDropperSupported,\n    onOpen\n  } = useEyeDropper();\n  const [value, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue != null ? defaultValue : fallbackValue,\n    onChange: onChangeProp\n  });\n  const resolvedValue = value != null ? value : \"#ffffff\";\n  const timeoutId = useRef(void 0);\n  const formatRef = useRef(format != null ? format : calcFormat(resolvedValue));\n  const isDraggingRef = useRef(false);\n  const [parsedValue, setParsedValue] = useState(convertHsva(resolvedValue, fallbackValue));\n  const {\n    h,\n    s,\n    v,\n    a\n  } = parsedValue;\n  const withAlpha = formatRef.current.endsWith(\"a\");\n  const isInteractive = !(disabled || readOnly);\n  const channels = useMemo(() => {\n    if (resolvedValue.startsWith(\"hsl\")) {\n      const {\n        h: h2,\n        s: s2,\n        l,\n        a: a2\n      } = convertHsla(resolvedValue, fallbackValue);\n      let channels2 = [{\n        label: \"H\",\n        space: \"h\",\n        value: Math.round(h2),\n        min: 0,\n        max: 360\n      }, {\n        label: \"S(%)\",\n        space: \"s\",\n        value: Math.round(s2 * 100),\n        min: 0,\n        max: 100\n      }, {\n        label: \"L(%)\",\n        space: \"l\",\n        value: Math.round(l * 100),\n        min: 0,\n        max: 100\n      }];\n      if (withAlpha) {\n        channels2 = [...channels2, {\n          label: \"A(%)\",\n          space: \"a\",\n          value: Math.round(a2 * 100),\n          min: 0,\n          max: 100\n        }];\n      }\n      return channels2;\n    } else {\n      const {\n        r,\n        g,\n        b,\n        a: a2\n      } = convertRgba(resolvedValue, fallbackValue);\n      let channels2 = [{\n        label: \"R\",\n        space: \"r\",\n        value: Math.round(r),\n        min: 0,\n        max: 255\n      }, {\n        label: \"G\",\n        space: \"g\",\n        value: Math.round(g),\n        min: 0,\n        max: 255\n      }, {\n        label: \"B\",\n        space: \"b\",\n        value: Math.round(b),\n        min: 0,\n        max: 255\n      }];\n      if (withAlpha) {\n        channels2 = [...channels2, {\n          label: \"A(%)\",\n          space: \"a\",\n          value: Math.round(a2 * 100),\n          min: 0,\n          max: 100\n        }];\n      }\n      return channels2;\n    }\n  }, [resolvedValue, withAlpha, fallbackValue]);\n  const onChange = useCallback(value2 => {\n    if (isString(value2)) {\n      setParsedValue(convertHsva(value2, fallbackValue));\n    } else {\n      setParsedValue(prev => ({\n        ...prev,\n        ...value2\n      }));\n    }\n  }, [fallbackValue]);\n  const onChangeStart = useCallback(value2 => {\n    window.clearTimeout(timeoutId.current);\n    isDraggingRef.current = true;\n    const {\n      h: h2,\n      s: s2,\n      v: v2,\n      a: a2\n    } = {\n      ...parsedValue,\n      ...value2\n    };\n    const nextValue = hsvTo([h2, s2, v2, a2], fallbackValue)(formatRef.current);\n    if (nextValue) onChangeStartRef(nextValue);\n  }, [formatRef, onChangeStartRef, fallbackValue, parsedValue]);\n  const onChangeEnd = useCallback(value2 => {\n    window.clearTimeout(timeoutId.current);\n    timeoutId.current = window.setTimeout(() => {\n      isDraggingRef.current = false;\n    }, 200);\n    let nextValue;\n    if (isString(value2)) {\n      nextValue = convertColor(value2, fallbackValue)(formatRef.current);\n    } else {\n      const {\n        h: h2,\n        s: s2,\n        v: v2,\n        a: a2\n      } = {\n        ...parsedValue,\n        ...value2\n      };\n      nextValue = hsvTo([h2, s2, v2, a2], fallbackValue)(formatRef.current);\n    }\n    if (nextValue) onChangeEndRef(nextValue);\n  }, [formatRef, onChangeEndRef, fallbackValue, parsedValue]);\n  const onChannelChange = useCallback((ev, space) => {\n    let n = Math.floor(parseFloat(ev.target.value));\n    if (isNaN(n)) n = 0;\n    if ([\"s\", \"l\", \"a\"].includes(space)) n = n / 100;\n    let nextValue;\n    if (resolvedValue.startsWith(\"hsl\")) {\n      const {\n        h: h2,\n        s: s2,\n        l,\n        a: a2\n      } = Object.assign(convertHsla(resolvedValue, fallbackValue), {\n        [space]: n\n      });\n      nextValue = hslaTo([h2, s2, l, a2], fallbackValue)(formatRef.current);\n    } else {\n      const {\n        r,\n        g,\n        b,\n        a: a2\n      } = Object.assign(convertRgba(resolvedValue, fallbackValue), {\n        [space]: n\n      });\n      nextValue = rgbaTo([r, g, b, a2], fallbackValue)(formatRef.current);\n    }\n    if (!nextValue) return;\n    onChange(nextValue);\n    onChangeEnd(nextValue);\n  }, [resolvedValue, onChange, onChangeEnd, formatRef, fallbackValue]);\n  const onEyeDropperClick = useCallback(async () => {\n    var _a;\n    try {\n      const {\n        sRGBHex\n      } = (_a = await onOpen()) != null ? _a : {};\n      if (!sRGBHex) return;\n      onChange(sRGBHex);\n      onChangeEnd(sRGBHex);\n    } catch {}\n  }, [onOpen, onChange, onChangeEnd]);\n  useUpdateEffect(() => {\n    const nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current);\n    if (nextValue) setValue(nextValue);\n  }, [h, s, v, a]);\n  useUpdateEffect(() => {\n    if (isDraggingRef.current) return;\n    if (valueProp) setParsedValue(convertHsva(valueProp, fallbackValue));\n  }, [valueProp]);\n  useUpdateEffect(() => {\n    if (!format || !value) return;\n    formatRef.current = format;\n    const nextValue = convertColor(value, fallbackValue)(format);\n    if (nextValue) setValue(nextValue);\n  }, [format]);\n  const getContainerProps = (props2 = {}, ref = null) => ({\n    ...props2,\n    ref,\n    ...omitObject(rest, [\"aria-readonly\"])\n  });\n  const getInputProps = useCallback((props2 = {}, ref = null) => ({\n    ...pickObject(rest, formControlProperties),\n    ...props2,\n    id,\n    ref,\n    type: \"hidden\",\n    name,\n    value: resolvedValue,\n    required,\n    disabled,\n    readOnly\n  }), [disabled, id, name, readOnly, required, rest, resolvedValue]);\n  const getSaturationSliderProps = useCallback((props2 = {}, ref = null) => ({\n    required,\n    disabled,\n    readOnly,\n    isInvalid,\n    ...props2,\n    ref,\n    value: [h, s, v],\n    onChange: handlerAll(props2.onChange, ([, s2, v2]) => onChange({\n      s: s2,\n      v: v2\n    })),\n    onChangeStart: handlerAll(props2.onChangeStart, ([, s2, v2]) => onChangeStart({\n      s: s2,\n      v: v2\n    })),\n    onChangeEnd: handlerAll(props2.onChangeEnd, ([, s2, v2]) => onChangeEnd({\n      s: s2,\n      v: v2\n    }))\n  }), [required, disabled, readOnly, isInvalid, h, s, v, onChange, onChangeStart, onChangeEnd]);\n  const getHueSliderProps = useCallback((props2 = {}, ref = null) => ({\n    required,\n    disabled,\n    readOnly,\n    isInvalid,\n    ...props2,\n    ref,\n    value: h,\n    onChange: handlerAll(props2.onChange, h2 => onChange({\n      h: h2\n    })),\n    onChangeStart: handlerAll(props2.onChangeStart, h2 => onChangeStart({\n      h: h2\n    })),\n    onChangeEnd: handlerAll(props2.onChangeEnd, h2 => onChangeEnd({\n      h: h2\n    }))\n  }), [required, disabled, readOnly, isInvalid, h, onChange, onChangeStart, onChangeEnd]);\n  const getAlphaSliderProps = useCallback((props2 = {}, ref = null) => ({\n    required,\n    disabled,\n    readOnly,\n    isInvalid,\n    ...props2,\n    ref,\n    value: a,\n    color: hsvTo([h, s, v, a], fallbackValue)(formatRef.current),\n    onChange: handlerAll(props2.onChange, a2 => onChange({\n      a: a2\n    })),\n    onChangeStart: handlerAll(props2.onChangeStart, a2 => onChangeStart({\n      a: a2\n    })),\n    onChangeEnd: handlerAll(props2.onChangeEnd, a2 => onChangeEnd({\n      a: a2\n    }))\n  }), [fallbackValue, required, disabled, readOnly, isInvalid, formatRef, h, s, v, a, onChange, onChangeStart, onChangeEnd]);\n  const getChannelProps = useCallback(({\n    space,\n    ...props2\n  }, ref = null) => {\n    return {\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props2,\n      ref,\n      type: \"number\",\n      step: 1,\n      onChange: handlerAll(props2.onChange, ev => onChannelChange(ev, space))\n    };\n  }, [required, disabled, readOnly, isInvalid, onChannelChange]);\n  const getEyeDropperProps = useCallback((props2 = {}, ref = null) => ({\n    disabled,\n    \"aria-label\": \"Pick a color\",\n    ...props2,\n    ref,\n    onClick: handlerAll(props2.onClick, onEyeDropperClick)\n  }), [disabled, onEyeDropperClick]);\n  const getSwatchProps = useCallback(({\n    color,\n    ...props2\n  } = {}, ref = null) => ({\n    \"aria-label\": `Select ${color} as the color`,\n    disabled,\n    readOnly,\n    ...props2,\n    ref,\n    color,\n    onClick: handlerAll(props2.onClick, () => {\n      if (!color) return;\n      onSwatchClick == null ? void 0 : onSwatchClick(color);\n      onChange(color);\n      onChangeEnd(color);\n    })\n  }), [disabled, readOnly, onSwatchClick, onChange, onChangeEnd]);\n  return {\n    value: resolvedValue,\n    onChange,\n    eyeDropperSupported,\n    withAlpha,\n    isInteractive,\n    disabled,\n    readOnly,\n    channels,\n    getContainerProps,\n    getInputProps,\n    getSaturationSliderProps,\n    getHueSliderProps,\n    getAlphaSliderProps,\n    getEyeDropperProps,\n    getChannelProps,\n    getSwatchProps\n  };\n};\nexport { ColorSelectorProvider, useColorSelectorContext, useColorSelector };","map":{"version":3,"names":["useFormControlProps","formControlProperties","useControllableState","useEyeDropper","calcFormat","convertColor","createContext","handlerAll","hsvTo","isString","parseToHsv","useCallbackRef","useUpdateEffect","omitObject","parseToRgba","parseToHsla","rgbaTo","hslaTo","pickObject","useCallback","useMemo","useRef","useState","convertHsla","value","fallback","_a","h","s","l","a","convertRgba","r","g","b","convertHsva","v","ColorSelectorProvider","useColorSelectorContext","name","errorMessage","useColorSelector","isInvalid","props","id","valueProp","defaultValue","fallbackValue","onChange","onChangeProp","onChangeStart","onChangeStartProp","onChangeEnd","onChangeEndProp","format","required","disabled","readOnly","onSwatchClick","rest","onChangeStartRef","onChangeEndRef","supported","eyeDropperSupported","onOpen","setValue","resolvedValue","timeoutId","formatRef","isDraggingRef","parsedValue","setParsedValue","withAlpha","current","endsWith","isInteractive","channels","startsWith","h2","s2","a2","channels2","label","space","Math","round","min","max","value2","prev","window","clearTimeout","v2","nextValue","setTimeout","onChannelChange","ev","n","floor","parseFloat","target","isNaN","includes","Object","assign","onEyeDropperClick","sRGBHex","getContainerProps","props2","ref","getInputProps","type","getSaturationSliderProps","getHueSliderProps","getAlphaSliderProps","color","getChannelProps","step","getEyeDropperProps","onClick","getSwatchProps"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\color-picker\\src\\use-color-selector.ts"],"sourcesContent":["import type {\n  CSSUIObject,\n  HTMLUIProps,\n  UIPropGetter,\n  ThemeProps,\n  RequiredUIPropGetter,\n} from \"@yamada-ui/core\"\nimport {\n  useFormControlProps,\n  type FormControlOptions,\n  formControlProperties,\n} from \"@yamada-ui/form-control\"\nimport type { InputProps } from \"@yamada-ui/input\"\nimport { useControllableState } from \"@yamada-ui/use-controllable-state\"\nimport { useEyeDropper } from \"@yamada-ui/use-eye-dropper\"\nimport type { ColorFormat, Dict, Merge } from \"@yamada-ui/utils\"\nimport {\n  calcFormat,\n  convertColor,\n  createContext,\n  handlerAll,\n  hsvTo,\n  isString,\n  parseToHsv,\n  useCallbackRef,\n  useUpdateEffect,\n  omitObject,\n  parseToRgba,\n  parseToHsla,\n  rgbaTo,\n  hslaTo,\n  pickObject,\n} from \"@yamada-ui/utils\"\nimport type { ChangeEvent } from \"react\"\nimport { useCallback, useMemo, useRef, useState } from \"react\"\nimport type { AlphaSliderProps } from \"./alpha-slider\"\nimport type { ColorSwatchProps } from \"./color-swatch\"\nimport type { HueSliderProps } from \"./hue-slider\"\nimport type { SaturationSliderProps } from \"./saturation-slider\"\n\ntype Space = keyof Hsla | keyof Rgba\ntype Hsla = { h: number; s: number; l: number; a: number }\ntype Rgba = { r: number; g: number; b: number; a: number }\ntype Hsva = { h: number; s: number; v: number; a: number }\ntype Channel = {\n  label: string\n  space: Space\n  value: number\n  min: number\n  max: number\n}\n\nconst convertHsla = (value: string, fallback?: string): Hsla => {\n  let [h, s, l, a] = parseToHsla(value, fallback) ?? [0, 0, 1, 1]\n\n  if (a > 1) a = 1\n\n  return { h, s, l, a }\n}\n\nconst convertRgba = (value: string, fallback?: string): Rgba => {\n  let [r, g, b, a] = parseToRgba(value, fallback) ?? [255, 255, 255, 1]\n\n  if (r > 255) r = 255\n  if (g > 255) g = 255\n  if (b > 255) b = 255\n  if (a > 1) a = 1\n\n  return { r, g, b, a }\n}\n\nconst convertHsva = (value: string, fallback?: string): Hsva => {\n  const [h, s, v, a] = parseToHsv(value, fallback)\n\n  return { h, s, v, a }\n}\n\ntype ColorSelectorContext = {\n  value: string\n  onChange: (value: string | Partial<Hsva>) => void\n  eyeDropperSupported: boolean\n  withAlpha: boolean\n  isInteractive: boolean\n  disabled?: boolean\n  readOnly?: boolean\n  channels: Channel[]\n  size?: ThemeProps<\"ColorSelector\">[\"size\"]\n  getHueSliderProps: UIPropGetter<\"input\", HueSliderProps, HueSliderProps>\n  getAlphaSliderProps: UIPropGetter<\"input\", AlphaSliderProps, AlphaSliderProps>\n  getEyeDropperProps: UIPropGetter<\"button\">\n  getChannelProps: RequiredUIPropGetter<\n    \"input\",\n    Merge<InputProps, { space: Space }>,\n    InputProps\n  >\n  getSwatchProps: UIPropGetter<\"div\", ColorSwatchProps, ColorSwatchProps>\n  styles: Record<string, CSSUIObject>\n}\n\nexport const [ColorSelectorProvider, useColorSelectorContext] =\n  createContext<ColorSelectorContext>({\n    name: \"ColorSelectorContext\",\n    errorMessage: `useColorSelectorContext returned is 'undefined'. Seems you forgot to wrap the components in \"<ColorSelector />\"`,\n  })\n\ntype UseColorSelectorOptions = {\n  /**\n   * The base `id` to use for the color selector.\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms.\n   */\n  name?: string\n  /**\n   * The value of the color selector.\n   */\n  value?: string\n  /**\n   * The initial value of the color selector.\n   */\n  defaultValue?: string\n  /**\n   * The fallback value returned when color determination fails.\n   */\n  fallbackValue?: string\n  /**\n   * Function called whenever the color selector value changes.\n   */\n  onChange?: (value: string) => void\n  /**\n   * Function called when the user starts selecting a new value.\n   */\n  onChangeStart?: (value: string) => void\n  /**\n   * Function called when the user is done selecting a new value.\n   */\n  onChangeEnd?: (value: string) => void\n  /**\n   * Color format. For example, `hex`, `rgba`, etc.\n   *\n   * @default \"hexa\"\n   */\n  format?: ColorFormat\n  /**\n   * Function called whenever the color swatch click.\n   */\n  onSwatchClick?: (value: string) => void\n}\n\nexport type UseColorSelectorBaseProps = UseColorSelectorOptions &\n  FormControlOptions\n\nexport type UseColorSelectorProps = Omit<\n  HTMLUIProps<\"div\">,\n  \"defaultValue\" | \"onChange\" | \"children\"\n> &\n  UseColorSelectorBaseProps\n\nexport const useColorSelector = ({\n  isInvalid,\n  ...props\n}: UseColorSelectorProps) => {\n  let {\n    id,\n    name,\n    value: valueProp,\n    defaultValue,\n    fallbackValue,\n    onChange: onChangeProp,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    format,\n    required,\n    disabled,\n    readOnly,\n    onSwatchClick,\n    ...rest\n  } = useFormControlProps({ isInvalid, ...props })\n\n  const onChangeStartRef = useCallbackRef(onChangeStartProp)\n  const onChangeEndRef = useCallbackRef(onChangeEndProp)\n  const { supported: eyeDropperSupported, onOpen } = useEyeDropper()\n  const [value, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? fallbackValue,\n    onChange: onChangeProp,\n  })\n  const resolvedValue = value ?? \"#ffffff\"\n  const timeoutId = useRef<any>(undefined)\n  const formatRef = useRef<ColorFormat>(format ?? calcFormat(resolvedValue))\n  const isDraggingRef = useRef<boolean>(false)\n  const [parsedValue, setParsedValue] = useState<Hsva>(\n    convertHsva(resolvedValue, fallbackValue),\n  )\n  const { h, s, v, a } = parsedValue\n  const withAlpha = formatRef.current.endsWith(\"a\")\n  const isInteractive = !(disabled || readOnly)\n\n  const channels: Channel[] = useMemo(() => {\n    if (resolvedValue.startsWith(\"hsl\")) {\n      const { h, s, l, a } = convertHsla(resolvedValue, fallbackValue)\n\n      let channels: Channel[] = [\n        { label: \"H\", space: \"h\", value: Math.round(h), min: 0, max: 360 },\n        {\n          label: \"S(%)\",\n          space: \"s\",\n          value: Math.round(s * 100),\n          min: 0,\n          max: 100,\n        },\n        {\n          label: \"L(%)\",\n          space: \"l\",\n          value: Math.round(l * 100),\n          min: 0,\n          max: 100,\n        },\n      ]\n\n      if (withAlpha) {\n        channels = [\n          ...channels,\n          {\n            label: \"A(%)\",\n            space: \"a\",\n            value: Math.round(a * 100),\n            min: 0,\n            max: 100,\n          },\n        ]\n      }\n\n      return channels\n    } else {\n      const { r, g, b, a } = convertRgba(resolvedValue, fallbackValue)\n\n      let channels: Channel[] = [\n        { label: \"R\", space: \"r\", value: Math.round(r), min: 0, max: 255 },\n        { label: \"G\", space: \"g\", value: Math.round(g), min: 0, max: 255 },\n        { label: \"B\", space: \"b\", value: Math.round(b), min: 0, max: 255 },\n      ]\n\n      if (withAlpha) {\n        channels = [\n          ...channels,\n          {\n            label: \"A(%)\",\n            space: \"a\",\n            value: Math.round(a * 100),\n            min: 0,\n            max: 100,\n          },\n        ]\n      }\n\n      return channels\n    }\n  }, [resolvedValue, withAlpha, fallbackValue])\n\n  const onChange = useCallback(\n    (value: string | Partial<Hsva>) => {\n      if (isString(value)) {\n        setParsedValue(convertHsva(value, fallbackValue))\n      } else {\n        setParsedValue((prev) => ({ ...prev, ...value }))\n      }\n    },\n    [fallbackValue],\n  )\n\n  const onChangeStart = useCallback(\n    (value: Partial<Hsva>) => {\n      window.clearTimeout(timeoutId.current)\n\n      isDraggingRef.current = true\n\n      const { h, s, v, a } = { ...parsedValue, ...value }\n\n      const nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n\n      if (nextValue) onChangeStartRef(nextValue)\n    },\n    [formatRef, onChangeStartRef, fallbackValue, parsedValue],\n  )\n\n  const onChangeEnd = useCallback(\n    (value: string | Partial<Hsva>) => {\n      window.clearTimeout(timeoutId.current)\n\n      timeoutId.current = window.setTimeout(() => {\n        isDraggingRef.current = false\n      }, 200)\n\n      let nextValue: string | undefined\n\n      if (isString(value)) {\n        nextValue = convertColor(value, fallbackValue)(formatRef.current)\n      } else {\n        const { h, s, v, a } = { ...parsedValue, ...value }\n\n        nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n      }\n\n      if (nextValue) onChangeEndRef(nextValue)\n    },\n    [formatRef, onChangeEndRef, fallbackValue, parsedValue],\n  )\n\n  const onChannelChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>, space: Space) => {\n      let n = Math.floor(parseFloat(ev.target.value))\n\n      if (isNaN(n)) n = 0\n\n      if ([\"s\", \"l\", \"a\"].includes(space)) n = n / 100\n\n      let nextValue: string | undefined\n\n      if (resolvedValue.startsWith(\"hsl\")) {\n        const { h, s, l, a } = Object.assign(\n          convertHsla(resolvedValue, fallbackValue),\n          { [space]: n },\n        )\n\n        nextValue = hslaTo([h, s, l, a], fallbackValue)(formatRef.current)\n      } else {\n        const { r, g, b, a } = Object.assign(\n          convertRgba(resolvedValue, fallbackValue),\n          { [space]: n },\n        )\n\n        nextValue = rgbaTo([r, g, b, a], fallbackValue)(formatRef.current)\n      }\n\n      if (!nextValue) return\n\n      onChange(nextValue)\n      onChangeEnd(nextValue)\n    },\n    [resolvedValue, onChange, onChangeEnd, formatRef, fallbackValue],\n  )\n\n  const onEyeDropperClick = useCallback(async () => {\n    try {\n      const { sRGBHex } = (await onOpen()) ?? {}\n\n      if (!sRGBHex) return\n\n      onChange(sRGBHex)\n      onChangeEnd(sRGBHex)\n    } catch {}\n  }, [onOpen, onChange, onChangeEnd])\n\n  useUpdateEffect(() => {\n    const nextValue = hsvTo([h, s, v, a], fallbackValue)(formatRef.current)\n\n    if (nextValue) setValue(nextValue)\n  }, [h, s, v, a])\n\n  useUpdateEffect(() => {\n    if (isDraggingRef.current) return\n\n    if (valueProp) setParsedValue(convertHsva(valueProp, fallbackValue))\n  }, [valueProp])\n\n  useUpdateEffect(() => {\n    if (!format || !value) return\n\n    formatRef.current = format\n\n    const nextValue = convertColor(value, fallbackValue)(format)\n\n    if (nextValue) setValue(nextValue)\n  }, [format])\n\n  const getContainerProps: UIPropGetter = (props = {}, ref = null) => ({\n    ...props,\n    ref,\n    ...omitObject(rest, [\"aria-readonly\"]),\n  })\n\n  const getInputProps: UIPropGetter<\"input\"> = useCallback(\n    (props = {}, ref = null) => ({\n      ...pickObject(rest, formControlProperties),\n      ...props,\n      id,\n      ref,\n      type: \"hidden\",\n      name,\n      value: resolvedValue,\n      required,\n      disabled,\n      readOnly,\n    }),\n    [disabled, id, name, readOnly, required, rest, resolvedValue],\n  )\n\n  const getSaturationSliderProps: UIPropGetter<\n    \"input\",\n    SaturationSliderProps,\n    SaturationSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: [h, s, v],\n      onChange: handlerAll(props.onChange, ([, s, v]) => onChange({ s, v })),\n      onChangeStart: handlerAll(props.onChangeStart, ([, s, v]) =>\n        onChangeStart({ s, v }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, ([, s, v]) =>\n        onChangeEnd({ s, v }),\n      ),\n    }),\n    [\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      h,\n      s,\n      v,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getHueSliderProps: UIPropGetter<\n    \"input\",\n    HueSliderProps,\n    HueSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: h,\n      onChange: handlerAll(props.onChange, (h) => onChange({ h })),\n      onChangeStart: handlerAll(props.onChangeStart, (h) =>\n        onChangeStart({ h }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, (h) => onChangeEnd({ h })),\n    }),\n    [\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      h,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getAlphaSliderProps: UIPropGetter<\n    \"input\",\n    AlphaSliderProps,\n    AlphaSliderProps\n  > = useCallback(\n    (props = {}, ref = null) => ({\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      ...props,\n      ref,\n      value: a,\n      color: hsvTo([h, s, v, a], fallbackValue)(formatRef.current),\n      onChange: handlerAll(props.onChange, (a) => onChange({ a })),\n      onChangeStart: handlerAll(props.onChangeStart, (a) =>\n        onChangeStart({ a }),\n      ),\n      onChangeEnd: handlerAll(props.onChangeEnd, (a) => onChangeEnd({ a })),\n    }),\n    [\n      fallbackValue,\n      required,\n      disabled,\n      readOnly,\n      isInvalid,\n      formatRef,\n      h,\n      s,\n      v,\n      a,\n      onChange,\n      onChangeStart,\n      onChangeEnd,\n    ],\n  )\n\n  const getChannelProps: RequiredUIPropGetter<\n    \"input\",\n    Merge<InputProps, { space: Space }>,\n    InputProps\n  > = useCallback(\n    ({ space, ...props }, ref = null) => {\n      return {\n        required,\n        disabled,\n        readOnly,\n        isInvalid,\n        ...props,\n        ref,\n        type: \"number\",\n        step: 1,\n        onChange: handlerAll(props.onChange, (ev) =>\n          onChannelChange(ev, space),\n        ),\n      } as Dict\n    },\n    [required, disabled, readOnly, isInvalid, onChannelChange],\n  )\n\n  const getEyeDropperProps: UIPropGetter<\"button\"> = useCallback(\n    (props = {}, ref = null) => ({\n      disabled,\n      \"aria-label\": \"Pick a color\",\n      ...props,\n      ref,\n      onClick: handlerAll(props.onClick, onEyeDropperClick),\n    }),\n    [disabled, onEyeDropperClick],\n  )\n\n  const getSwatchProps: UIPropGetter<\n    \"div\",\n    ColorSwatchProps,\n    ColorSwatchProps\n  > = useCallback(\n    ({ color, ...props } = {}, ref = null) => ({\n      \"aria-label\": `Select ${color} as the color`,\n      disabled,\n      readOnly,\n      ...props,\n      ref,\n      color,\n      onClick: handlerAll(props.onClick, () => {\n        if (!color) return\n\n        onSwatchClick?.(color)\n        onChange(color)\n        onChangeEnd(color)\n      }),\n    }),\n    [disabled, readOnly, onSwatchClick, onChange, onChangeEnd],\n  )\n\n  return {\n    value: resolvedValue,\n    onChange,\n    eyeDropperSupported,\n    withAlpha,\n    isInteractive,\n    disabled,\n    readOnly,\n    channels,\n    getContainerProps,\n    getInputProps,\n    getSaturationSliderProps,\n    getHueSliderProps,\n    getAlphaSliderProps,\n    getEyeDropperProps,\n    getChannelProps,\n    getSwatchProps,\n  }\n}\n\nexport type UseColorSelectorReturn = ReturnType<typeof useColorSelector>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}