{"ast":null,"code":"\"use client\";\n\n// src/index.ts\nimport { assignRef, isElement, useCallbackRef, useUnmountEffect } from \"@yamada-ui/utils\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nvar isScrollable = (el, isVertical) => {\n  const style = getComputedStyle(el);\n  if ([\"auto\", \"scroll\", \"overlay\"].includes(style.overflow)) return true;\n  if (isVertical) {\n    return [\"auto\", \"scroll\", \"overlay\"].includes(style.overflowY);\n  } else {\n    return [\"auto\", \"scroll\", \"overlay\"].includes(style.overflowX);\n  }\n};\nvar onScroll = ({\n  root,\n  isVertical,\n  isReverse,\n  behavior,\n  position\n}) => {\n  let options;\n  const el = isElement(root) && isScrollable(root, isVertical) ? root : document.body;\n  if (isVertical) {\n    options = {\n      top: position != null ? position : isReverse ? el.scrollHeight : 0,\n      behavior\n    };\n  } else {\n    options = {\n      left: position != null ? position : isReverse ? el.scrollWidth : 0,\n      behavior\n    };\n  }\n  if (el === document.body) {\n    window.scrollTo(options);\n  } else {\n    el.scrollTo(options);\n  }\n};\nvar getScrollPosition = (root, isVertical) => {\n  const el = isElement(root) && isScrollable(root, isVertical) ? root : document.body;\n  if (isVertical) {\n    return el.scrollHeight - el.scrollTop;\n  } else {\n    return el.scrollWidth - el.scrollLeft;\n  }\n};\nvar useInfiniteScroll = ({\n  orientation = \"vertical\",\n  rootRef,\n  rootMargin,\n  threshold,\n  initialLoad = false,\n  startIndex = initialLoad ? 0 : 1,\n  onLoad: onLoadProp,\n  resetRef,\n  indexRef: indexRefProp,\n  isDisabled = false,\n  isReverse = false,\n  behavior\n} = {}) => {\n  const ref = useRef(null);\n  const indexRef = useRef(startIndex);\n  const processingRef = useRef(false);\n  const observerRef = useRef(void 0);\n  const isMountedRef = useRef(false);\n  const prevScrollPosition = useRef(0);\n  const [isFinish, setIsFinish] = useState(false);\n  const onLoad = useCallbackRef(onLoadProp);\n  const isVertical = orientation === \"vertical\";\n  const options = useMemo(() => {\n    const root = rootRef == null ? void 0 : rootRef.current;\n    return {\n      root,\n      rootMargin,\n      threshold\n    };\n  }, [rootMargin, rootRef, threshold]);\n  const onReset = useCallback((index = 1, runScroll = true) => {\n    indexRef.current = index;\n    setIsFinish(false);\n    if (runScroll) {\n      const root = rootRef == null ? void 0 : rootRef.current;\n      onScroll({\n        root,\n        isVertical,\n        isReverse,\n        behavior\n      });\n    }\n    if (isDisabled) return;\n    setTimeout(() => {\n      const observer = observerRef.current;\n      const el = ref.current;\n      if (el) observer == null ? void 0 : observer.observe(el);\n    });\n  }, [isDisabled, isReverse, rootRef, isVertical, behavior]);\n  const onFinish = useCallback(() => {\n    const observer = observerRef.current;\n    const el = ref.current;\n    if (el) observer == null ? void 0 : observer.unobserve(el);\n    setIsFinish(true);\n  }, []);\n  const createObserver = useCallback(() => {\n    const observer = new IntersectionObserver(async ([entry]) => {\n      if (!entry.isIntersecting || processingRef.current) return;\n      const props = {\n        index: indexRef.current,\n        entry,\n        finish: onFinish\n      };\n      processingRef.current = true;\n      const root = rootRef == null ? void 0 : rootRef.current;\n      if (isReverse) {\n        prevScrollPosition.current = getScrollPosition(root, isVertical);\n      }\n      await (onLoad == null ? void 0 : onLoad(props));\n      if (isReverse) {\n        const position = prevScrollPosition.current;\n        onScroll({\n          root,\n          isVertical,\n          position\n        });\n      }\n      indexRef.current += 1;\n      processingRef.current = false;\n    }, options);\n    return observer;\n  }, [onFinish, onLoad, options, rootRef, isReverse, isVertical]);\n  useEffect(() => {\n    const setupObserver = async () => {\n      const el = ref.current;\n      const isMounted = isMountedRef.current;\n      const index = indexRef.current;\n      if (initialLoad && !isMounted) {\n        processingRef.current = true;\n        await onLoad({\n          index,\n          finish: onFinish\n        });\n        indexRef.current += 1;\n        processingRef.current = false;\n      }\n      if (isDisabled) return;\n      observerRef.current = createObserver();\n      const observer = observerRef.current;\n      if (isReverse && !isMounted) {\n        const root = rootRef == null ? void 0 : rootRef.current;\n        onScroll({\n          root,\n          isVertical,\n          isReverse\n        });\n        isMountedRef.current = true;\n      }\n      setTimeout(() => {\n        if (el) observer.observe(el);\n      });\n      return () => {\n        if (el) observer.unobserve(el);\n      };\n    };\n    setupObserver();\n  }, [createObserver, initialLoad, isDisabled, isReverse, isVertical, onFinish, onLoad, rootRef]);\n  useUnmountEffect(() => isMountedRef.current = false);\n  assignRef(resetRef, onReset);\n  assignRef(indexRefProp, index => indexRef.current = index);\n  return {\n    ref,\n    isFinish\n  };\n};\nexport { useInfiniteScroll };","map":{"version":3,"names":["assignRef","isElement","useCallbackRef","useUnmountEffect","useCallback","useEffect","useMemo","useRef","useState","isScrollable","el","isVertical","style","getComputedStyle","includes","overflow","overflowY","overflowX","onScroll","root","isReverse","behavior","position","options","document","body","top","scrollHeight","left","scrollWidth","window","scrollTo","getScrollPosition","scrollTop","scrollLeft","useInfiniteScroll","orientation","rootRef","rootMargin","threshold","initialLoad","startIndex","onLoad","onLoadProp","resetRef","indexRef","indexRefProp","isDisabled","ref","processingRef","observerRef","isMountedRef","prevScrollPosition","isFinish","setIsFinish","current","onReset","index","runScroll","setTimeout","observer","observe","onFinish","unobserve","createObserver","IntersectionObserver","entry","isIntersecting","props","finish","setupObserver","isMounted"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\use-infinite-scroll\\src\\index.ts"],"sourcesContent":["import {\n  assignRef,\n  isElement,\n  useCallbackRef,\n  useUnmountEffect,\n} from \"@yamada-ui/utils\"\nimport type { RefObject } from \"react\"\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\"\n\nconst isScrollable = (el: HTMLElement, isVertical: boolean) => {\n  const style = getComputedStyle(el)\n\n  if ([\"auto\", \"scroll\", \"overlay\"].includes(style.overflow)) return true\n\n  if (isVertical) {\n    return [\"auto\", \"scroll\", \"overlay\"].includes(style.overflowY)\n  } else {\n    return [\"auto\", \"scroll\", \"overlay\"].includes(style.overflowX)\n  }\n}\n\nconst onScroll = ({\n  root,\n  isVertical,\n  isReverse,\n  behavior,\n  position,\n}: {\n  root: HTMLElement | null | undefined\n  isVertical: boolean\n  isReverse?: boolean\n  behavior?: ScrollBehavior\n  position?: number\n}) => {\n  let options: ScrollToOptions\n  const el =\n    isElement(root) && isScrollable(root, isVertical) ? root : document.body\n\n  if (isVertical) {\n    options = { top: position ?? (isReverse ? el.scrollHeight : 0), behavior }\n  } else {\n    options = { left: position ?? (isReverse ? el.scrollWidth : 0), behavior }\n  }\n\n  if (el === document.body) {\n    window.scrollTo(options)\n  } else {\n    el.scrollTo(options)\n  }\n}\n\nconst getScrollPosition = (\n  root: HTMLElement | null | undefined,\n  isVertical: boolean,\n) => {\n  const el =\n    isElement(root) && isScrollable(root, isVertical) ? root : document.body\n\n  if (isVertical) {\n    return el.scrollHeight - el.scrollTop\n  } else {\n    return el.scrollWidth - el.scrollLeft\n  }\n}\n\nexport type UseInfiniteScrollProps = Omit<IntersectionObserverInit, \"root\"> & {\n  /**\n   * The orientation of the infinite scroll.\n   *\n   * @default 'vertical'\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * The element that is used as the viewport for checking visibility of the target.\n   * Defaults to the browser viewport if not specified or if `null`.\n   */\n  rootRef?: RefObject<HTMLElement>\n  /**\n   * Margin around the root. Can have values similar to the CSS margin property,\n   * e.g. \"10px 20px 30px 40px\" (top, right, bottom, left).\n   */\n  rootMargin?: string\n  /**\n   * Either a single number or an array of numbers which indicate at what percentage of the target's visibility the observer's callback should be executed.\n   */\n  threshold?: number | number[]\n  /**\n   * If set the `onLoad` function will start from the given index.\n   * If `initialLoad` is `true`, index starts from `0`.\n   *\n   * @default 1\n   */\n  startIndex?: number\n  /**\n   * The callback invoked when trigger is intersect.\n   */\n  onLoad?: ({\n    index,\n    entry,\n    finish,\n  }: {\n    index: number\n    finish: () => void\n    entry?: IntersectionObserverEntry\n  }) => Promise<void>\n  /**\n   * Ref to a reset function.\n   */\n  resetRef?: RefObject<(index?: number, runScroll?: boolean) => void>\n  /**\n   * Ref to a reset index function.\n   */\n  indexRef?: RefObject<(index: number) => void>\n  /**\n   * If `true`, the infinite scroll is disabled.\n   *\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   *  If `true`, reverse direction.\n   *\n   * @default false\n   */\n  isReverse?: boolean\n  /**\n   * If `true`, invoke `onLoad` function for the first time.\n   *\n   * @default false\n   */\n  initialLoad?: boolean\n  /**\n   * Determines whether scrolling is instant or animates smoothly.\n   */\n  behavior?: ScrollBehavior\n}\n\n/**\n * `useInfiniteScroll` is a custom hook for providing infinite scroll functionality.\n *\n * @see Docs https://yamada-ui.com/hooks/use-infinite-scroll\n */\nexport const useInfiniteScroll = <T extends HTMLElement = HTMLDivElement>({\n  orientation = \"vertical\",\n  rootRef,\n  rootMargin,\n  threshold,\n  initialLoad = false,\n  startIndex = initialLoad ? 0 : 1,\n  onLoad: onLoadProp,\n  resetRef,\n  indexRef: indexRefProp,\n  isDisabled = false,\n  isReverse = false,\n  behavior,\n}: UseInfiniteScrollProps = {}) => {\n  const ref = useRef<T>(null)\n  const indexRef = useRef<number>(startIndex)\n  const processingRef = useRef<boolean>(false)\n  const observerRef = useRef<IntersectionObserver | undefined>(undefined)\n  const isMountedRef = useRef<boolean>(false)\n  const prevScrollPosition = useRef<number>(0)\n  const [isFinish, setIsFinish] = useState<boolean>(false)\n  const onLoad = useCallbackRef(onLoadProp)\n  const isVertical = orientation === \"vertical\"\n  const options: IntersectionObserverInit = useMemo(() => {\n    const root = rootRef?.current\n\n    return { root, rootMargin, threshold }\n  }, [rootMargin, rootRef, threshold])\n\n  const onReset = useCallback(\n    (index: number = 1, runScroll: boolean = true) => {\n      indexRef.current = index\n\n      setIsFinish(false)\n\n      if (runScroll) {\n        const root = rootRef?.current\n\n        onScroll({ root, isVertical, isReverse, behavior })\n      }\n\n      if (isDisabled) return\n\n      setTimeout(() => {\n        const observer = observerRef.current\n        const el = ref.current\n\n        if (el) observer?.observe(el)\n      })\n    },\n    [isDisabled, isReverse, rootRef, isVertical, behavior],\n  )\n\n  const onFinish = useCallback(() => {\n    const observer = observerRef.current\n    const el = ref.current\n\n    if (el) observer?.unobserve(el)\n\n    setIsFinish(true)\n  }, [])\n\n  const createObserver = useCallback(() => {\n    const observer = new IntersectionObserver(async ([entry]) => {\n      if (!entry.isIntersecting || processingRef.current) return\n\n      const props = { index: indexRef.current, entry, finish: onFinish }\n\n      processingRef.current = true\n\n      const root = rootRef?.current\n\n      if (isReverse) {\n        prevScrollPosition.current = getScrollPosition(root, isVertical)\n      }\n\n      await onLoad?.(props)\n\n      if (isReverse) {\n        const position = prevScrollPosition.current\n\n        onScroll({ root, isVertical, position })\n      }\n\n      indexRef.current += 1\n      processingRef.current = false\n    }, options)\n\n    return observer\n  }, [onFinish, onLoad, options, rootRef, isReverse, isVertical])\n\n  useEffect(() => {\n    const setupObserver = async () => {\n      const el = ref.current\n      const isMounted = isMountedRef.current\n      const index = indexRef.current\n\n      if (initialLoad && !isMounted) {\n        processingRef.current = true\n\n        await onLoad({ index, finish: onFinish })\n\n        indexRef.current += 1\n        processingRef.current = false\n      }\n\n      if (isDisabled) return\n\n      observerRef.current = createObserver()\n\n      const observer = observerRef.current\n\n      if (isReverse && !isMounted) {\n        const root = rootRef?.current\n\n        onScroll({ root, isVertical, isReverse })\n\n        isMountedRef.current = true\n      }\n\n      setTimeout(() => {\n        if (el) observer.observe(el)\n      })\n\n      return () => {\n        if (el) observer.unobserve(el)\n      }\n    }\n\n    setupObserver()\n  }, [\n    createObserver,\n    initialLoad,\n    isDisabled,\n    isReverse,\n    isVertical,\n    onFinish,\n    onLoad,\n    rootRef,\n  ])\n\n  useUnmountEffect(() => (isMountedRef.current = false))\n\n  assignRef(resetRef, onReset)\n  assignRef(indexRefProp, (index) => (indexRef.current = index))\n\n  return { ref, isFinish }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}