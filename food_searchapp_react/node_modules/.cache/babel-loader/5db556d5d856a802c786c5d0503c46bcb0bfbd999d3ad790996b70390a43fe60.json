{"ast":null,"code":"\"use client\";\n\n// src/use-autosize.ts\nimport { pickObject } from \"@yamada-ui/utils\";\nimport { useRef } from \"react\";\nvar useAutosize = (ref, maxRows, minRows) => {\n  const valueRef = useRef();\n  const resizeTextarea = () => {\n    const el = ref.current;\n    if (!el) return;\n    let {\n      value,\n      placeholder\n    } = el;\n    if (value === valueRef.current) return;else valueRef.current = value;\n    value != null ? value : value = placeholder != null ? placeholder : \"x\";\n    const nodeSizeData = getSizingData(el);\n    if (!nodeSizeData) return;\n    const rows = calcRows(el, nodeSizeData, value, maxRows, minRows);\n    el.rows = rows;\n  };\n  return resizeTextarea;\n};\nvar SIZING_STYLE = [\"borderBottomWidth\", \"borderLeftWidth\", \"borderRightWidth\", \"borderTopWidth\", \"boxSizing\", \"fontFamily\", \"fontSize\", \"fontStyle\", \"fontWeight\", \"letterSpacing\", \"lineHeight\", \"paddingBottom\", \"paddingLeft\", \"paddingRight\", \"paddingTop\",\n// non-standard\n\"tabSize\", \"textIndent\",\n// non-standard\n\"textRendering\", \"textTransform\", \"width\", \"wordBreak\"];\nvar getSizingData = el => {\n  const style = window == null ? void 0 : window.getComputedStyle(el);\n  if (style == null) return null;\n  const sizingStyle = pickObject(style, SIZING_STYLE);\n  const {\n    boxSizing\n  } = sizingStyle;\n  if (boxSizing === \"\") return null;\n  const paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop);\n  const borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);\n  const singleRowHeight = parseFloat(sizingStyle.lineHeight);\n  return {\n    sizingStyle,\n    paddingSize,\n    borderSize,\n    singleRowHeight\n  };\n};\nvar calcRows = (el, sizingData, value, maxRows, minRows) => {\n  const clone = el.cloneNode();\n  Object.assign(clone.style, sizingData.sizingStyle);\n  forceHiddenStyles(clone);\n  clone.value = value;\n  document.body.appendChild(clone);\n  let rows;\n  if (clone.scrollHeight) {\n    const rowHeight = sizingData.singleRowHeight;\n    rows = Math.min(maxRows, Math.max(minRows, Math.floor(clone.scrollHeight / rowHeight)));\n  } else {\n    const lineBreaks = (value.match(/\\n/g) || []).length;\n    rows = Math.min(maxRows, Math.max(minRows, lineBreaks + 1));\n  }\n  document.body.removeChild(clone);\n  return rows;\n};\nvar HIDDEN_TEXTAREA_STYLE = {\n  \"min-height\": \"0\",\n  \"max-height\": \"none\",\n  height: \"0\",\n  visibility: \"hidden\",\n  overflow: \"hidden\",\n  position: \"absolute\",\n  \"z-index\": \"-1000\",\n  top: \"0\",\n  right: \"0\"\n};\nvar forceHiddenStyles = el => {\n  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(key => {\n    el.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], \"important\");\n  });\n};\nvar use_autosize_default = useAutosize;\nexport { use_autosize_default };","map":{"version":3,"names":["pickObject","useRef","useAutosize","ref","maxRows","minRows","valueRef","resizeTextarea","el","current","value","placeholder","nodeSizeData","getSizingData","rows","calcRows","SIZING_STYLE","style","window","getComputedStyle","sizingStyle","boxSizing","paddingSize","parseFloat","paddingBottom","paddingTop","borderSize","borderBottomWidth","borderTopWidth","singleRowHeight","lineHeight","sizingData","clone","cloneNode","Object","assign","forceHiddenStyles","document","body","appendChild","scrollHeight","rowHeight","Math","min","max","floor","lineBreaks","match","length","removeChild","HIDDEN_TEXTAREA_STYLE","height","visibility","overflow","position","top","right","keys","forEach","key","setProperty","use_autosize_default"],"sources":["C:\\チーム開発\\Food_searchApp\\food_searchapp_react\\node_modules\\@yamada-ui\\textarea\\src\\use-autosize.ts"],"sourcesContent":["import { pickObject } from \"@yamada-ui/utils\"\nimport type { RefObject } from \"react\"\nimport { useRef } from \"react\"\n\nconst useAutosize = (\n  ref: RefObject<HTMLTextAreaElement>,\n  maxRows: number,\n  minRows: number,\n) => {\n  const valueRef = useRef<string>()\n\n  const resizeTextarea = () => {\n    const el = ref.current\n    if (!el) return\n\n    let { value, placeholder } = el\n    if (value === valueRef.current) return\n    else valueRef.current = value\n\n    value ??= placeholder ?? \"x\"\n\n    const nodeSizeData = getSizingData(el)\n\n    if (!nodeSizeData) return\n\n    const rows = calcRows(el, nodeSizeData, value, maxRows, minRows)\n\n    el.rows = rows\n  }\n\n  return resizeTextarea\n}\n\nconst SIZING_STYLE = [\n  \"borderBottomWidth\",\n  \"borderLeftWidth\",\n  \"borderRightWidth\",\n  \"borderTopWidth\",\n  \"boxSizing\",\n  \"fontFamily\",\n  \"fontSize\",\n  \"fontStyle\",\n  \"fontWeight\",\n  \"letterSpacing\",\n  \"lineHeight\",\n  \"paddingBottom\",\n  \"paddingLeft\",\n  \"paddingRight\",\n  \"paddingTop\",\n  // non-standard\n  \"tabSize\",\n  \"textIndent\",\n  // non-standard\n  \"textRendering\",\n  \"textTransform\",\n  \"width\",\n  \"wordBreak\",\n] as const\n\ntype SizingProps = Extract<\n  (typeof SIZING_STYLE)[number],\n  keyof CSSStyleDeclaration\n>\n\ntype SizingStyle = Pick<CSSStyleDeclaration, SizingProps>\n\ntype SizingData = {\n  sizingStyle: SizingStyle\n  paddingSize: number\n  borderSize: number\n  singleRowHeight: number\n}\n\nconst getSizingData = (el: HTMLElement): SizingData | null => {\n  const style = window?.getComputedStyle(el)\n\n  if (style == null) return null\n\n  const sizingStyle = pickObject(\n    style,\n    SIZING_STYLE as unknown as SizingProps[],\n  )\n  const { boxSizing } = sizingStyle\n\n  if (boxSizing === \"\") return null\n\n  const paddingSize =\n    parseFloat(sizingStyle.paddingBottom!) + parseFloat(sizingStyle.paddingTop!)\n\n  const borderSize =\n    parseFloat(sizingStyle.borderBottomWidth!) +\n    parseFloat(sizingStyle.borderTopWidth!)\n\n  const singleRowHeight = parseFloat(sizingStyle.lineHeight!)\n\n  return {\n    sizingStyle,\n    paddingSize,\n    borderSize,\n    singleRowHeight,\n  }\n}\n\nconst calcRows = (\n  el: HTMLTextAreaElement,\n  sizingData: SizingData,\n  value: string,\n  maxRows: number,\n  minRows: number,\n) => {\n  const clone = el.cloneNode() as HTMLTextAreaElement\n  Object.assign(clone.style, sizingData.sizingStyle)\n  forceHiddenStyles(clone)\n\n  clone.value = value\n  document.body.appendChild(clone)\n\n  let rows\n  if (clone.scrollHeight) {\n    const rowHeight = sizingData.singleRowHeight\n    rows = Math.min(\n      maxRows,\n      Math.max(minRows, Math.floor(clone.scrollHeight / rowHeight)),\n    )\n  } else {\n    const lineBreaks = (value.match(/\\n/g) || []).length\n    rows = Math.min(maxRows, Math.max(minRows, lineBreaks + 1))\n  }\n\n  document.body.removeChild(clone)\n\n  return rows\n}\n\nconst HIDDEN_TEXTAREA_STYLE = {\n  \"min-height\": \"0\",\n  \"max-height\": \"none\",\n  height: \"0\",\n  visibility: \"hidden\",\n  overflow: \"hidden\",\n  position: \"absolute\",\n  \"z-index\": \"-1000\",\n  top: \"0\",\n  right: \"0\",\n} as const\n\nconst forceHiddenStyles = (el: HTMLElement) => {\n  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach((key) => {\n    el.style.setProperty(\n      key,\n      HIDDEN_TEXTAREA_STYLE[key as keyof typeof HIDDEN_TEXTAREA_STYLE],\n      \"important\",\n    )\n  })\n}\n\nexport default useAutosize\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}